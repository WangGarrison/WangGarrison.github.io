<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构：大数据问题的处理——散列、堆排</title>
      <link href="/2020/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%A3%E5%88%97%E3%80%81%E5%A0%86%E6%8E%92/"/>
      <url>/2020/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%A3%E5%88%97%E3%80%81%E5%A0%86%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1>题目引出</h1><hr><blockquote><p>在文件中产生10 0000个随机数字，数字的取值范围0~32767，按如下要求实现，在实现过程中能够使用的数组最长为10000，个别变量的内存忽略</p><ol><li>找到重复次数最多的那个数字(如果有多个，选择任意一个)</li><li>找到重复次数最多的前100个</li></ol></blockquote><h1>算法思路</h1><hr><p><strong>第一问</strong>：找到重复次数最多的那个数字(如果有多个，选择任意一个)</p><ol><li>首先用文件产生十万个随机数字</li><li>遍历这十万个数据，开辟一个数组充当计数器，因为题目要求能够使用的数组最长为一万，且数据取值范围到32767，因而要把十万个数据分组统计，每一组的个数不超过10000个，<font color='red'>由于分组的结果不能影响最后统计数字次数的结果，因而不能直接一刀切分组，要进行散列分组(即哈希，可对4取余利用余数分组)</font>，分别存入四个文件(哈希文件)，第一个哈希文件是对4取余余数为0的数，第二个哈希文件是对4取余余数为1的数…</li><li>分别找到每个哈希文件中次数最多的数字，进而求得四个文件中数字次数的冠军</li></ol><p><strong>第二问</strong>：找到重复次数最多的前100个</p><ol><li>对每个哈希文件进行堆排序，得到每个文件中重复次数最多的前100个</li><li>再综合这四百个数字，得到次数排名前100</li></ol><h1>具体实现</h1><hr><h2 id="宏定义">宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 100000  <span class="comment">//十万个随机数字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_NUM 10000<span class="comment">//计数器大小为1万</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> //定义数对</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//数字</span></span><br><span class="line"><span class="keyword">int</span> times; <span class="comment">//次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一问：找到重复次数最多的那个数字">第一问：找到重复次数最多的那个数字</h2><h3 id="1-首先用文件产生十万个随机数字">1.首先用文件产生十万个随机数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span><span class="comment">//产生MAX_NUM个随机数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fw = fopen(path, <span class="string">"wb"</span>);</span><br><span class="line">assert(fw != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = rand();</span><br><span class="line">fwrite(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fw);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辅助函数：显示path路径文件里边的数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span><span class="comment">//显示path文件含有的数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line">assert(fr != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, tmp);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-统计一个hash文件中出现次数最多的数字">2.统计一个hash文件中出现次数最多的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pair <span class="title">HashFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(ITEM_NUM, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line">assert(arr != <span class="literal">NULL</span> &amp;&amp; fr != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//统计hash文件中每个数字出现的次数</span></span><br><span class="line"><span class="comment">//文件0：0,4,8-&gt;0,1,2  文件1：1,5,9-&gt;0,1,2  文件2：2,6,10-&gt;0,1,2  文件3：3,7,11-&gt;0,1,2  哈希函数y=x/4</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)<span class="comment">//(0,1,2,3)-&gt;0，即四个文件中最小的数字对应的计数器下标都是0</span></span><br><span class="line">&#123;</span><br><span class="line">arr[tmp / <span class="number">4</span>]++;<span class="comment">//hash函数 y = x/4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到次数最多的数字及次数 </span></span><br><span class="line">Pair pa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITEM_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pa.times &lt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line">pa.num = i * <span class="number">4</span> + tmp % <span class="number">4</span>; <span class="comment">//反推：0-&gt;(0,1,2,3)，i*4加该文件数字对4的余数</span></span><br><span class="line">pa.times = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fr);</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line"><span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-统计文件中出现次数最多的数字">3.统计文件中出现次数最多的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pair <span class="title">MaxTimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//生成四个不同的文件名</span></span><br><span class="line"><span class="keyword">char</span> pathArr[<span class="number">4</span>][<span class="number">20</span>];<span class="comment">//四个文件名，0.txt  1.txt  2.txt  3.txt</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//批量生成文件名</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(pathArr[i], <span class="string">"%d.txt"</span>, i);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//定义四个hash文件并打开</span></span><br><span class="line">FILE *fw[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fw[i] = fopen(pathArr[i], <span class="string">"wb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将原来的数据散列到四个hash文件中</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fwrite(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fw[tmp % <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fclose(fw[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计每个hash文件中出现次数最多的数字</span></span><br><span class="line">Pair paArr[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">paArr[i] = HashFile(pathArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到四个里面次数最大的</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//保存次数最多的数据下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (paArr[index].times &lt; paArr[i].times)</span><br><span class="line">&#123;</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> paArr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-主函数测试">4.主函数测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*path = <span class="string">"big.txt"</span>;</span><br><span class="line">CreateBigFile(path);</span><br><span class="line"></span><br><span class="line">Pair pa = MaxTimes(path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"十万个数据中重复次数最多的是：\n\n 数字=%d，次数=%d\n\n"</span>, pa.num, pa.times);</span><br><span class="line"><span class="comment">//Show(path);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201017205232765.png#pic_left" alt="在这里插入图片描述"></p><h3 id="5-散列生成的文件">5.散列生成的文件</h3><p><img src="https://img-blog.csdnimg.cn/20201017210751749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_left" alt="在这里插入图片描述"></p><h2 id="第二问：找到重复次数最多的前100个">第二问：找到重复次数最多的前100个</h2><h3 id="1-找每一个哈希文件中次数最多的前100名">1.找每一个哈希文件中次数最多的前100名</h3><p>注意：由于哈希，数字存放的位置和数字本身有映射关系，而排序的交换会破坏这种关系，所以数字本身和它的次数都得保存起来，因而计数器数组元素类型要改成结构体Pair类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计hash文件中出现次数最多的前100个数字，计数器限制为ITEM_NUM</span></span><br><span class="line"><span class="function">Pair *<span class="title">HashFile2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//arr 为ITEM_NUM长的int型数组，计数器  注意：数字存放的位置和数字本身有关系</span></span><br><span class="line"><span class="comment">//将arr改为元素类型为Pair的数组</span></span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line">Pair *arr = (Pair*)<span class="built_in">calloc</span>(ITEM_NUM ,  <span class="keyword">sizeof</span>(Pair));</span><br><span class="line">assert(fr != <span class="literal">NULL</span> &amp;&amp; arr!=<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//统计hash文件中每个数字出现的次数</span></span><br><span class="line"><span class="comment">//文件0：0,4,8-&gt;0,1,2  文件1：1,5,9-&gt;0,1,2  文件2：2,6,10-&gt;0,1,2  文件3：3,7,11-&gt;0,1,2  哈希函数y=x/4</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)<span class="comment">//(0,1,2,3)-&gt;0，即四个文件中最小的数字对应的计数器下标都是0</span></span><br><span class="line">&#123;</span><br><span class="line">arr[tmp / <span class="number">4</span>].num = tmp;</span><br><span class="line">arr[tmp / <span class="number">4</span>].times++;<span class="comment">//hash函数 y = x/4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对arr数组按times递减排序, 排序选用堆排序，只需要得到前100个</span></span><br><span class="line">HeapSort(arr, ITEM_NUM);</span><br><span class="line">fclose(fr);</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在筛出的400个数据里找次数排名前100">2.在筛出的400个数据里找次数排名前100</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在筛出的400个数据里找次数前100的</span></span><br><span class="line"><span class="function">Pair * <span class="title">MaxTimes2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//生成四个不同的文件名</span></span><br><span class="line"><span class="keyword">char</span> pathArr[<span class="number">4</span>][<span class="number">20</span>];<span class="comment">//四个文件名，0.txt  1.txt  2.txt  3.txt</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//批量生成文件名</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(pathArr[i], <span class="string">"%d.txt"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义四个hash文件并打开</span></span><br><span class="line">FILE *fw[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fw[i] = fopen(pathArr[i], <span class="string">"wb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将原来的数据散列到四个hash文件中</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fwrite(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fw[tmp % <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fclose(fw[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计每个hash文件中出现次数的前100-----------</span></span><br><span class="line">Pair *arr[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = HashFile2(pathArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//400个里面找前100, 先把400个数对汇总到一起</span></span><br><span class="line">Pair *fourHundred = (Pair*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Pair) * <span class="number">400</span>);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">fourHundred[index++] = arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//汇总的400个数据进行递减式堆排</span></span><br><span class="line">HeapSort(fourHundred, <span class="number">400</span>);</span><br><span class="line"><span class="keyword">return</span> fourHundred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-附：递减式堆排代码-针对Pair类型">3.附：递减式堆排代码(针对Pair类型)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////// 递减式堆排序 //////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//一次堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(Pair *arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span><span class="comment">//start起始下标，end结尾下标，O(logn)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pair tmp = arr[start];</span><br><span class="line"><span class="keyword">int</span> parent = start;<span class="comment">//标记父节点下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= <span class="built_in">end</span>; i = <span class="number">2</span> * i + <span class="number">1</span>)<span class="comment">//i下一次要到它的左孩子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找左右孩子的较大值</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; arr[i].times &gt; arr[i + <span class="number">1</span>].times)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//i变为左右孩子较大值的下标</span></span><br><span class="line"><span class="keyword">if</span> (arr[i].times &lt; tmp.times)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//arr[(i - 1) / 2] = arr[i];//放到i的父节点</span></span><br><span class="line">arr[parent] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent = i;<span class="comment">//更新下一次i的父节点</span></span><br><span class="line">&#125;</span><br><span class="line">arr[parent] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(Pair *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(nlogn)，O(1)，不稳定(父子相互交换数据，父子下标是跳跃式的)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//建立大根堆，O(nlogn)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//len-1最后一个的下标，再减一除以二是它的父节点下标，从后往前多次调整</span></span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(arr, i, len - <span class="number">1</span>);<span class="comment">//每一个i都遍历到len-1作为end，因为即使有的没有len-1这个子节点，也不影响，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次将根和待排序最后的值交换，然后再调整,O(nlogn)</span></span><br><span class="line">Pair tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[len - <span class="number">1</span> - i];</span><br><span class="line">arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line"></span><br><span class="line">HeapAdjust(arr, <span class="number">0</span>, len - <span class="number">2</span> - i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-主函数测试：">4.主函数测试：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*path = <span class="string">"big.txt"</span>;</span><br><span class="line">CreateBigFile(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一问</span></span><br><span class="line">Pair pa = MaxTimes(path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"十万个数据中重复次数最多的是：\n\n 数字=%d，次数=%d\n\n"</span>, pa.num, pa.times);</span><br><span class="line"><span class="comment">//Show(path);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二问</span></span><br><span class="line">Pair *pa2 = MaxTimes2(path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"重复数字最多的前100个：\n\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d %d)  "</span>, pa2[i].num, pa2[i].times);</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201017232146157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><h2 id="总结">总结</h2><hr><p>对于上述问题，其实主要就干了三件事</p><ol><li><font color='red'>对大文件散列(哈希)，得到多个哈希文件</font></li><li><font color='red'>再得到每个哈希文件中次数最多的数字</font></li><li><font color='red'>得到所有文件中重复次数最多的数字</font></li></ol><p>对于处理类似数据多而可用内存少的大数据问题，核心思想就是<font color='red'><strong>先哈希, 再堆排</strong></font></p><hr><h1>海量数据问题</h1><hr><p>海量数据处理，就是基于海量数据上的存储、处理、操作。海量数据问题，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p><h2 id="处理海量问题的基本思路">处理海量问题的基本思路</h2><ol><li>分而治之/hash映射 + hash统计 +堆/快速/归并排序；</li><li>双层桶划分</li><li>Bloom filter/Bitmap；</li><li>Trie树/数据库/倒排索引；</li><li>外排序；</li><li>分布式处理之Hadoop/Mapreduce。</li></ol><h2 id="例1：海量日志数据，提取出某日访问百度次数最多的那个IP">例1：海量日志数据，提取出某日访问百度次数最多的那个IP</h2><p><strong>算法思想：分而治之+Hash</strong></p><ol><li>IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理</li><li>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址</li><li>对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址</li><li>可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP</li></ol><h2 id="例2：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节">例2：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节</h2><p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p><strong>基本思想：哈希+堆排</strong></p><ul><li>先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计</li><li>借助堆这个数据结构，找出Top K，时间复杂度为N‘logK</li></ul><p>即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）</p><h2 id="例3：有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词">例3：有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</h2><p><strong>基本思想：哈希+堆排+归并</strong></p><ul><li>顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右</li><li>如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M</li><li>对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件</li><li>把这5000个文件进行归并，得到所有中频数最高的前100个单词</li></ul><h2 id="总结-2">总结</h2><hr><p>大数据问题的处理：<font color='red'><strong>哈希+堆排</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：排序算法汇总</title>
      <link href="/2020/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2020/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="冒泡排序-Bubble-Sort">冒泡排序(Bubble Sort)</h2><hr><p><strong>算法思路</strong>：依次比较两个相邻的元素，大的往后，小的往前，每一趟比较都把最大的元素放到末尾，越小的元素会经由交换慢慢“浮”到数列的顶端，因而称之为冒泡排序</p><p><strong>时间复杂度</strong>：O(n^2）</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：冒泡排序的比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定</strong>排序算法</p><p><strong>冒泡排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20200921173942278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200921171828440.gif#pic_center" alt="冒泡排序"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span>  <span class="comment">//冒泡排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//两两比较，小的往前，大的往后，每一趟把最大的放到最后</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">1</span>&lt; len - i ; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序-Selection-Sort">选择排序(Selection Sort)</h2><hr><p><strong>算法思路</strong>：第一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小元素，然后放到已排序的序列的末尾，即<strong>每次从待排序数据中选个&quot;最小值&quot;和&quot;第一个交换&quot;</strong></p><p><strong>时间复杂度</strong>：O(n^2)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定，有跳跃式地交换数据，例：序列5 8 5 2 9，第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法</p><p><strong>选择排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20200921180226635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200921180311930.gif#pic_center" alt="在这里插入图片描述"><br><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span>  <span class="comment">//选择排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//每一趟选出最小的放到最前面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minindex;  <span class="comment">//保存最小值的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">minindex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i +<span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[minindex])</span><br><span class="line">&#123;</span><br><span class="line">minindex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选出来的最小值与“第一个”进行交换</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">tmp = arr[i];</span><br><span class="line">arr[i] = arr[minindex];</span><br><span class="line">arr[minindex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="直接-插入排序-Insertion-Sort">(直接)插入排序(Insertion Sort)</h2><hr><p><strong>算法思路</strong>：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。即将待排序数据看成两个部分，左边部分为已经排序好的数据，右部分为待排序数据，从右边的数据中取一个数，插入到左边的合适位置使左边部分始终保持有序</p><p><strong>时间复杂度</strong>：最坏O(n^2)，最好O(n)，平均O(n^2)<br><font color='red'>插入排序待排序数列越有序越快，完全有序时间复杂度为O(n) </font></p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：稳定</p><p><strong>插入排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20200921183352227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200921183444857.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//每次从右部分取出一个插入到左边的合适位置</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)<span class="comment">//遍历右部分</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)<span class="comment">//j是左部分数列游标</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= arr[j])<span class="comment">//右边取出的大于左边的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//右边取出的小于左边的</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];<span class="comment">//左部分数列后移</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>] = tmp;<span class="comment">//把右边取出的那个数插入到左边的合适位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="希尔排序-Shell-Sort">希尔排序(Shell Sort)</h2><hr><p><strong>希尔排序</strong>：是插入排序的一种，又称缩小增量排序，是直接插入排序的一种更高效的改进版本。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li><p>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</p></li><li><p>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p></li></ul><p>希尔排序与插入排序的不同之处在于，<strong>它会通过设定带间隔的分组</strong>，优先比较距离较远的元素（同时破坏了稳定性）</p><p><strong>算法思路</strong>：定义一个间隔序列来表示排序过程中进行比较的元素之间有多远的间隔，每次将具有相同间隔的数分为一组，进行插入排序，最后一个分组组数必须是1，当最后一组执行完插入排序，排序结束</p><p><strong>时间复杂度</strong>：O(n^1.3)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定</p><p><strong>希尔排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/2020092423523516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200924235318162.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shell</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len,<span class="keyword">int</span> gap)</span><span class="comment">//每一个分组的排序 ,gap是分组的间隔</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (i = gap; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span>; j-=gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j + gap] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span>  <span class="comment">//希尔排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d[] = &#123; <span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span> &#125;;<span class="comment">//设定分组的序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(d) / <span class="keyword">sizeof</span>(d[<span class="number">0</span>]); i++)<span class="comment">//按设定的分组间隔依次分组排序</span></span><br><span class="line">&#123;</span><br><span class="line">Shell(arr, len, d[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充</strong>：关于希尔排序的增量与复杂度的关系</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20200924235954641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><hr><h2 id="快速排序-Quick-Sort">快速排序(Quick Sort)</h2><hr><p><strong>算法思路</strong>：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的</p><ul><li>在待排序数据中选取一个数据作为基准(可选择第一个数据)</li><li>使用基准数据将剩余的数据分成两部分，左部分（不一定有序）都比基准小，右部分（不一定有序）都比基准大</li><li>分别再对左部分和右部分（至少有两个数据）进行快速排序（递归）</li></ul><p><strong>时间复杂度</strong>：O(nlogn)，如果数列本来就有序，则快排退化为选择排序，时间复杂度退为O(n^2)，快排越有序越慢，因为选好基准数据后，它是从后往前依次找比基准数据小的数据</p><p><strong>空间复杂度</strong>：O(logn)，递归涉及到函数栈的开辟</p><p><strong>稳定性</strong>：不稳定</p><p><strong>快速排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201004111352387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201004125403870.gif#pic_center" alt="在这里插入图片描述"><br>（该动图每次把基准与数字进行交换，代码中是用tmp来保存基准，没有交换）</p><p><strong>C代码</strong>：三个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//快排的一次过程，把一个基准扣下来，从后往前找比它小的，从前往后找比它大的</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//QuickSort的中间层马甲</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排的一次划分，笔试的重点，low起始下标，high结尾下标</span></span><br><span class="line"><span class="comment">//把一个基准扣下来，从后往前找比它小的，从前往后找比它大的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//一次划分：O(n)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[low];<span class="comment">//基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从后往前找比基准小的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[high]&lt;tmp)<span class="comment">//找到比基准小的数字</span></span><br><span class="line">&#123;</span><br><span class="line">arr[low] =arr[high];<span class="comment">//将数字放到前面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前往后找比基准大的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high&amp;&amp;arr[low] &lt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">arr[high] = arr[low];<span class="comment">//将数字放到后面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[low] = tmp;<span class="comment">//基准应该放的位置</span></span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//返回基准放好的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//QuickSort的中间层马甲</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//递归次数为O(logn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = Partition(arr, low, high);</span><br><span class="line"><span class="keyword">if</span> (mid - low &gt; <span class="number">1</span>)<span class="comment">//左边的数据超过一个就要继续排序</span></span><br><span class="line">&#123;</span><br><span class="line">Quick(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (high - mid &gt; <span class="number">1</span>)<span class="comment">//右边的数据超过一个就要继续排序</span></span><br><span class="line">&#123;</span><br><span class="line">Quick(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装快排接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(n*logn)，O(logn)，不稳定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Quick(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的非递归实现</strong>：只用修改Quick函数即可，用栈将一次快排划分的左右下标保存起来，非递归的时间复杂度与空间复杂度同递归实现的数量级是一样的，但是在同样的数据量下，非递归实现对空间消耗的绝对值较小，非递归栈只保存两个下标，而递归实现涉及的是函数栈</p><p><strong>快排非递归C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//一次划分：O(n)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[low];<span class="comment">//基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从后往前找比基准小的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[high]&lt;tmp)<span class="comment">//找到比基准小的数字</span></span><br><span class="line">&#123;</span><br><span class="line">arr[low] =arr[high];<span class="comment">//将数字放到前面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前往后找比基准大的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high&amp;&amp;arr[low] &lt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">arr[high] = arr[low];<span class="comment">//将数字放到后面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[low] = tmp;<span class="comment">//基准应该放的位置</span></span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//返回基准放好的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排的非递归实现--------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack st;  <span class="comment">//栈用来保存每次快排的左下标与右下标</span></span><br><span class="line">InitStack(&amp;st);</span><br><span class="line">Push(&amp;st, low);</span><br><span class="line">Push(&amp;st, high);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;st))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> right;</span><br><span class="line">Pop(&amp;st, &amp;right);<span class="comment">//把high给right</span></span><br><span class="line"><span class="keyword">int</span> left;</span><br><span class="line">Pop(&amp;st, &amp;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = Partition(arr, left, right);<span class="comment">//mid就是一次快排返回的基准位置  left......mid......right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mid - left &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;st, left);</span><br><span class="line">Push(&amp;st, mid - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right - mid &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;st, mid + <span class="number">1</span>);</span><br><span class="line">Push(&amp;st, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Destory(&amp;st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装快排接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(n*logn)，O(logn)，不稳定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Quick2(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的优化</strong></p><blockquote><p>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p><ul><li>选择基准的方式：</li></ul><ol><li>固定位置，取序列的第一个或最后一个元素作为基准</li><li>随机选取基准</li><li>三位数取中，选取第一个、中间一个、最后一个数据排序取三者的中位数作为基准</li></ol></blockquote><blockquote><p>快排对于越有序的数列，其时间复杂度和空间复杂度都会增大，基于此可以进行优化。</p><ul><li>优化一： 当待排序序列的长度分割到一定大小后，使用插入排序。对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</li><li>优化二：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</li><li>优化三：优化递归操作</li><li>优化四：使用并行或多线程处理子序列</li><li>效率比较好的组合是：三数取中+插排+聚集相等元素</li></ul></blockquote><hr><h2 id="堆排序-Heap-Sort">堆排序(Heap Sort)</h2><hr><p><strong>预备知识</strong>：</p><blockquote><ul><li>完全二叉树：若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边，这就是完全二叉树</li><li>堆：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong>（父结点大于子结点）；或者每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong>（父结点小于子结点）</li><li><img src="https://img-blog.csdnimg.cn/20201005140431534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>大顶堆是一种逻辑结构，按层序遍历可映射为数组：<br><img src="https://img-blog.csdnimg.cn/20201005141300869.png#pic_center" alt="在这里插入图片描述"></li><li>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：<br>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]<br>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</li><li>对于完全二叉树，<strong>已知父结点下标i，则子结点下标2<em>i+1,2</em>i+2；已知子结点下标i，则父结点下标(i-1)/2</strong></li></ul></blockquote><p><strong>算法思路</strong>：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><ul><li>建立大顶堆（升序排序）</li><li>将堆顶元素与末尾元素交换，将最大元素放置在尾端</li><li>将去掉尾端元素剩下的继续调整为大顶堆，然后再将堆顶元素交换至末尾，再调整</li></ul><p>注意：建立大顶堆需要从后往前多次堆调整，而一次堆调整是从上往下比较的</p><p><strong>时间复杂度</strong>：O(nlogn)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定，跳跃式的交换数据</p><p><strong>堆排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201005143220893.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span><span class="comment">//start起始下标，end结尾下标，O(logn)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[start];</span><br><span class="line"><span class="keyword">int</span> parent = start;<span class="comment">//标记父节点下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= <span class="built_in">end</span>; i = <span class="number">2</span> * i + <span class="number">1</span>)<span class="comment">//i下一次要到它的左孩子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找左右孩子的较大值</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//i变为左右孩子较大值的下标</span></span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//arr[(i - 1) / 2] = arr[i];//放到i的父节点</span></span><br><span class="line">arr[parent] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent = i;<span class="comment">//更新下一次i的父节点</span></span><br><span class="line">&#125;</span><br><span class="line">arr[parent] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(nlogn)，O(1)，不稳定(父子相互交换数据，父子下标是跳跃式的)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//建立大根堆，O(nlogn)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//len-1最后一个的下标，再减一除以二是它的父节点下标，从后往前多次调整</span></span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(arr, i, len - <span class="number">1</span>);<span class="comment">//每一个i都遍历到len-1作为end，因为即使有的没有len-1这个子节点，也不影响，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次将根和待排序最后的值交换，然后再调整,O(nlogn)</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[len - <span class="number">1</span> - i];</span><br><span class="line">arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line"></span><br><span class="line">HeapAdjust(arr, <span class="number">0</span>, len - <span class="number">2</span> - i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="归并排序-Merge-Sort">归并排序(Merge Sort)</h2><hr><p><strong>算法思路</strong>：归并排序就是利用分治归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列，再两两归并，…，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为二路归并排序</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置，重复该步骤直到某一指针超出序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><p><strong>时间复杂度</strong>：O(nlogn)</p><p><strong>空间复杂度</strong>：O(n)</p><p><strong>稳定性</strong>：稳定，没有交换数据，归并排序是一种比较占用内存，但却效率高且稳定的排序算法</p><p><strong>归并排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201005192958335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201005192600741.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> gap)</span><span class="comment">//gap归并段的长度，O(n)，O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low1 = <span class="number">0</span>;<span class="comment">//第一个归并段的起始下标</span></span><br><span class="line"><span class="keyword">int</span> high1 = gap - <span class="number">1</span>;<span class="comment">//第一个归并段的结束下标</span></span><br><span class="line"><span class="keyword">int</span> low2 = high1+<span class="number">1</span>;<span class="comment">//第二个归并段的起始下标</span></span><br><span class="line"><span class="keyword">int</span> high2 = low2 + gap &lt; len ? low2 + gap - <span class="number">1</span> : len - <span class="number">1</span>;<span class="comment">//第二个归并段的结束下标</span></span><br><span class="line"><span class="keyword">int</span> *brr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//brr的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low2 &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两个归并段都有数据就要进行归并</span></span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[low1] &lt;= arr[low2])</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个归并段的数据已经完成，另一个还有数据</span></span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1)</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (low2 &lt;= high2)</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入到下一块的归并</span></span><br><span class="line">low1 = high2 + <span class="number">1</span>;</span><br><span class="line">high1 = low1 + gap - <span class="number">1</span>;</span><br><span class="line">low2 = high1 + <span class="number">1</span>;</span><br><span class="line">high2 = low2 + gap &lt; len ? low2 + gap - <span class="number">1</span> : len - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打单的段</span></span><br><span class="line"><span class="keyword">while</span> (low1 &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = brr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(brr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(nlogn)，O(n)，稳定(没有交换数据)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)<span class="comment">//O(logn)</span></span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, len, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="基数排序-Radix-Sort">基数排序(Radix Sort)</h2><hr><p><strong>算法思路</strong>：基数排序是一种非比较型排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较，基数排序属于“分配式排序”，又称“桶子法”（bucket sort）或bin sort，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用（低位优先，多关键字排序）</p><ul><li>首先取得待排序数列中的最大值，其位数就是进出的趟数</li><li>根据每个数的低位关键字将数字分配至不同的桶中</li><li>各个桶依次出尽数据组成新的队列，再根据下一个低位关键字入队列、出队列，如此反复直至所有位均已完毕，数列便有序</li></ul><p><strong>时间复杂度</strong>：O(d*n)，d是待排序数列最大值的位数</p><p><strong>空间复杂度</strong>：O(n)</p><p><strong>稳定性</strong>：稳定</p><p><strong>基数排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201006161123509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201006153507672.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////  基数排序需要用到的链式队列  //////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Node *front;<span class="comment">//队头</span></span><br><span class="line">Node *rear;<span class="comment">//队尾</span></span><br><span class="line">&#125;HNode,*Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(q != <span class="literal">NULL</span>);</span><br><span class="line">q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Queue q, <span class="keyword">int</span> val)</span><span class="comment">//入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p-&gt;data = val;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsEmpty(q))</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;front = p;</span><br><span class="line">q-&gt;rear = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;rear-&gt;next = p;</span><br><span class="line">q-&gt;rear = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(Queue q, <span class="keyword">int</span> *rtval)</span><span class="comment">//出队列获取队头的值，且删除队头</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (IsEmpty(q))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rtval != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*rtval = q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">Node *p = q-&gt;front;</span><br><span class="line">q-&gt;front = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)<span class="comment">//刚才删除的是最后一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////  基数排序  //////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取十进制数字的位数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125; <span class="keyword">while</span> (n != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到十进制num右数第n位的数字(从0开始)，例：(123,0)-&gt;3, (123,1)-&gt;2, (123,2)-&gt;1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Key</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span><span class="comment">//得到当前数的关键字（此时该入的对列）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//不停的丢个位数字</span></span><br><span class="line">&#123;</span><br><span class="line">num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一趟的具体进出，利用链式队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Radix</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> n)</span><span class="comment">//n是十进制右数第几位，0个位，1十位，2百位...</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HNode qrr[<span class="number">10</span>];<span class="comment">//10个队列的队头结点</span></span><br><span class="line"><span class="keyword">int</span> k;<span class="comment">//需要进的队列的编号/关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//初始化队列</span></span><br><span class="line">&#123;</span><br><span class="line">InitQueue(&amp;qrr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">k = Key(arr[i], n);<span class="comment">//获取该入的队列编号</span></span><br><span class="line">Push(&amp;qrr[k], arr[i]);<span class="comment">//arr[i]放入k号对列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，10个队列依次全出</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//arr下标，出的数据要放入arr中去</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;qrr[j]))<span class="comment">//只要当前队列不为空，就要一直出数据</span></span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;qrr[j], &amp;arr[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> <span class="comment">//O(d*n)，d是最大值的位数，O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//首先找到最大值</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到进队和出队的趟数，即最大值的位数</span></span><br><span class="line"><span class="keyword">int</span> n= GetDigit(<span class="built_in">max</span>);</span><br><span class="line"><span class="comment">//进出n趟</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">Radix(arr, len, i);<span class="comment">//i是每一趟进出的关键字</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////  基数排序以上  ////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结">总结</h2><hr><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(d*n)</td><td>O(d*n)</td><td>O(n)</td><td>稳定</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：栈的应用—中缀表达式转后缀表达式、后缀表达式的运算</title>
      <link href="/2020/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="后缀（逆波兰）表达式">后缀（逆波兰）表达式</h2><p><strong>中缀表达式</strong>：就是我们平时用的标准四则运算表达式，运算符在操作数中间，例如：9+（3-1）*3+10/2</p><p><strong>后缀表达式</strong>：也称为逆波兰表达式，是将运算符写在操作数之后的表达式，例如上式的后缀表达式为：9 3 1 - 3 * + 10 2 / +</p><p><strong>作用</strong>：对计算机而言，中缀表达式是比较复杂的结构，而逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构，它执行先进后出的顺序</p><hr><h2 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h2><p><strong>例</strong>：中缀表达式 <font color='red'>9+（3-1）*3+10/2 </font>转换为后缀表达式 <font color='red'>9 3 1 - 3 * + 10 2 / +</font></p><p><strong>人眼观察方法</strong>：因为a + b 转为后缀表达式是 a b +，先在表达式中找最先运算的子式转成后缀表达式，如下图要先算3-1，转后缀为31-，再把31-看为一个整体A，则接下来运算A * 3,转为后缀即为A 3 *,即3 1 - 3 *，依次类推就可推出最终转成的后缀表达式为9 3 1 - 3 * + 10 2 / +<br><img src="https://img-blog.csdnimg.cn/20200928172718270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>程序算法思路</strong>：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止，总结如下：<br><img src="https://img-blog.csdnimg.cn/20200903125326214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>详细过程如下</strong>： <font color='red'>9+（3-1）*3+10/2 </font>转换为后缀表达式 <font color='red'>9 3 1 - 3 * + 10 2 / +</font></p><ol><li><p>初始化一空栈，用来对符号进出栈使用，如下图左侧</p></li><li><p>第一个是数字9，直接输出，后面是符号+，进栈，如下图右侧<img src="https://img-blog.csdnimg.cn/2020090311211026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>第三个字符是（，左括号还未配对，入栈，如下图左侧</p></li><li><p>第四个字符是数字3，直接输出，总表达式为9 3，接着是-，进栈，如下图右侧<img src="https://img-blog.csdnimg.cn/2020090311234826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>接下来是数字1，输出，总表达式为9 3 1，后面是），此时，要去匹配之前的左括号，所以栈顶依次输出，直到（出栈。总的表达式现在为9 3 1 -，栈中剩下+，如下图左侧</p></li><li><p>紧接着是*，因为此时栈顶为+号，优先级低于乘号，因此不输出，乘号进栈，接着是数字3，输出，总表达式为9 3 1 - 3，如下图右侧<img src="https://img-blog.csdnimg.cn/20200903112719488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>之后是+，此时栈顶为乘号，栈顶优先级高，因此栈中元素出栈并输出（没有比+更低的优先级，所以全部出栈），总输出表达式9 3 1 - 3 * +。然后将当前这个符号+进栈，如下图左侧</p></li><li><p>紧接着是数字10，直接输出，总表达式变为9 3 1 - 3 * + 10。然后是/ ,栈顶+优先级低于除号，/进栈，如下图右侧<img src="https://img-blog.csdnimg.cn/20200903113358503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>接下来是最后一个数字2，输出，表达式为9 3 1 - 3 * +10 2，如下图左侧</p></li><li><p>中缀表达式遍历结束，将栈中符号依次全部出栈并输出，最后输出的后缀表达式为：9 3 1 - 3 * +10 2 / + <img src="https://img-blog.csdnimg.cn/20200903113623733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ol><p><strong>C代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中缀表达式转后缀表达式</span></span><br><span class="line"><span class="comment">//中缀表达式存储在字符串中，为便于表示，代码使用9+(3-1)*3+8/2为例子</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack s;</span><br><span class="line">InitStack(&amp;s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> mid[] = <span class="string">"9+(3-1)*3+8/2"</span>;  <span class="comment">//中缀表达式</span></span><br><span class="line"><span class="keyword">char</span> back[<span class="number">14</span>];  <span class="comment">//后缀表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> useless;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid[i] &lt;= <span class="string">'9'</span>&amp;&amp;mid[i] &gt;= <span class="string">'0'</span>)  <span class="comment">//是数字，直接输出</span></span><br><span class="line">&#123;</span><br><span class="line">back[j] = mid[i];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">'('</span>)  <span class="comment">//是左括号，直接入栈</span></span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;s, mid[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">')'</span>)  <span class="comment">//是右括号，栈中出栈直到第一个左括号出栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (GetTop(&amp;s) != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">Pop(&amp;s, &amp;useless);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">'*'</span> || mid[i] == <span class="string">'/'</span>)  <span class="comment">//是*/，出栈，直到栈空或者栈中遇到左括号或+-，当前符号入栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;s) &amp;&amp; (GetTop(&amp;s) != <span class="string">'+'</span> &amp;&amp; GetTop(&amp;s) != <span class="string">'-'</span>))</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">Push(&amp;s, mid[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">'+'</span> || mid[i] == <span class="string">'-'</span>)  <span class="comment">//是+-，出栈，直到栈空或者左括号当前符号入栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;s)&amp;&amp;GetTop(&amp;s) != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">Push(&amp;s, mid[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中缀表达式遍历结束，要将栈中剩余符号依次弹出</span></span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;s))</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">back[j] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"中缀表达式： %s\n\n"</span>, mid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"后缀表达式： %s\n\n"</span>, back);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：<br><img src="https://img-blog.csdnimg.cn/20200903145703175.png#pic_center" alt="在这里插入图片描述"></p><hr><h2 id="计算机如何用后缀表达式求值">计算机如何用后缀表达式求值</h2><p><strong>例如</strong>：中缀表达式 <font color='red'>9+（3-1）*3+10/2 </font>的后缀表达式 <font color='red'>9 3 1 - 3 * + 10 2 / +</font>，计算机如何用该后缀表达式进行运算呢</p><p><strong>规则</strong>：从左到右遍历<strong>后缀</strong>表达式的每个数字和符号，遇到数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果</p><p><strong>详细过程如下</strong>：<font color='red'><strong>9 3 1 - 3 * + 10 2 / +</strong></font></p><ol><li>初始化一个空栈，该栈用来对要运算的数字进出使用</li><li>后缀表达式中前三个都是数字，所以9 3 1依次进栈，如下图<br><img src="https://img-blog.csdnimg.cn/20200903104948554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>接下来是 - 运算符，所以将栈顶的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈，如下图左侧</li><li>接着是数字3进栈，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903105318923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>接下来是* ，也就意味着栈中3与2出栈，相乘得到6，再将6入栈，如下图左侧</li><li>再下来是+ ，将6与9出栈，相加得到15，再将15入栈，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903105625715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>接着是10与2两数字进栈，如下图左侧</li><li>接下来是/ ，因此栈顶的2与10出栈，10与2相除得到5，5入栈，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903105805650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>最后是运算符+ ，所以5与15出栈相加得到20，再将20进栈，如下图左侧</li><li>后缀表达式遍历结束，最后栈中结果是20出栈，栈变为空，计算结束，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903110059180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ol><p>以上可以看出后缀表达式可以很顺利地解决计算问题，因此后缀表达式是很重要的</p><hr><p><strong>综上，要想让计算机拥有处理我们通常的标准（中缀）表达式的能力，最重要的是两大步</strong>：</p><ul><li><strong>将中缀表达式转换为后缀表达式（栈用来进出运算的符号）</strong></li><li><strong>将后缀表达式进行运算得到结果（栈用来进出运算的数字）</strong></li></ul><p><strong>上述过程充分利用了栈的后进先出特性，是栈这种数据结构比较重要的应用</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：BF算法-KMP算法</title>
      <link href="/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ABF%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ABF%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="BF算法">BF算法</h2><hr><p>BF(Brute Force)算法，即暴力算法，是普通的串的模式匹配算法，BF算法是一种蛮力算法</p><p>BF算法的思想就是将目标串S(主串)的第一个字符与模式串T(子串)的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；<strong>若不相等，则比较S的第二个字符和T的第一个字符</strong>，依次比较下去，直到得出最后的匹配结果</p><p>BF算法效率并不高，因为每次没找到，主串都要回退到上一次开始的下一个位置</p><p><strong>BF算法时间复杂度O(m*n)      空间复杂度O(1)</strong></p><p>BF算法图解如下：<br><img src="https://img-blog.csdnimg.cn/20200921220553377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>C代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//返回 子串T 在 主串S 中第pos个字符之后的位置</span><br><span class="line">//时间复杂度：O(m*n) 空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">int BF(const char* S, const char *T,int pos)  //S主串，T子串</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S == NULL || T == NULL || pos &lt; 0 || pos &gt;= strlen(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i = pos;</span><br><span class="line">int j = 0;</span><br><span class="line">int len1 = strlen(S);//主串长度</span><br><span class="line">int len2 = strlen(T);//子串长度</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">/*回退到本次开始的下一个位置（i-j+1)，j回退到0*/</span><br><span class="line">i = i - j + 1;</span><br><span class="line">j = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &gt;= len2)  //子串走完即为查找成功</span><br><span class="line"><span class="built_in">return</span> i - j ;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BF算法的效率不高，时间复杂度<strong>O(m*n)</strong>，每次匹配失败主串游标 i 都要回退到本次开始的下一个位置，子串游标 j 要回退到0。而KMP算法改进了i，j的回退，避免了不必要的回溯，提高了效率，时间复杂度降到了<strong>O(m+n)</strong></p><h2 id="KMP算法">KMP算法</h2><hr><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，取他们姓首字母，即为KMP算法。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的</p><p><strong>KMP算法时间复杂度O(m+n) 空间复杂度O(n)</strong></p><p>在BF算法中，每次失配，主串游标 i 都要回退到 i-j+1，子串游标 j 要回退到0</p><p>但是其实在出现失配时，可以让 i 不回退，j 回退到该退的位置即可，如下图BF算法示意图中，第一次失配后，i 回溯到 i-j+1，j 回溯到0，但是我们可以发现之后的比较中，i 又回到了之前的位置，j 位置改变了而已（下图红框）</p><p><img src="https://img-blog.csdnimg.cn/20200921220852377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><font color='red'>KMP算法就是在出现失配时，让主串游标 i 不回退，利用之前失败的信息，让子串游标 j 退回到合适的位置</font></p><p>所以关键就是求出失配后子串游标 j 应该回溯的位置，我们用一个<strong>next数组</strong>来存储子串每个位置对应的 j 应该回溯的位置</p><p>把上面BF算法代码直接拷贝过来，修改 i,j 的回退即可完成KMP算法的大框架</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S, <span class="keyword">const</span> <span class="keyword">char</span> *T,<span class="keyword">int</span> pos)</span>  <span class="comment">//S主串，T子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span> || T == <span class="literal">NULL</span> || pos &lt; <span class="number">0</span> || pos &gt;= <span class="built_in">strlen</span>(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S);<span class="comment">//主串长度</span></span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(T);<span class="comment">//子串长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//修改i，j的回退</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//i不回退</span></span><br><span class="line"><span class="comment">//j要退到k</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &gt;= len2)  <span class="comment">//子串走完即为查找成功</span></span><br><span class="line"><span class="keyword">return</span> i - j ;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的任务就是要把 j 回退的位置 k 给求出来，即求出next数组</p><hr><h2 id="求next数组">求next数组</h2><p><font color='green'>预备知识：字符串的前缀、后缀</font></p><blockquote><p>前缀：首字符开始的子串<br>真前缀：首字符开始的子串，但不包含原串本身<br>后缀：以尾字符结尾的子串<br>真后缀：以尾字符结尾的子串，但不包含原串本身<br>例：ababc<br>前缀：a、ab、aba、abab、ababc<br>真前缀：a、ab、aba、abab<br>后缀：c、bc、abc、babc、ababc<br>真后缀：c、bc、abc、babc</p></blockquote><p><strong>如下例中</strong><br><img src="https://img-blog.csdnimg.cn/20200922230942153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在 i 是4,j 是4时发生失配，但是我们发现<strong>失配前的S串真后缀与T串真前缀出现相等</strong>，<strong>相等的部分就不用比较了</strong>，因此直接从相等的后面开始继续比较就好（如下图），即<strong>j回溯到相等串的后面，即j下标变为相等串的长度</strong>，所以关键就是求每次失配这个相等串的长度 k</p><p>又因为第一次比较中，失配前的四个字符S串与T串都是一一对应相等的，因此S串的真后缀也是T串的真后缀，因此<font color='red'><strong>k就是T串失配前的串的真前缀与真后缀相等时的长度值</strong></font><br><img src="https://img-blog.csdnimg.cn/20200922233902750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因而求k值的方法就是：在子串失配前找到相等的真前缀与真后缀，其长度就是k或者可以这样描述：</p><blockquote><p>在子串失配前找到最长两个相等的真子串，这两个真子串满足如下特点：<br>1.一个串以首字符开头<br>2.另一个串以失配前的最后一个字符作为结尾<br>k就是该真子串的长度</p></blockquote><p>上例T串每个字符对应的k值如下：<br>规定：next[0]=-1,next[0]=0</p><table><thead><tr><th>模式串T串</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p><strong>注意</strong>：还有一种常用的next数组表示，next[0]放的是0，next[1]是1，后续每一个k值都比上表里的大1，但是算法思路都是一样的，二者皆可，为便于编码，这里采用next[0] = -1这种方法</p><p><strong>手动已经可以求出next数组的值了，接下来就是用程序具体求出next数组：</strong></p><ol><li>对于任意串都可以确定其next[0] = -1,next[1] = 0;</li><li>设next[j] = k，即下标 j 之前的串的真前缀与真后缀相等的长度为k，即P0…Pk-1 == Pj-k…Pj-1，求next[j+1]</li><li>情况一：若Pk == Pj，则P0…Pk-1Pk = Pj-k…Pj-1Pj，即j+1对应的真前缀与真后缀相等时的值是k+1，即next[j+1] = k+1</li><li>情况二：若Pk != Pj，如下图，把P0…Pk放到Pk…Pj下面来看，则<font color='red'><strong>又要用到之前的思想，主串游标j不动，子串游标k往回退到合适位置</strong></font>，而子串游标k回退的位置在之前已经求出来了，是next[k]，所以k回退到next[k]，即<font color='red'><strong>k=next[k]</font></strong>，之后Pk再与Pj比较，如此往复直到Pk==Pj或k回溯到-1，k回溯到-1说明没有相等的真前缀与真后缀，那么next[j+1]赋值为0即可，或者next[j+1]=k+1，这也是next数组的第一个k值放-1的好处<br><img src="https://img-blog.csdnimg.cn/20200927162838750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>next数组的C代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* T,<span class="keyword">int</span> * next)</span>  <span class="comment">//根据子串T获取它的next数组(用来存放所有的k值)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lenT = <span class="built_in">strlen</span>(T);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T[k] == T[j] || k == <span class="number">-1</span>  )<span class="comment">//Pk==Pj，k为-1就没必要回退了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next[j + 1] = k + 1;</span></span><br><span class="line"><span class="comment">j++;</span></span><br><span class="line"><span class="comment">k++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">next[++j] = next[++k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//Pk != Pj</span></span><br><span class="line">&#123;</span><br><span class="line">k = next[k];<span class="comment">//主串游标j不动，子串游标k往回退</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>至此，next数组已经求出，即主串游标不动、子串游标j回退的位置已经求出，最后把j = next[j]放入失配条件下，KMP算法就完成了，KMP算法全部的C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* T, <span class="keyword">int</span> * next)</span></span>;  <span class="comment">//声明获取next数组的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S, <span class="keyword">const</span> <span class="keyword">char</span> *T, <span class="keyword">int</span> pos)</span>  <span class="comment">//S主串，T子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span> || T == <span class="literal">NULL</span> || pos &lt; <span class="number">0</span> || pos &gt;= <span class="built_in">strlen</span>(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S);<span class="comment">//主串长度</span></span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(T);<span class="comment">//子串长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len2 * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">GetNext(T, next);<span class="comment">//求next数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; len1&amp;&amp;j &lt; len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j] || j==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//i不回退</span></span><br><span class="line">j = next[j];<span class="comment">//j回退到k</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(next);</span><br><span class="line"><span class="keyword">if</span> (j &gt;= len2)  <span class="comment">//子串走完即为查找成功</span></span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* T, <span class="keyword">int</span> * next)</span>  <span class="comment">//根据子串T获取它的next数组(用来存放所有的k值)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lenT = <span class="built_in">strlen</span>(T);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T[k] == T[j] || k == <span class="number">-1</span>)<span class="comment">//Pk==Pj，k为-1就没必要回退了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next[j + 1] = k + 1;</span></span><br><span class="line"><span class="comment">j++;</span></span><br><span class="line"><span class="comment">k++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">next[++j] = next[++k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//Pk != Pj</span></span><br><span class="line">&#123;</span><br><span class="line">k = next[k];<span class="comment">//主串游标j不动，子串游标k往回退</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：makefile</title>
      <link href="/2020/09/12/Linux%EF%BC%9Amakefile/"/>
      <url>/2020/09/12/Linux%EF%BC%9Amakefile/</url>
      
        <content type="html"><![CDATA[<h2 id="makefile是什么">makefile是什么</h2><p><strong>makefile</strong>： makefile是linux下对源文件的自动编译工具，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中， makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令</p><p><strong>make</strong>：make 是一个命令工具，是一个解释 makefile中指令的命令工具，makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率</p><h2 id="makefile文件">makefile文件</h2><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序，该文件名称必须为&quot;Makefile&quot;或&quot;makefile&quot;或&quot;GNUmakefile&quot;，如果使用了其他名称，则需要使用make命令-f或–file参数去指定，如&quot;make  -f  MakeLinux&quot;</p><p><strong>大多数make都支持&quot;makefile&quot;和&quot;Makefile&quot;这两者默认文件名，因而最好使用其作为文件名</strong></p><p><strong>makefile文件书写规则</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target:prerequisites</span><br><span class="line"><span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>==<strong>target</strong>是要生成的目标文件(Object File)，也可以是执行文件或一个标签==</p><p>==<strong>prerequisites</strong>就是要生成target所必须的先决文件==</p><p>==<strong>commnd</strong>就是由prerequisites生成target所需要的命令（Shell命令）==</p><p>注意：commnd前要用Tab缩进<br><img src="https://img-blog.csdnimg.cn/20200912100634310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中</p><p>makefile文件中，规则的书写顺序是很重要的，makefile中应该有一个最终目标，其他的目标都是被这个目标所连带出来的，要让make知道你的最终目标。makefile中<strong>第一条规则中的目标将被确立为最终的目标</strong>。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标</p><p>例如下图：(main是最终目标)<br><img src="https://img-blog.csdnimg.cn/20200912104615847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="使用变量">使用变量</h2><p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。就是以一组文字或符号等，来替换一些设置或一串保留的数据</p><p><img src="https://img-blog.csdnimg.cn/20200912104938917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>变量使用方式：</p><ul><li>==定义：用=进行定义==</li><li>==使用：$(变量名)==</li></ul><p>例如：上例中有5个.o文件，可以如下定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file=my_add.o my_sub.o my_mux.o\</span><br><span class="line"> my_div.o main.o</span><br></pre></td></tr></table></figure><p>反斜杠\是换行符的意思，以后用到这5个.o文件，使用$(file)即可</p><p>变量与环境变量的其他介绍请参考我的上一篇博客：<a href="https://blog.csdn.net/huifaguangdemao/article/details/108393856" target="_blank" rel="noopener">Linux：Shell、BASH以及Shell Script简介</a></p><h2 id="文件搜寻">文件搜寻</h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make自动去找</p><p>makefile中的特殊变量<strong>VPATH</strong>就是实现该功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了</p><p><strong>VPATH使用规则</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH=path1:path2</span><br></pre></td></tr></table></figure><p>上面指定了两个路径，路径之间用冒号：分隔</p><p>还可以使用make的关键字vpath设置文件搜索路径，vapth是全小写，不同于VPATH，vapth是关键字，VPATH是变量</p><p><strong>vpath使用规则</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vpath &lt;pattern&gt; &lt;directories&gt;  <span class="comment">#为符合模式&lt;pattern&gt;的文件指定搜索路径&lt;directories&gt;</span></span><br><span class="line"></span><br><span class="line">vpath&lt;pattern&gt;  <span class="comment">#清除符合模式&lt;pattern&gt;的文件的搜索目录</span></span><br><span class="line"></span><br><span class="line">vpath  <span class="comment">#清除所有已被设置好了的文件搜索目录</span></span><br></pre></td></tr></table></figure><p>例：vpath  %.c  path1表示指定.c文件的搜寻目录为path1，%表示匹配零或若干字符</p><h2 id="隐晦规则">隐晦规则</h2><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个.o文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令</p><p>只要make看到一个.o文件，它就会自动的把 .c文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c就会是whatever.o的依赖文件。并且 gcc -c whatever.c 也会被推导出来，这就是make的隐晦规则</p><p>根据隐晦规则与变量，刚开始的例子可以进行简化，如下图：<br><img src="https://img-blog.csdnimg.cn/20200912121303163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="引用其他的makefile">引用其他的makefile</h2><p>在maikefile文件中使用include关键字可以把别的makefile包含进来，被包含的文件会原模原样的放在当前文件的包含位置</p><p>include语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include file1 file2 file3</span><br></pre></td></tr></table></figure><p>file可以是当前操作系统Shell的文件格式，可以包含路径和通配符，也可是使用变量</p><h2 id="伪目标">伪目标</h2><p>makefile书写规则中的target也可以是一个伪目标，例如清除命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure><p>执行完rm *.o命令并不会生成一个clean文件，clean只是一个标签，形象地称其为伪目标</p><p>可以使用.PHONY来显示地指明一个目标是伪目标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：每个makefile中都应该写一个清空目标文件(.o和执行文件)的命令，以便于重编译和保持文件的清洁，不成文的规矩是——“clean从来都是放在文件的最后”，<strong>make会把makefile里出现的第一个target当作缺省target。其他的除非是生成缺省target需要,否则不会执行</strong>，因此该clean在make时并不会执行，要执行该clean命令，手动使用make clean命令来清除掉*.o文件</p><h2 id="make工作执行流程">make工作执行流程</h2><p>GNU的make工作时执行步骤如下：</p><ol><li>读入所有的makefile文件</li><li>读入被include的其他的makefile</li><li>初始化文件中的变量</li><li>推导隐晦规则，并分析所有规则</li><li>为所有的目标文件创建关系依赖链</li><li>根据依赖关系，决定哪些目标要重新生成</li><li>执行生成命令</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：gdb调试</title>
      <link href="/2020/09/06/Linux%EF%BC%9Agdb%E8%B0%83%E8%AF%95/"/>
      <url>/2020/09/06/Linux%EF%BC%9Agdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="gdb">gdb</h2><p>gdb（GNU debugger ）是GNU开源组织发布的一个强大的Linux下的程序调试工具，它可以：</p><ol><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时你的程序中所发生的事</li><li>可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG</li></ol><h2 id="Debug与Release">Debug与Release</h2><p>gdb调试的是可执行文件的Debug版本，这里简单提一下Debug版本与Release版本</p><p>生成的可执行文件可以有Debug版本和Release版本，gcc默认生成的是Release版本</p><p><strong>Debug版本</strong>：可调试的版本，它包含调试信息，并且不作任何优化，便于开发人员调试程序</p><p><strong>Release版本</strong>：发行版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用，它不可单步执行之类的</p><p>gcc默认生成的是Release版本，<strong>在编译时加上-g选项可以生成Debug版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g  源文件.c  -o  指定的文件名</span><br></pre></td></tr></table></figure><p>-g选项与-o选项缺一不可，如果是分步完成编译链接，-g选项必须加到编译阶段</p><p><img src="https://img-blog.csdnimg.cn/20200906110553866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="gdb的使用">gdb的使用</h2><h3 id="1、使用gdb打开文件">1、使用gdb打开文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb  debug版本的可执行文件  <span class="comment">#gdb后面跟的必须是debug版本的可执行文件，否则会报错</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906111045841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2、查看源码">2、查看源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list                <span class="comment">#list可以简写为l，用list默认查看main函数所在的代码</span></span><br><span class="line">list 源代码文件      <span class="comment">#查看指定文件的代码</span></span><br><span class="line">list 源代码文件:行数 <span class="comment">#查看指定文件指定行数周围10行的代码</span></span><br><span class="line">list 文件名:函数名   <span class="comment">#查看指定文件指定函数周围10行的代码</span></span><br><span class="line"><span class="comment">#命令一次只能显示十行，若想查看后面的源码可一直按回车键，直到所有源码显示完</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906112850896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="断点管理">断点管理</h2><h3 id="1、添加断点">1、添加断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b 行号  <span class="comment">#将断点添加到最近一次显示的文件的指定行</span></span><br><span class="line">b filename:行号  <span class="comment">#将断点添加到filename的指定行</span></span><br><span class="line">b functionname  <span class="comment">#将断点添加到指定函数的第一行</span></span><br><span class="line"><span class="comment">#b全称breakpoint</span></span><br></pre></td></tr></table></figure><h3 id="2、查看已有的断点的信息">2、查看已有的断点的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info <span class="built_in">break</span>  <span class="comment">#break可以简写为b</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906113348987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="3、删除断点">3、删除断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d 断点号  <span class="comment">#删除指定的断点</span></span><br></pre></td></tr></table></figure><h3 id="4、添加条件断点">4、添加条件断点</h3><p>这种断点是当满足一定条件时才会触发，比较适合进行异常排查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> line-or-function <span class="keyword">if</span> (condition)</span><br><span class="line">b src/main.cpp:127 <span class="keyword">if</span> cnt==10</span><br></pre></td></tr></table></figure><h3 id="5、将断点设置为无效">5、将断点设置为无效</h3><p>将断点设置为无效并不会删除该断点，当需要时可以继续启用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> [breakpoints] [range...]  <span class="comment">#disable可以简写为dis</span></span><br></pre></td></tr></table></figure><p>breakpoints为断点号。 如果什么都不指定， 表示disable所有的停止点。 简写命令是dis</p><h3 id="6、恢复断点">6、恢复断点</h3><p>与disable对应的就是启用设置为无效的断点，即恢复断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enable</span> [breakpoints] [range...]</span><br><span class="line"><span class="built_in">enable</span> once [breakpoints]  <span class="comment">#仅仅恢复断点一次，当程序停止后， 该断点马上被GDB自动删除</span></span><br></pre></td></tr></table></figure><h2 id="执行流程控制">执行流程控制</h2><h3 id="1、启动调试，开始执行">1、启动调试，开始执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run  <span class="comment">#可以简写为r</span></span><br></pre></td></tr></table></figure><h3 id="2、单步执行">2、单步执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next  <span class="comment">#逐过程，简写为n    调用函数的语句中：n直接执行完函数继续执行</span></span><br><span class="line">step  <span class="comment">#逐语句，简写为s    s进入函数一句一句执行</span></span><br><span class="line">finish  <span class="comment">#直接将当前函数执行完成，退出到调用函数的下一条指令的位置</span></span><br></pre></td></tr></table></figure><h3 id="3、继续执行，直到下一个断点">3、继续执行，直到下一个断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure><h3 id="4、退出循环体">4、退出循环体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">until   <span class="comment">#简写为u</span></span><br></pre></td></tr></table></figure><h3 id="5、退出调试">5、退出调试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h2 id="程序变量">程序变量</h2><h3 id="查看变量的值">查看变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p valname</span><br><span class="line">p &amp;valname</span><br><span class="line">p 数组名  <span class="comment">#显示数组中所有元素的值</span></span><br><span class="line">p 数组指针  <span class="comment">#显示的是指针的值</span></span><br></pre></td></tr></table></figure><p>执行一次p显示一次，如果不执行p，则不会显示</p><h3 id="查看变量的类型">查看变量的类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptype valname</span><br></pre></td></tr></table></figure><h3 id="自动显示变量的值">自动显示变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display valname  <span class="comment">#每执行一次next或step，就显示一次</span></span><br></pre></td></tr></table></figure><h3 id="根据内存地址查看内存的存储值">根据内存地址查看内存的存储值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;addr&gt;  <span class="comment">#&lt;addr&gt;表示一个内存地址</span></span><br></pre></td></tr></table></figure><h3 id="显示函数调用堆栈">显示函数调用堆栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt  <span class="comment">#打印当前的函数调用栈的所有信息</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906133317813.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：Shell、BASH以及Shell-Script简介</title>
      <link href="/2020/09/04/Linux%EF%BC%9AShell%E3%80%81BASH%E4%BB%A5%E5%8F%8AShell-Script%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/09/04/Linux%EF%BC%9AShell%E3%80%81BASH%E4%BB%A5%E5%8F%8AShell-Script%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1>Shell</h1><h2 id="什么是Shell">什么是Shell</h2><p>Shell（壳程序）是系统的用户界面，提供了用户与内核进行相互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。</p><p><img src="https://img-blog.csdnimg.cn/20200904093431812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果</p><p>只要能够操作应用程序的软件都能够称为壳程序，<strong>狭义的壳程序指的是命令行方面的软件</strong>，如本文接下来介绍的BASH；广义的壳程序则包括图形用户界面模式的软件，因为图形用户界面其实也能够操作各种应用程序来调用内核工作</p><h1>BASH</h1><h2 id="什么是BASH">什么是BASH</h2><p>Shell根据发展有多种不同的版本，BASH就是其中一个版本，BASH(Bourne Again Shell)是Linux默认使用的版本</p><h2 id="Shell的变量功能">Shell的变量功能</h2><h3 id="变量">变量</h3><p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。就是以一组文字或符号等，来替换一些设置或一串保留的数据。<br><img src="https://img-blog.csdnimg.cn/20200904101958701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="环境变量">环境变量</h3><p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。为了区别于自定义变量，环境变量通常以大写字符来表示</p><p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。如下图：<br><img src="https://img-blog.csdnimg.cn/20200904102900764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="变量的使用与设置：echo、-、unset">变量的使用与设置：echo、=、unset</h3><p><strong>echo</strong>：可以利用echo命令来使用变量，变量在被使用时，前面要加上美元符号$，例如：查看PATH变量的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904104430430.png#pic_center" alt="在这里插入图片描述"><br><strong>=</strong>：用=可以设置或是修改某个变量的内容，例如要把myname变量内容设置为WangGarrison，则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myname=WangGarrison</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904105347859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>变量在设置时，要符合某些规定，否则会设置失败，规则如下：</p><ol><li>变量与变量内容以一个=来连接</li><li>等号两边不能直接接空格</li><li>变量名称只能是英文字母与数字，且开头不能是数字</li><li>变量内容有空格可使用单引号或双引号将变量引起来</li></ol><p><strong>unset</strong>：unset可以取消变量，例如取消myname的设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> myname</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904110038428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="环境变量的功能">环境变量的功能</h3><p>环境变量可以帮我们实现很多功能，包括根目录（主文件夹）的变换、提示字符的显示、执行文件查找的路径等</p><p>可以用env与export命令来查看当前shell环境默认的环境变量，env是environment(环境)的简写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904122100733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Linux重要的10个环境变量如下表：</p><table><thead><tr><th>环境变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录</td></tr><tr><td>SHELL</td><td>用户使用的Shell解释器名称</td></tr><tr><td>PATH</td><td>执行文件查找的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本解释器</td></tr><tr><td>RANDOM</td><td>随机数的变量</td></tr><tr><td>LANG</td><td>语系数据</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>MAIL</td><td>邮件保存的路径</td></tr></tbody></table><p>使用set命令可以查看所有变量（含环境变量与自定义变量）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><h3 id="自定义变量转成环境变量">自定义变量转成环境变量</h3><p>自定义变量与环境变量的主要差别在于环境变量会被子进程所继续引用，而自定义变量不会，父进程与子进程相关性如下图：<br><img src="https://img-blog.csdnimg.cn/20200904124449575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>子进程仅仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量。所以原本bash的自定义变量在进入了子进程之后不能在子进程使用，直到子进程exit后才能继续使用</p><p>所以要想让父进程的自定义变量可以在子进程使用，则需要把自定义变量转换成环境变量，使用export命令进行转换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> 变量名称</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-export.html" target="_blank" rel="noopener">export命令的具体介绍</a></p><h3 id="变量键盘读取、数组与声明">变量键盘读取、数组与声明</h3><p><strong>read</strong>：用来读取来自键盘输入的变量，可用来与用户交互</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [-pt] variable  <span class="comment">#-p后面可以接提示字符   -t后面可以接等待的秒数</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904155058786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>declare,typeset</strong>：declare或typeset是一样的功能，就是声明变量的类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> [-aixr] variable</span><br><span class="line">-a：将后面名为variable的变量定义成为数组（array）类型</span><br><span class="line">-i：将后面名为variable的变量定义成为整数（<span class="built_in">integer</span>）类型</span><br><span class="line">-x：用法与<span class="built_in">export</span>一样，就是将后面的variable变成环境变量</span><br><span class="line">-r：将变量设置成为<span class="built_in">readonly</span>类型，该变量不可被更改内容，也不能<span class="built_in">unset</span></span><br></pre></td></tr></table></figure><p>在默认情况下，变量类型默认为字符串，如下图中变量a默认是字符串2+3+4<br><img src="https://img-blog.csdnimg.cn/20200904164806662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>数组（array）变量类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var[index]=content  <span class="comment">#数组名为var,下标是index，内容是content，</span></span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://img-blog.csdnimg.cn/20200904170449162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="命令别名与历史命令">命令别名与历史命令</h2><p><strong>命令别名设置</strong>：alias、unalias</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> lm=<span class="string">'ls -al | more'</span>  <span class="comment">#把ls -al |more命令简化为lm</span></span><br></pre></td></tr></table></figure><p>直接敲alias可以查看当前有哪些命令别名。如下图：<br><img src="https://img-blog.csdnimg.cn/20200904182537483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>删除命令别名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unalias</span> lm</span><br></pre></td></tr></table></figure><p><strong>历史命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> [n]  </span><br><span class="line"><span class="built_in">history</span> [-c]  </span><br><span class="line"><span class="built_in">history</span> [-raw]</span><br><span class="line">选项与参数：</span><br><span class="line">n：列出最近的n条命令行表</span><br><span class="line">-c：将目前的shell中的所有<span class="built_in">history</span>内容全部清除</span><br><span class="line">-a：将目前新增的<span class="built_in">history</span>命令新增入histfiles中，若没有histfiles，则默认写入~/.bash_history</span><br><span class="line">-r：将histfiles的内容读到目前这个shell的<span class="built_in">history</span>中</span><br><span class="line">-w：将目前的<span class="built_in">history</span>记录内容写到histfiles中</span><br></pre></td></tr></table></figure><p>当我们以bash登录Linux主机之后，系统会主动地由家目录~/.bash_history读取以前曾经执行过的命令，该目录会记录的数据数目，就与bash的HISTFILESIZE这个环境变量有关</p><h1>Shell Script</h1><h2 id="什么是ShellScript">什么是ShellScript</h2><p>Shell Script即Shell脚本，是针对shell所写的脚本。我们将一些shell规定的语法与命令，再搭配正则表达式、管道命令与数据流重定向等功能，写成一个纯文本文件以达到我们想要的处理目的，再配以“.sh”的扩展名，这便是“Shell script”</p><p>简言之，我们只有通过Shell 这个工具来解释我们的命令等请求，才能成功实现与计算机的交流，同时再搭配Shell script这个可以批量处理命令的“程序”，我们就可以与计算机更好的交流</p><h2 id="参考书籍">参考书籍</h2><p>《鸟哥的Linux私房菜》第四版 第10章认识与学习BASH</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：顺序栈与链栈</title>
      <link href="/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%A0%88%E4%B8%8E%E9%93%BE%E6%A0%88/"/>
      <url>/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%A0%88%E4%B8%8E%E9%93%BE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="栈-Stack">栈(Stack)</h2><p>栈是先进后出(Last In Fast Out)的线性表，限定仅在表尾进行插入和删除操作的线性表，把允许插入删除的一端称为栈顶</p><h2 id="栈示意图">栈示意图</h2><p><img src="https://img-blog.csdnimg.cn/20200902105233991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="进栈出栈变化形式">进栈出栈变化形式</h2><p>最先进栈的元素不一定最后出栈，因为栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就行</p><p>例如整型数字元素1，2，3依次进栈，出栈顺序可为：</p><ul><li>第一种，1，2，3进，再3，2，1出，出栈次序321</li><li>第二种，1进，1出，2进，2出，3进，3出，出栈次序123</li><li>第三种，1进，2进，2出，1出，3进，3出，出栈次序213</li><li>第四种，1进，1出，2进，3进，3出，2出，出栈次序132</li><li>第五种，1进，2进，2出，3进，3出，1出，出栈次序231</li></ul><p>3个元素会有5种出栈次序</p><h2 id="栈的顺序存储结构">栈的顺序存储结构</h2><p>栈是线性表的特例，栈的顺序存储结构其实是线性表顺序存储的简化，称为顺序栈，顺序栈结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;   <span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elemtype *elem;</span><br><span class="line"><span class="keyword">int</span> top;   <span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line"><span class="keyword">int</span> stacksize;  <span class="comment">/* 栈的空间大小 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的初始化">顺序栈的初始化</h2><ol><li>开辟初始空间</li><li>初始化top</li><li>初始化stacksize</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);  <span class="comment">//确保st不为空指针</span></span><br><span class="line"></span><br><span class="line">st-&gt;elem = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*STACK_INIT_SIZE);</span><br><span class="line">st-&gt;stacksize = STACK_INIT_SIZE;</span><br><span class="line">st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的扩容">顺序栈的扩容</h2><ol><li>开辟空间</li><li>更新stacksize</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AppendStack</span><span class="params">(PStack st)</span><span class="comment">//扩容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">st-&gt;elem = (ElemType*)<span class="built_in">realloc</span>(st-&gt;elem, st-&gt;stacksize + <span class="keyword">sizeof</span>(ElemType)*STACKINCREMENT);</span><br><span class="line">st-&gt;stacksize += STACKINCREMENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的进栈-Push">顺序栈的进栈(Push)</h2><p><img src="https://img-blog.csdnimg.cn/20200902111503507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>对于进栈操作push，其实做了三件事情</p><ol><li>判断栈满</li><li>栈顶指针加一</li><li>将新插入元素赋值给栈顶空间</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(PStack st, ElemType val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st-&gt;top == st-&gt;stacksize)  <span class="comment">//判断栈满</span></span><br><span class="line">&#123;</span><br><span class="line">AppendStack(st);</span><br><span class="line">&#125;</span><br><span class="line">st-&gt;top++;  <span class="comment">//栈顶指针加一</span></span><br><span class="line">st-&gt;elem[st-&gt;top] = val;  <span class="comment">//将新插入元素赋值给栈顶空间</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的出栈-Pop">顺序栈的出栈(Pop)</h2><p>若栈不为空，则弹出栈顶元素给e，栈顶指针减一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(PStack st, ElemType *e)</span>  <span class="comment">// 若栈不为空，则弹出栈顶元素给e，栈顶指针减一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st-&gt;top &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*e = st-&gt;elem[st-&gt;top];</span><br><span class="line">st-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的销毁">顺序栈的销毁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destory</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(st-&gt;elem);</span><br><span class="line">st-&gt;elem = <span class="literal">NULL</span>;</span><br><span class="line">st-&gt;stacksize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的清空">顺序栈的清空</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">st-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈判空">顺序栈判空</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> st-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取顺序栈栈顶元素">获取顺序栈栈顶元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetTop</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> st-&gt;elem[st-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的链式存储结构">栈的链式存储结构</h2><p>栈的链式存储结构是用链表方式来实现栈，简称链栈，<br>链栈把栈顶放在单链表的头部，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200902131310411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>链栈结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>  // 栈结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>  // 链栈</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LinkStackPtr top;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><p>链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些</p><h2 id="链栈的进栈-Push">链栈的进栈(Push)</h2><p>假设要进栈的是元素值为e的新节点s，top为栈顶指针，则进栈示意图如下：<br><img src="https://img-blog.csdnimg.cn/20200902131516181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>将当前的栈顶元素赋值给新节点的直接后继</li><li>更新栈顶指针，使其指向新元素</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *LS, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StacNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line"></span><br><span class="line">s-&gt;next = LS-&gt;top; <span class="comment">//将当前的栈顶元素赋值给新节点的直接后继</span></span><br><span class="line">LS-&gt;top = s;  <span class="comment">//更新栈顶指针，使其指向新元素</span></span><br><span class="line"></span><br><span class="line">LS-&gt;count++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的出栈-Pop">链栈的出栈(Pop)</h2><p>假设变量p用来存储要删除的栈顶结点</p><ol><li>将栈顶结点赋值给p，如下图步骤1</li><li>栈顶指针下移一位，如下图步骤2</li><li>释放结点p</li></ol><p><img src="https://img-blog.csdnimg.cn/20200902133553634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若栈不为空，则删除栈顶元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr p;</span><br><span class="line"><span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">*e = S-&gt;top-&gt;next;</span><br><span class="line"></span><br><span class="line">p = S-&gt;top; <span class="comment">//将栈顶结点赋值给p，如上图步骤1</span></span><br><span class="line">S-&gt;top = S-&gt;top-&gt;next;  <span class="comment">//栈顶指针下移一位，如上图步骤2</span></span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//释放结点p</span></span><br><span class="line">S-&gt;count--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈与链栈对比">顺序栈与链栈对比</h2><p>顺序栈与链栈的进栈出栈时间复杂度均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度可以灵活开辟。所以他们的区别如同顺序表与链表的区别。<br><strong>如果栈的使用过程中元素的变化不可预料，有时很小，有时很大，那么最好用链栈；反之，如果它的变化在可控范围内，则可使用顺序栈</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：objdump和readelf的简单使用</title>
      <link href="/2020/09/01/Linux%EF%BC%9Aobjdump%E5%92%8Creadelf%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/01/Linux%EF%BC%9Aobjdump%E5%92%8Creadelf%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="objdump命令">objdump命令</h2><p><strong>objdump</strong>：objdump是用来查看目标文件或者可执行的目标文件的构成的GCC工具，objdump命令用一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息</p><p><strong>objdump命令的使用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objdump -t obj  <span class="comment">#输出目标文件的符号表</span></span><br><span class="line">objdump -h obj  <span class="comment">#输出目标文件的所有段</span></span><br><span class="line">objdump -S obj  <span class="comment">#C语言与汇编语言同时显示</span></span><br><span class="line">objdump -f obj  <span class="comment">#显示目标文件头信息</span></span><br><span class="line">objdump -x obj  <span class="comment">#显示目标文件的所有Header信息</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200901113634467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="readelf命令">readelf命令</h2><p><strong>readelf</strong>：readelf命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息</p><p><strong>ELF文件</strong>：目标文件在不同的系统或平台上具有不同的命名格式，在Unix和X86-64 Linux上称为ELF(Executable and Linkable Format, ELF)，ELF文件参与程序的连接（建立一个程序）和程序的执行（运行一个程序），所以可以从不同的角度来看待elf格式的文件，如下图：<br><img src="https://img-blog.csdnimg.cn/20200901114348278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>readelf命令的使用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">readelf -a [file]  <span class="comment">#--all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I.</span></span><br><span class="line"></span><br><span class="line">readelf -h [file]  <span class="comment">#--file-header 显示elf文件开始的文件头信息. </span></span><br><span class="line"></span><br><span class="line">readelf -l [file]  <span class="comment">#--program-headers --segments 显示程序头（段头）信息(如果有的话)。 </span></span><br><span class="line"></span><br><span class="line">readelf -S [file]  <span class="comment">#--section-headers --sections 显示节头信息(如果有的话) </span></span><br><span class="line"></span><br><span class="line">readelf -g [file]  <span class="comment">#--section-groups 显示节组信息(如果有的话)。 </span></span><br><span class="line"></span><br><span class="line">readelf -t [file]  <span class="comment">#--section-details 显示节的详细信息(-S的)。 </span></span><br><span class="line"></span><br><span class="line">readelf -s [file]  <span class="comment">#--syms --symbols 显示符号表段中的项（如果有的话）。 </span></span><br><span class="line"></span><br><span class="line">readelf -e [file]  <span class="comment">#--headers 显示全部头信息，等价于: -h -l -S -n --notes 显示note段（内核注释）的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -r [file]  <span class="comment">#--relocs 显示可重定位段的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -u [file]  <span class="comment">#--unwind 显示unwind段信息。当前只支持IA64 ELF的unwind段信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -d [file]  <span class="comment">#--dynamic 显示动态段的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -V [file]  <span class="comment">#--version-info 显示版本段的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -A [file]  <span class="comment">#--arch-specific 显示CPU构架信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -D [file]  <span class="comment">#--use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 </span></span><br><span class="line"></span><br><span class="line">readelf -x [file]  <span class="comment">#--hex-dump= 以16进制方式显示指定段内内容。number指定段表中段的索引,或字符串指定文件中的段名。 </span></span><br><span class="line"></span><br><span class="line">readelf -I [file]  <span class="comment">#--histogram 显示符号的时候，显示bucket list长度的柱状图。 </span></span><br><span class="line"></span><br><span class="line">readelf -v [file]  <span class="comment">#--version 显示readelf的版本信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -H [file]  <span class="comment">#--help 显示readelf所支持的命令行选项。 </span></span><br><span class="line"></span><br><span class="line">readelf -W [file]  <span class="comment">#--wide 宽行输出</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200901115504269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：编译链接原理</title>
      <link href="/2020/08/28/Linux%EF%BC%9A%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/28/Linux%EF%BC%9A%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在Linux下，当我们使用GCC来编译Hello World程序时，只须使用最简单的命令（源代码为hello.c）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>事实上，上述过程可以分解为4个步骤，分别是预处理，编译，汇编和链接，如下图：<br><img src="https://img-blog.csdnimg.cn/20200828092410563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="预编译">预编译</h2><p>预编译阶段把.cpp和.h等文件编译成一个 .i文件，第一步预编译的过程相当于如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i  <span class="comment">#-E表示只进行预编译，-o指定生成文件名</span></span><br></pre></td></tr></table></figure><p>预编译阶段主要处理那些源代码文件中以“#”开始的预编译指令。比如“#include”、“#define”等，主要处理规则如下：</p><ul><li>将所有的#define删除，并且展开所有的宏定义</li><li>处理所有的预编译指令，比如 #if、#ifdef、#elif、#else、#endif</li><li>处理#include预编译指令，将包含的文件插入到该预编译指令的位置。（这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件）</li><li>删除所有的注释“//”和“/* */”</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告能够显示行号</li><li>保留所有的#pragram编译器指令，因为编译器要使用它们</li></ul><p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也以经插入到.i文件中，所有可以通过查看.i文件来判断宏定义是否正确或头文件是否包含正确</p><p><strong>预编译阶段处理其实可以总结为以下三点</strong>：</p><ul><li><font color='red'><strong>处理预编译指令</strong></font></li><li><font color='red'><strong>删除注释</strong></font></li><li><font color='red'><strong>宏替换</strong></font></li></ul><p>hello.c文件与预编译生成的hello.i文件内容对比如下<br><img src="https://img-blog.csdnimg.cn/20200828110851580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="编译">编译</h2><p>编译过程就是把预处理完的文件进行一系列<font color='red'><strong>词法分析、语法分析、语义分析及优化后</strong></font>生成的汇编代码文件，这个过程是程序构建的核心部分，命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p>hello.c文件与编译生成的hello.s文件内容对比如下<br><img src="https://img-blog.csdnimg.cn/20200828111556372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="汇编">汇编</h2><p>汇编过程把汇编代码转成机器可执行的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>该过程的处理有：<font color='red'><strong>翻译成二进制，生成各个段、生成符号表</strong></font><br>汇编生成的hello.o文件是二进制文件，用vim查看会是乱码，要使用objdump命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h hello.o</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200828113848202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200828113917340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="链接">链接</h2><p>链接阶段的处理有：<font color='red'><strong>合并各个段，符号解析、符号重定位</strong></font><br><img src="https://img-blog.csdnimg.cn/20200828114023176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200828114036348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200828114050299.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020082811410427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：gcc和g-的使用与区别</title>
      <link href="/2020/08/18/Linux%EF%BC%9Agcc%E5%92%8Cg-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/08/18/Linux%EF%BC%9Agcc%E5%92%8Cg-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc与g-是什么">gcc与g++是什么</h2><p>gcc：是GCC中的GNU C Compiler（C 编译器）注意：GCC与gcc是两个东西</p><p>g++：是GCC中的GNU C++ Compiler（C++编译器）</p><p>GCC: GNU Compiler Collection(GNU 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p><h2 id="gcc与g-区别">gcc与g++区别</h2><p><font color='red'>gcc和g++都可以编译c语言和c++</font></p><p>如果是 .c文件，gcc按照c语言的方式去编译，g++会按照c++的方式编译；如果是 .cpp文件，gcc和g++都会按照c++的方式去编译</p><p>gcc只会默认连接c库，不会连接c++库，而g++都会连接，gcc编译cpp文件时，必须手动连接c++的库（命令：gcc -o main main.cpp  -lstdc++）</p><h2 id="gcc-g-的使用">gcc/g++的使用</h2><p>gcc与g++使用方法相同，这里只以gcc为例</p><p>1、预编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E **.c  <span class="comment">#执行命令后生成**.i文件</span></span><br></pre></td></tr></table></figure><p>预编译阶段：处理预编译指令，删除注释，宏替换</p><p>2、编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S **.i  <span class="comment">#执行命令后默认生成一个**.s文件</span></span><br></pre></td></tr></table></figure><p>编译阶段：语法、词法分析，代码优化，汇总符号</p><p>3、汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c **.s  <span class="comment">#执行命令后生成**.o文件，是可重定位的二进制文件</span></span><br></pre></td></tr></table></figure><p>汇编阶段：翻译成二进制，生成各个段，生成符号表</p><p>4、链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc **.o  <span class="comment">#默认生成一个a.out文件，a.out是可执行文件</span></span><br></pre></td></tr></table></figure><p>链接阶段：合并各个段，符号解析，符号重定位</p><p>上述命令可以加-o指定生成的文件名，o是output的缩写，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc **.o -o 自定义的文件名  <span class="comment">#指定生成的可执行文件名称</span></span><br></pre></td></tr></table></figure><p><strong>上述过程总结如下图</strong><br><img src="https://img-blog.csdnimg.cn/20200818203115154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200818204208939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：进程相关的操作</title>
      <link href="/2020/08/15/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/08/15/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是进程">什么是进程</h2><p>在Linux中触发任何一个事件，系统都会将它定义为一个进程，并且给予这个进程一个ID，称为<strong>PID</strong>（Process ID），同时根据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置，操作系统中对进程的定义如下：</p><p><strong>进程(process)</strong>：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，即进行中的程序或运行中的程序，也就是程序的一次实例化</p><p><strong>程序(program)</strong>：存储在磁盘上的二进制可执行文件，程序员编写源代码文件，由编译器编译链接生成的文件。Windows上可执行程序是.exe文件，Linux上是a.out文件（ELF格式的文件）</p><h2 id="执行一个程序，生成进程">执行一个程序，生成进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路径 可执行文件名      <span class="comment">#./程序有文件名称，表示前台执行，必须等待进程执行结束</span></span><br><span class="line">路径 可执行文件名 &amp;    <span class="comment">#./程序文件名 &amp;，表示后台执行</span></span><br></pre></td></tr></table></figure><h2 id="查看进程">查看进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps       <span class="comment">#查看 Linux 中当前运行的进程</span></span><br><span class="line"><span class="built_in">jobs</span>     <span class="comment">#查看当前终端的后台任务  任务号 任务状态 任务名称</span></span><br><span class="line">ps aux   <span class="comment">#查看系统所有的进程</span></span><br><span class="line">ps -A    <span class="comment">#所有的进程均显示出来，与-e具有同样的效果</span></span><br><span class="line">ps -e    <span class="comment">#所有的进程均显示出来</span></span><br><span class="line">ps -a    <span class="comment">#不显示与终端有关的进程</span></span><br><span class="line">ps -l    <span class="comment">#较长、较详细的将该PID的信息列出</span></span><br><span class="line">ps -f    <span class="comment">#做一个更完整的输出</span></span><br></pre></td></tr></table></figure><p>ps -l会列出与你的操作环境（bash）有关的进程，显示的如下：<br><img src="https://img-blog.csdnimg.cn/20200815114402522.png#pic_center" alt="在这里插入图片描述"><br>上图中ps -l命令下面一行的含义如下：<br><img src="https://img-blog.csdnimg.cn/20200815115123804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="结束一个进程">结束一个进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> pid      <span class="comment">#结束进程标识符为pid的进程</span></span><br><span class="line">pkill cmd     <span class="comment">#结束一组相同cmd的进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 pid   <span class="comment">#强制结束一个进程</span></span><br></pre></td></tr></table></figure><h2 id="挂起一个进程">挂起一个进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -stop pid</span><br></pre></td></tr></table></figure><h2 id="唤醒">唤醒</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> 任务号  <span class="comment">#将任务唤醒到后台执行</span></span><br><span class="line"><span class="built_in">fg</span> 任务号  <span class="comment">#将任务唤醒到前台执行</span></span><br></pre></td></tr></table></figure><h2 id="top：动态查看进程的变化">top：动态查看进程的变化</h2><p>ps命令是选取一个时间点的进程状态，top则可以持续监测进程运行的状态，使用方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top -d 数字   <span class="comment">#数字表示秒数，整个进程界面更新的秒数，默认是5秒</span></span><br><span class="line">top -b       <span class="comment">#以批量的方式执行top</span></span><br><span class="line">top -n       <span class="comment">#与-b搭配，意义是需要执行几次top的输出结果</span></span><br><span class="line">top -p       <span class="comment">#指定某些歌PID来执行查看监测</span></span><br></pre></td></tr></table></figure><p>在top执行过程当中可以使用的按键命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">?  <span class="comment">#显示在top当中可以输入的按键命令</span></span><br><span class="line">P  <span class="comment">#以CPU的使用排序显示</span></span><br><span class="line">M  <span class="comment">#以Memory的使用排序显示</span></span><br><span class="line">N  <span class="comment">#以PID来排序</span></span><br><span class="line">T  <span class="comment">#由该进程使用的CPU使用时间累积（TIME+）排序</span></span><br><span class="line">k  <span class="comment">#给予某个PID一个信号（signal）</span></span><br><span class="line">r  <span class="comment">#给予某个PID重新制定一个nice值</span></span><br><span class="line">q  <span class="comment">#退出top的按键</span></span><br></pre></td></tr></table></figure><p>执行top命令默认显示如下图（数据是动态变化的）：<br><img src="https://img-blog.csdnimg.cn/20200815120843152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>top的功能非常多，可以使用man top命令来查看它的说明文档</p><h2 id="参考书籍">参考书籍</h2><p>《鸟哥的Linux私房菜》第16章 进程管理与SELinux初探</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文件的压缩与解压</title>
      <link href="/2020/08/15/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"/>
      <url>/2020/08/15/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下常见的压缩包">Linux下常见的压缩包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">***.zip      zip程序压缩的文件</span><br><span class="line">***.gz       gzip程序压缩的文件</span><br><span class="line">***.tar      tar程序打包的文件，并没有压缩过</span><br><span class="line">***.tar.gz   tar程序打包的文件，并且经过gzip的压缩</span><br><span class="line">***.tgz      与***.tar.gz可以认为是一样的</span><br><span class="line">***.tar.xz   tar程序打包的文件，并且经过xz的压缩</span><br></pre></td></tr></table></figure><p>虽然Linux文件的属性与文件后缀名没有绝对关系，但是为了帮助人们更好识别，适当的扩展名是可以有的。</p><h2 id="打包文件">打包文件</h2><p>压缩/解压命令通常仅能对一个文件压缩/解压，如此一来，要对一大堆文件进行压缩，打包命令 tar 就尤为重要了，打包即将很多文件结合为一个文件，方便进行压缩<br>打包命令：例如要对当前目录下的main.c 和test.c打包成一个文件名为coding.tar，执行的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar cf coding.tar  main.c test.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200815093358690.png#pic_center" alt="在这里插入图片描述"><br>tar的选项可有如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c  创建，创建包的时候使用</span><br><span class="line">f  目标为文件而不是设备</span><br><span class="line">x  释放文档内容，在解包的时候使用</span><br><span class="line">t  只查看包中的内容而不释放</span><br><span class="line">v  显示详细过程</span><br><span class="line">z  在GNU版本新加的选项，使得tar命令有压缩与解压缩功能</span><br></pre></td></tr></table></figure><p>以上选项可以组合，例如上例中的cf选项</p><h2 id="压缩">压缩</h2><p>文件打包以后，就可以进行压缩了，例如上例中生成的coding.tar包，对其压缩的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  coding.tar</span><br></pre></td></tr></table></figure><p>执行该命令后，会生成coding.tar.gz压缩包<br><img src="https://img-blog.csdnimg.cn/20200815094210919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="解压">解压</h2><p>解压就是对文件压缩的逆过程，<font color='red'>先进行解压缩，再进行解包</font></p><p>第一步：解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d coding.tar.gz   <span class="comment">#执行该命令会生成coding.tar包</span></span><br></pre></td></tr></table></figure><p>第二步：解包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf coding.tar   <span class="comment">#执行该命令会把main.c和test.c解出来</span></span><br></pre></td></tr></table></figure><p>tar在新版本中加的选项 z 可以使得tar命令具有压缩与解压缩的功能，因此压缩与解压可以直接这样执行：<br><img src="https://img-blog.csdnimg.cn/20200815095058585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>注意：</strong><br>coding.tgz文件可以通过gzip命令解压，可以通过tar命令不使用z选项进行解包<br>coding.tar.gz文件同样可以通过tar命令加上z选项（tar zxf）进行解压并解包</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文件操作相关的命令</title>
      <link href="/2020/08/13/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/08/13/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux：文件操作相关的命令">Linux：文件操作相关的命令</h2><h2 id="1-创建文件">1.创建文件</h2><p>创建普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch filename  <span class="comment">#创建一个普通文件，eg: touch main.c</span></span><br></pre></td></tr></table></figure><p>创建目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir direname  <span class="comment">#创建一个目录，eg: mkdir MyCode</span></span><br></pre></td></tr></table></figure><h2 id="2-删除文件">2.删除文件</h2><p>删除普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm filename  <span class="comment">#删除一个普通文件</span></span><br></pre></td></tr></table></figure><p>删除目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir direname  <span class="comment">#删除一个空目录，只能删除空目录</span></span><br><span class="line">rmdir -r direname  <span class="comment">#删除非空目录，-r选项让它递归地去删除</span></span><br></pre></td></tr></table></figure><h2 id="3-拷贝文件">3.拷贝文件</h2><p>拷贝普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 路径1/filename 路径2  <span class="comment">#将路径1下的filename文件拷贝一份到路径2下</span></span><br></pre></td></tr></table></figure><p>拷贝目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r 路径1/direname 路径2  <span class="comment">#将路径1下的direname目录拷贝到路径2下</span></span><br></pre></td></tr></table></figure><h2 id="4-剪切-移动文件">4.剪切/移动文件</h2><p>剪切/移动普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 路径1/filename 路径2  <span class="comment">#将路径1下的filename文件剪切/移动到路径2下</span></span><br></pre></td></tr></table></figure><p>剪切/移动目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 路径1/diername 路径2  <span class="comment">#将路径1下的direname目录剪切/移动到路径2下</span></span><br></pre></td></tr></table></figure><h2 id="5-文件重命名">5.文件重命名</h2><p>普通文件和目录文件重命名命令相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 路径1/filename 路径1/newname  <span class="comment">#其实就是把该文件剪切到相同目录再换个名称</span></span><br></pre></td></tr></table></figure><h2 id="6-修改文件的属性">6.修改文件的属性</h2><p>修改文件的所有者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown newuser filename  <span class="comment">#只有root用户才能执行</span></span><br></pre></td></tr></table></figure><p>修改文件的组用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp newgroup filename  <span class="comment">#只有root用户才能执行</span></span><br></pre></td></tr></table></figure><p>修改文件的权限<br>1）文字设定法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a/u/g/o+/-/=rwx的子集 filename  <span class="comment">#例如：chmod g-x main.c 将组用户对于main.c文件的执行权限删去</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200813105924877.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200813110501110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2）数字设定法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 filename  <span class="comment">#三个数字分别代表一类用户的权限，数字取值范围是0~7</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200813110029110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="7-文件搜索命令">7.文件搜索命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 查找的起始位置 查找的标准</span><br></pre></td></tr></table></figure><p>查找的标准有如下选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-name  <span class="comment">#文件名：支持通配符</span></span><br><span class="line">-<span class="built_in">type</span>  <span class="comment">#文件类型：-f普通文件 -d目录 -p管道 -l链接 -c字符设备 -b块设备 -s套接字 </span></span><br><span class="line">-user  <span class="comment">#username</span></span><br><span class="line">-group  <span class="comment">#groupname</span></span><br><span class="line">-mtime +num/-num  <span class="comment">#+num:num天之前修改  -num：num天以内修改的</span></span><br><span class="line">-amin  +num/-num  <span class="comment">#+num：num分之前修改 -num：num分以内修改的</span></span><br><span class="line">-perm  <span class="comment">#根据文件权限搜索</span></span><br></pre></td></tr></table></figure><h2 id="8-管道命令和过滤命令">8.管道命令和过滤命令</h2><p>管道命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /etc | less  <span class="comment">#管道命令将前一个命令的输出传递给后面的命令</span></span><br></pre></td></tr></table></figure><p>管道命令将前一个命令的输出传递给后面的命令<br><img src="https://img-blog.csdnimg.cn/2020081311405454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>过滤命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 过滤的条件</span><br></pre></td></tr></table></figure><h2 id="9-在终端查看文件内容">9.在终端查看文件内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat filename  <span class="comment">#直接将文件全部内容显示到终端界面上</span></span><br><span class="line">less filename  <span class="comment">#类似于文本查看器</span></span><br><span class="line">more filename  <span class="comment">#和cat命令类似，但不会一次直接将所有的内容显示</span></span><br><span class="line">head -n filename  <span class="comment">#显示文件前n行内容</span></span><br><span class="line">tail -n filename  <span class="comment">#显示文件末尾n行内容</span></span><br><span class="line">tail -f filename  <span class="comment">#循环读取文件尾部的内容，不断刷新的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文本编辑器vi-vim的使用</title>
      <link href="/2020/08/13/Linux%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8vi-vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/13/Linux%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8vi-vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux：vi-vim">Linux：vi/vim</h2><p><strong>vi</strong>：在所有的Linux发行版上面都内置的一个文本编辑器，很多软件默认也使用vi作为它们的编辑工具</p><p><strong>vim</strong>：可以认为是vi的高级版本，它具有程序编辑能力，可以用字体颜色来辨别语法的正确性，vim里面还加入了很多额外的功能，例如多文件编辑、区块复制等</p><h2 id="vi-vim的使用">vi/vim的使用</h2><p>vim有三种基本操作模式，分别是（一般）命令模式，插入（编辑）模式，（命令行）末行模式</p><p><strong>一般命令模式</strong><br>使用vim打开一个文件就进入一般命令模式了，例如用vim 打开main.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br></pre></td></tr></table></figure><p>如果当前目录下没有main.c文件，执行该命令就会新建一个main.c，进入后显示如下图<br><img src="https://img-blog.csdnimg.cn/20200813203946291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在该模式下可以使用上下左右按键来移动光标，也可以使用删除、复制、粘贴等功能。命令如下：<br><img src="https://img-blog.csdnimg.cn/20200813212924537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>插入（编辑）模式</strong><br>在一般命令模式中可以进行删除、复制、粘贴等操作，但是却无法编辑文件的内容，要编辑文件内容，就要在一般命令模式按下i、l、o、O、a、A、r、R中任何一个字母，就会进入编辑模式，在界面左下角会显示INSERT模式<br><img src="https://img-blog.csdnimg.cn/20200813205019547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>输入的字母代表的意思如下：<br><img src="https://img-blog.csdnimg.cn/20200813205751447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时就可以进行编辑了，如果要回到一般命令模式，按下Esc键即可</p><p><strong>（命令行）末行模式</strong><br>末行模式可以对vim做一个配置，对文本进行保存、退出编辑、全文搜索、替换等操作<br>在一般命令模式下输入：/ ？三个中的任何一个就可进入末行模式，输入后显示如下图<br><img src="https://img-blog.csdnimg.cn/20200813210254314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>光标到了最末尾一行，这就是末行模式，可以输入一些命令对文件进行操作，命令如下：<br><img src="https://img-blog.csdnimg.cn/20200813213151242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意：一般命令模式可与编辑模式及末行模式切换，但编辑模式不可直接切换为末行模式，<strong>通常编辑完文本后，先按Esc转到一般命令模式，再按：转到末行模式，最后输入wq保存并退出</strong></p><p>这三种模式之间的关系如下图<br><img src="https://img-blog.csdnimg.cn/20200813214504358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="vim的简单配置">vim的简单配置</h2><p>默认vim编辑器配置比较单调，我们可以自己修改，例如加入行号，自动缩进，设置tab缩进格数，设置鼠标等<br>配置文件有两个位置，第一个是在/etc/vimrc，该文件需root用户修改，修改后的配置对全系统有效，第二个在~/.vimrc，修改该配置只针对此用户有效。选择这两个位置中的一个进行编辑即可。具体配置参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nu  <span class="comment">#设置行号  set nonu  #取消行号</span></span><br><span class="line"><span class="built_in">set</span> hlsearch  <span class="comment">#设置高亮查找，默认就是高亮查找  set nohlsearch  #取消高亮查找</span></span><br><span class="line"><span class="built_in">set</span> autoindent  <span class="comment">#设置自动缩进</span></span><br><span class="line"><span class="built_in">set</span> noautoindent  <span class="comment">#取消自动缩进</span></span><br><span class="line"><span class="built_in">set</span> cindent  <span class="comment">#设置c自动缩进</span></span><br><span class="line"><span class="built_in">set</span> tabstop=4  <span class="comment">#设置tab键为四个空格</span></span><br><span class="line"><span class="built_in">set</span> shiftwidth=4  <span class="comment">#将换行自动缩进设置为四个空格</span></span><br><span class="line"><span class="built_in">set</span> smartindent  <span class="comment">#设置智能对齐</span></span><br><span class="line"><span class="built_in">set</span> showcmd  <span class="comment">#命令行显示输入的命令</span></span><br><span class="line"><span class="built_in">set</span> mouse=a  <span class="comment">#打开鼠标</span></span><br><span class="line">syntax on  <span class="comment">#设置根据程序语法显示不同颜色</span></span><br></pre></td></tr></table></figure><h2 id="vim多窗口功能">vim多窗口功能</h2><p>vim支持多窗口视图，当打开一个文件，在末行模式下输入He表示在下边分屏浏览目录，He！表示在上分屏浏览目录，Ve在左边分屏浏览目录，Ve！在右边分屏浏览目录，示例如下图：<br><img src="https://img-blog.csdnimg.cn/20200813221501311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>输入Ve！后回车，在右侧分屏浏览目录如下图<br><img src="https://img-blog.csdnimg.cn/20200813221523693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="参考书籍">参考书籍</h2><p>《鸟哥的Linux私房菜》第四版 第九章 vim程序编辑器</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文件系统、文件类型与文件权限</title>
      <link href="/2020/08/11/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
      <url>/2020/08/11/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux的文件系统">Linux的文件系统</h2><p>现在Linux大多采用ext4文件系统（Fourth extended filesystem），ext4是索引式的文件系统，以ext4文件系统格式化磁盘时，将磁盘划分成三个区：</p><p><strong>1.superblock（超级区块）</strong>：记录此文件系统的整体信息，包括inode区块的总量、使用量、剩余量，以及文件系统的格式与相关信息等；<br><strong>2.inode</strong>：很多inode节点，给每一个inode都分配一个编码，一个文件会有一个inode节点，在此inode中存储文件的属性信息以及存储文件内容的那些block号<br><strong>3.block（数据区块）</strong>：很多block，给每个block都分配了一个编号，每一个block用于存储文件真实内容，若文件太大时，会占用多个数据区块，一个block一般4K大小</p><h2 id="文件类型与文件权限">文件类型与文件权限</h2><p>在终端输入 ls  -l 查看文件的属性，显示如下图：<br><img src="https://img-blog.csdnimg.cn/20200811210956640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'><strong>第1栏文件类型：</strong></font>Linux下一切皆文件，Linux系统一共有五种文件类型，注意：Linux并不以文件的扩展名区分文件类型，Linux的五种文件类型如下：</p><p>普通文件：用符号 - 表示，例如.c、.cpp、.h、.txt等文件<br>目录文件：d<br>链接文件：l，类似于Windows上的快捷方式<br>管道文件：p，应用在进程间通信<br>设备文件：字符设备文件 c，块设备文件 b，套接字 s</p><p><font color='red'><strong>第2栏文件权限：</strong></font>第二列每三个字母代表一种用户类型的权限，一个文件将访问其的用户划分成三类，分别是所有者、组用户和其他用户，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200811212521303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'><strong>第3栏文件的链接数：</strong></font>普通文件：硬链接文件个数<br>目录文件：目录中一级子目录的个数<br><font color='red'><strong>第4栏文件的所有者</strong></font><br><img src="https://img-blog.csdnimg.cn/20200811212913500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'><strong>第5栏文件所属的组</strong></font><br><font color='red'><strong>第6栏文件的大小，单位字节</strong></font><br><font color='red'><strong>第7栏文件最后修改时间</strong></font><br><font color='red'><strong>第8栏文件名</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：目录组织结构、绝对路径与相对路径、目录相关命令</title>
      <link href="/2020/08/11/Linux%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%81%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E3%80%81%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/08/11/Linux%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%81%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E3%80%81%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux目录组织结构">Linux目录组织结构</h2><p>在Linux下面，所有的文件与目录都是由根目录开始的，根目录是所有文件与目录的源头，然后再一个一个的分支下来，像树枝状，如下图<br><img src="https://img-blog.csdnimg.cn/20200811104213517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="目录树directory tree"><br>Linux的FHS（Filesystem Hierarchy Standard）给出了每个特定的目录下应该存放什么样的文件，FHS目的是希望让用户可以了解到已安装软件通常放置于哪个目录下</p><p><font color='red'><strong>/bin</strong></font>：存放常用命令（即二进制可执行程序），主要有：cat、ls、mkdir、tar、mount、mv、cp、bash等常用命令<br><font color='red'><strong>/etc</strong></font>：存放系统配置文件<br><font color='red'><strong>/home</strong></font>：所有普通用户的家目录，“~”代表目前这个用户的家目录<br><font color='red'><strong>/root</strong></font>：系统管理用户的家目录<br><font color='red'><strong>/usr</strong></font>：存放系统应用程序及文档，（usr全称UNIX Software Resource）<br><font color='red'><strong>/proc</strong></font>：虚拟文件系统目录，以进程为单位存储内存的映射，（proc全称process information pseudo-file system进程信息虚拟文件系统）<br><font color='red'><strong>/dev</strong></font>：存放设备文件<br><font color='red'><strong>/mnt</strong></font>：临时挂载点<br><font color='red'><strong>/lib</strong></font>：存放库文件<br><font color='red'><strong>/boot</strong></font>：系统内核及启动有关的文件<br><font color='red'><strong>/tmp</strong></font>：存放各种临时文件，是所有用户均可访问的地点<br><font color='red'><strong>/var</strong></font>：存放系统运行中常改变的文件，如系统日志</p><h2 id="绝对路径与相对路径">绝对路径与相对路径</h2><p>根据文件名写法的不同，将所谓的路径定义为绝对路径与相对路径<br><font color='red'><strong>绝对路径</strong></font>：由根目录(/)开始写起的文件名或目录名称，例如：/usr/local/src<br><font color='red'><strong>相对路径</strong></font>：相对于当前位置的路径，即从当前位置开始到指定位置的路径，<strong>‘.’代表当前位置，‘..’代表当前位置的上一层目录</strong>，例如：./main.c表示当前位置下的main.c文件</p><p>区分绝对路径和相对路径只需要看首字符，如果首字符是‘/’，则是绝对路径，其他的都是相对路径<br><strong>注意</strong>：在写程序（shell脚本）来管理系统的条件下，务必使用绝对路径，因为绝对路径的写法虽然比较麻烦，但是可以肯定的是这个写法是唯一的且正确的，若使用相对路径，则可能由于执行的工作环境不同导致一些问题的发生</p><h2 id="目录相关命令">目录相关命令</h2><p><font color='red'><strong>.</strong></font>：代表当前目录，例如./main.c当前目录下的main.c文件</p><p><font color='red'><strong>..</strong></font>：代表上一层目录，例如../test.c上一层目录下的test.c文件</p><p><font color='red'><strong>~</strong></font>：代表目前使用者身份的家目录，例如cd ~dmtsai等价于cd /home/dmtsai</p><p><font color='red'><strong>cd</strong></font>：change directory 切换目录，例如cd /usr/share</p><p><font color='red'><strong>pwd</strong></font>：print working directory 显示当前工作位置的绝对路径</p><p><font color='red'><strong>mkdir</strong></font>：make directory 建立一个新目录</p><p><font color='red'><strong>rmdir</strong></font>：remove directory 删除一个空目录，目录需要一层一层的删除才行，而且被删除的目录里面必定不能存在其他的目录或文件，即必须是空目录，如果要删除非空目录，要使用命令<strong>rmdir  -r  dirname</strong>，-r参数让它递归地去删除</p><p><font color='red'><strong>ls</strong></font>：查看文件或目录的信息，<br>用法：ls  路径，显示指定路径下的文件，如果不给路径，默认显示的是当前目录的文件<br>ls命令的选项与参数：<br>-a显示所有的文件，连同隐藏的文件（开头为 <strong>.</strong> 的文件）<br>-i         显示文件对应的inode节点号<br>-l         显示文件的详细信息，包含文件的属性与权限等数据（常用ls  -l也可简化为ll）</p><p><strong>参考书籍</strong><br>《鸟哥的Linux私房菜》第四版 第五章Linux的文件权限与目录配置</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：删除单链表中p节点，时间复杂度O-1</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%ADp%E8%8A%82%E7%82%B9%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%ADp%E8%8A%82%E7%82%B9%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1/</url>
      
        <content type="html"><![CDATA[<h2 id="题目背景">题目背景</h2><p>在plist中删除p节点，时间复杂度要求O(1)</p><h2 id="算法">算法</h2><p>因为时间复杂度为O(1)，所以常规思路遍历链表是不行的。删除节点，其实是把该节点数据域清除，已知了p节点，那么可以知道它的next节点，所以可以把p节点的下一个节点的数据域赋值给p节点数据域，再让p节点的next指向p-&gt;next-&gt;next，就实现了p节点数据域的清除，也就间接删除了p节点。<br>如果p是最后一个节点，则只好遍历链表，复杂度O(n)<br><strong>只有p是最后一个节点时间复杂度才是O(n),平均时间复杂度(O(1)*(n-1) + O(n))/n = O(1)，所以该算法时间复杂度仍为O(1)</strong></p><h2 id="C代码">C代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteP</span><span class="params">(Linklist plist, Linklist p)</span><span class="comment">//在plist中删除p节点，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(plist != <span class="literal">NULL</span>);</span><br><span class="line">assert(p != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span> || p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)<span class="comment">//p不是最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把p-&gt;next-&gt;data的值赋值给p-&gt;data,再让p-&gt;next指向下下个节点</span></span><br><span class="line">p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p-&gt;next);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//p是最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList tmp;</span><br><span class="line"><span class="keyword">for</span> (; tmp-&gt;next-&gt;next != <span class="literal">NULL</span>;)</span><br><span class="line">&#123;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(tmp-&gt;next-&gt;next);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：求单链表倒数第k个节点，只能遍历一次链表</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%B1%82%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%8F%AA%E8%83%BD%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%B1%82%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%8F%AA%E8%83%BD%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求">题目要求</h2><p>求单链表倒数第k个节点，要求只能遍历一次单链表</p><h2 id="算法">算法</h2><p>用两个指针p、q来实现，p、q都指向链表开始位置，先让p指针向后走k个位置，然后两个指针同步走，当p指针为空的时候，q指针就是倒数第k个节点</p><h2 id="C代码">C代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">FindNodeOfK</span><span class="params">(LinkList plist, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span> || plist-&gt;next == <span class="literal">NULL</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList p = plist, q = plist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k&amp;&amp;p != <span class="literal">NULL</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="comment">//k的值大于链表的长度</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：判断两个单链表是否相交</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求">题目要求</h2><p>判断两个单链表是否相交，如果相交则返回第一个相交的节点，如果没有相交则返回NULL</p><h2 id="算法">算法</h2><p>1、先求两个链表长度的差值，让长的链表指针先走这个差值，如下图让plist1先走到p位置<br><img src="https://img-blog.csdnimg.cn/20200727213627962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、完成步骤1后，让两个链表的指针同步向后走，每走一步判断两个节点是否相等，如果相等则直接返回这个节点，如果走到NULL，则两个链表不相交</p><h2 id="C代码">C代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">IsIntersect</span><span class="params">(LinkList plist1, Linklist plist2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (plist1 == <span class="literal">NULL</span> || plist2 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ListEmpty(plist1) || ListEmpty(plist2))<span class="comment">//空链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = GetLength(plist1);</span><br><span class="line"><span class="keyword">int</span> len2 = GetLength(plist2);</span><br><span class="line">LinkList p = plist1, q = plist2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len1 &gt; len2)<span class="comment">// 长链表走差值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 - len1; i++)</span><br><span class="line">&#123;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//两个指针同步走</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：判断链表是否有环，若有环找到环入口</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%8C%E8%8B%A5%E6%9C%89%E7%8E%AF%E6%89%BE%E5%88%B0%E7%8E%AF%E5%85%A5%E5%8F%A3/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%8C%E8%8B%A5%E6%9C%89%E7%8E%AF%E6%89%BE%E5%88%B0%E7%8E%AF%E5%85%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤一：判断链表是否有环，如果有，则返回相遇的节点，如果没有则返回NULL">步骤一：判断链表是否有环，如果有，则返回相遇的节点，如果没有则返回NULL</h2><p><strong>算法</strong>：通过设置快慢指针来判断相遇，快指针一次走两个节点，慢指针一次走一个，若两个指针能相遇则说明有环，返回相遇的节点，若快指针走到NULL都没发生相遇，则说明没环，返回NULL<br><img src="https://img-blog.csdnimg.cn/20200727202646350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Loop</span><span class="params">(LinkList plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span> || plist-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkList p = plist; <span class="comment">// 快指针</span></span><br><span class="line">LinkList q = plist; <span class="comment">// 慢指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) <span class="comment">// p-&gt;next != NULL 保证快指针一次走两个节点能够成功</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤二：找到有环链表的环的入口">步骤二：找到有环链表的环的入口</h2><p><strong>算法一</strong>：通过数学推导来找入口，具体如下：<br>设置快慢指针，快指针一次走两个节点，慢指针一次走一个节点，如下图，plist为链表起点，m为环入口，s点为快慢指针相遇点。<br><img src="https://img-blog.csdnimg.cn/20200727205446662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>当快慢指针相遇在s点，慢指针走过的路程为 x + y ,快指针走过的路程为x + y + (k +y) * n，n是快指针绕环的圈数。</strong><br>因为快指针速度是慢指针二倍，快慢指针移动的时间相同，所以快指针的路程等于慢指针路程的二倍，即2(x + y) = x + y + (k + y)n<br>化解：x + y = (k + y)n<br>x + y =  (k + y)(n - 1) + k+y<br><strong>x = (k + y)(n-1) + k</strong><br><strong>该式里，右边(k + y)(n -1)是绕环的路程，即从plist起点开始到环入口的路程等于从相遇点s开始到m的路程加上绕环的路程<br>因而可以让两个速度相同的指针，一个从plist开始走，一个从s点开始走，二者第一次相遇的点就是环入口m点</strong></p><p>C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">IsLoop</span><span class="params">(LinkList plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList s = Loop(plist);<span class="comment">//通过上一步骤的Loop函数找到快慢指针相遇点</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList p = plist;</span><br><span class="line">LinkList q = s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">//p就是入环的第一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法二</strong>：遍历节点时把节点存储在一个表里，每次移动指针都在表里查看有无当前节点，若有出现重复则返回该节点，若无则继续遍历。该算法思路较为简单，但效率不高，O(n^2)<br>C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLESIZE 10  </span></span><br><span class="line"><span class="function">Linklist <span class="title">FindCircleStart</span><span class="params">(Linklist plist)</span><span class="comment">//如果有环，找到入幻的第一个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(plist != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">Linklist p = plist;</span><br><span class="line"><span class="keyword">if</span> (IsCircle(p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历p，把节点存起来，第一个出现重复的节点就是环的入口</span></span><br><span class="line">Linklist table[TABLESIZE];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">table[i] = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i &gt; TABLESIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">realloc</span>(table, <span class="keyword">sizeof</span>(table) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)<span class="comment">//看已存的表里有没有重复的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j +<span class="number">1</span>; k &lt; i; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (table[k] == table[j])</span><br><span class="line"><span class="keyword">return</span> table[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串算法：等宽替换-以少换多-以多换少</title>
      <link href="/2020/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AD%89%E5%AE%BD%E6%9B%BF%E6%8D%A2-%E4%BB%A5%E5%B0%91%E6%8D%A2%E5%A4%9A-%E4%BB%A5%E5%A4%9A%E6%8D%A2%E5%B0%91/"/>
      <url>/2020/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AD%89%E5%AE%BD%E6%9B%BF%E6%8D%A2-%E4%BB%A5%E5%B0%91%E6%8D%A2%E5%A4%9A-%E4%BB%A5%E5%A4%9A%E6%8D%A2%E5%B0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目一：写一个函数将字符串中的字符-移到字符串的前部分，前面的非-字符后移，但不能改变非-字符的先后顺序，例如auto-toc-处理后为-autoc">题目一：写一个函数将字符串中的字符*移到字符串的前部分，前面的非*字符后移，但不能改变非*字符的先后顺序，例如auto**toc**处理后为****autoc</h2><p><strong>算法一：</strong><br><img src="https://img-blog.csdnimg.cn/20200623153956201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="算法一"><br>C代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1:从后往前复制非*的字符,然后前面的补*</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Move1</span><span class="params">(<span class="keyword">char</span> *str)</span><span class="comment">//O(n),O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *arr =  (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">assert(arr != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(str);<span class="comment">//str下标</span></span><br><span class="line"><span class="keyword">int</span> j = i;<span class="comment">//arr下标</span></span><br><span class="line"><span class="keyword">int</span> rtval;<span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从后往前复制非*的字符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] != <span class="string">'*'</span>)<span class="comment">//非*,需要复制到arr中</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j--] = str[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rtval = <span class="built_in">strlen</span>(str)-j<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//前面补*</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[j--] = <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(str,arr);<span class="comment">//将数据复制到str中</span></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rtval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法一时间复杂度O(n),空间复杂度0(n)</p><p><strong>算法二：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200623154404291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法2,利用两个下标i,j分别到字符串的末尾,通过i从后往前遍历,如果i的数据为非*则将数据复制到j处,</span></span><br><span class="line"><span class="comment">//j往前,如果没有复制则j不动,最后将前面的部分补充为*</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Move</span><span class="params">(<span class="keyword">char</span> *str)</span><span class="comment">//O(n),O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(str);<span class="comment">//遍历的下标</span></span><br><span class="line"><span class="keyword">int</span> j = i;<span class="comment">//数据移动后的下标</span></span><br><span class="line"><span class="keyword">int</span> rtval;<span class="comment">//返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)<span class="comment">//利用i从后往前遍历字符串</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] != <span class="string">'*'</span>)</span><br><span class="line">&#123;</span><br><span class="line">str[j--] = str[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rtval = <span class="built_in">strlen</span>(str)-j<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">str[j--] = <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rtval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法二未使用辅助空间，时间复杂度O(n),空间复杂度度O(1)</p><h2 id="题目二：将字符串中的空格替换为-20-例如-a-b-c-“a-20b-20-20c”">题目二：将字符串中的空格替换为%20,例如&quot;a b  c&quot;-&gt;“a%20b%20%20c”</h2><p><strong>算法一：</strong><br><img src="https://img-blog.csdnimg.cn/20200623154824220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>算法二：</strong><br><img src="https://img-blog.csdnimg.cn/202006231548409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>算法二C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span> *str1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//先统计空格数量，利用i定位到字符串末尾，j=i+空格数*2；</span></span><br><span class="line"><span class="comment">//再从后往前替换，遇到非空格的直接放，遇到空格替换为0 2 %, j往前移动3个</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> blank = <span class="number">0</span>;<span class="comment">//空格数量</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; str1[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == <span class="string">' '</span>)</span><br><span class="line">blank++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = i + blank * <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//i是旧串末尾，j是新串的末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] != <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">str1[j] = str1[i];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//是空格</span></span><br><span class="line">&#123;</span><br><span class="line">str1[j--] = <span class="string">'0'</span>;</span><br><span class="line">str1[j--] = <span class="string">'2'</span>;</span><br><span class="line">str1[j--] = <span class="string">'%'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三：删除字符串中多余的空格-多个空格只保留一个-“a-b-c-d”-“a-b-c-d”">题目三：删除字符串中多余的空格,多个空格只保留一个.“a b c    d”-&gt;“a b c d”</h2><p><img src="https://img-blog.csdnimg.cn/20200623155226357.png" alt="在这里插入图片描述"><br>算法：i不断后移判断，若当前是空格，接下来也是空格，则不赋值，i后移，j不动<br>若当前是空格接下来不是空格或者当前是非空格则把i赋值给j，i后移，j后移</p><p>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//i不断后移判断，若当前是空格，接下来也是空格，则不赋值，i后移，j不动</span></span><br><span class="line"><span class="comment">//若当前是空格接下来不是空格或者当前是非空格则把i赋值给j，i后移，j后移</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; str2[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str2[i] == <span class="string">' '</span>&amp;&amp;str2[i + <span class="number">1</span>] == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">str2[j] = str2[i];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str2[j] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言位运算及其应用</title>
      <link href="/2020/06/23/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2020/06/23/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>位运算符</strong></p><p>位运算符允许对一个字节或更大的数据单位中独立的位做处理：可以清除、设定，或者倒置任何位或多个位。也可以将一个整数的位模式（bit pattern）向右或向左移动，针对的是二进制。<br><img src="https://img-blog.csdnimg.cn/20200623143142494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200623143214315.png" alt="在这里插入图片描述"><br>注意：&lt;&lt;左移运算符最右边补0，&gt;&gt;右移运算符最左边补符号位，（记忆这两个符号方法：箭头朝哪一边就是哪一边移）</p><p><strong>位运算应用</strong><br>下面数据x设为1字节，即8位</p><p>去掉最后一位 ： (10110<strong>1</strong>-&gt;10110)   算法  x &gt;&gt; 1</p><p>在最后加一个0：(101101-&gt;101101<strong>0</strong>)  算法 x &lt;&lt; 1</p><p>在最后加一个1：(101101-&gt;101101<strong>1</strong>) 算法 (x &lt;&lt; 1)|1</p><p>把最后一位变成1： (10110<strong>0</strong>-&gt;10110<strong>1</strong>) 算法 x | 1</p><p>把最后一位变成0：(10110<strong>1</strong>-&gt;10110<strong>0</strong>) 算法 (x | 1)-1</p><p>最后一位取反：(10110<strong>1</strong>-&gt;10110<strong>0</strong>) 算法 x ^ 1</p><p>把右数第k位变成1：(101<strong>0</strong>01-&gt;101<strong>1</strong>01,k=3) 算法 x | (1 &lt;&lt; (k-1))</p><p>把右数第k位变成0： (101<strong>1</strong>01-&gt;101<strong>0</strong>01,k=3) 算法 x &amp; ~(1 &lt;&lt; (k-1))</p><p>右数第k位取反： (101<strong>0</strong>01-&gt;101<strong>1</strong>01,k=3) 算法 x ^ (1 &lt;&lt; (k-1))</p><p>取末三位： (1101<strong>101</strong>-&gt;101) 算法 x &amp; 7<br>注：7的二进制为0000  0111，x&amp;7即可取末三位</p><p>取末k位： (110<strong>1101</strong>-&gt;1101,k=4) 算法 x &amp; ((1 &lt;&lt; k)-1)</p><p>取右数第k位： (110<strong>1</strong>101-&gt;1,k=4) 算法 (x &gt;&gt; (k-1)) &amp; 1</p><p><strong>位运算方法总结</strong></p><p>1.确定符号，变1：|1；变0：&amp;0；取反：^1<br>2.确定数字<br>3.构造数字<br>例如：<img src="https://img-blog.csdnimg.cn/202006231501513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>例题：统计一个字节数据二进制1的个数</strong><br><img src="https://img-blog.csdnimg.cn/20200623151149156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言动态内存分配malloc、calloc、realloc</title>
      <link href="/2020/05/23/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dmalloc%E3%80%81calloc%E3%80%81realloc/"/>
      <url>/2020/05/23/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dmalloc%E3%80%81calloc%E3%80%81realloc/</url>
      
        <content type="html"><![CDATA[<h2 id="动态内存"><strong>动态内存</strong></h2><p>根据需要动态创建需要的内存。例如根据变量创建数组，其内存区域在堆。这里简单提一下堆与栈</p><p><strong>栈</strong>：局部变量所在的内存区域，在Windows默认其大小为1M，系统自行管理其内存（即你不用管回收问题）</p><p><strong>堆</strong>：动态内存所在区域，默认大小为2G左右（不同平台有差别），程序管理内存，特别要注意内存释放</p><p>从以上栈与堆的大小可以知道，堆比栈大的多，所以动态内存还有一个使用场景，即需要创建大容量的数组时</p><h2 id="malloc、calloc、realloc"><strong>malloc、calloc、realloc</strong></h2><p><strong>malloc</strong>(字节数): 创建成功，函数返回一个指向分配起始地址的指针，失败返回NULL，内存数据为没有初始化的随机值</p><p><strong>calloc</strong>(单元个数，每个单元的字节数): 创建成功，函数返回一个指向分配起始地址的指针，失败返回NULL，内存数据初始化为0</p><p><strong>realloc</strong>(旧内存地址，新的内存字节大小): 用于修改动态内存的大小</p><p><strong>注意</strong>：这三个是C语言表中库中的函数，使用时要引用头文件stdlib.h，返回的地址都是void*类型，要强制类型转换成你所要用的类型</p><p><strong>malloc与calloc主要区别</strong>： 1.malloc内存数据未初始化，为随机值，calloc内存数据初始化为0,<br>2.malloc只有一个参数，calloc有两个参数，注意看他们的函数原型声明：void* malloc(unsigned size);    void* calloc(size_t nelem, size_t elsize)</p><h2 id="free"><strong>free</strong></h2><p><strong>free</strong>(地址): 释放动态创建的内存，不释放会发生内存泄漏<br>free在使用的时候在以下情况会崩溃：1.越界（动态分配的内存太小）2.动态内存指针发生移动  3.重复释放</p><p>解释一下第二条动态内存指针发生移动导致free失败的原因<br>free函数只有一个参数，即分配的内存的首地址，它只用这一个信息就知道要释放多大的内存，这是因为动态分配的内存的那个首地址记录了它后边的分配的空间的大小的信息，因此只传给free函数内存首地址即可，若这个地址（指针）发生了移动，free就会崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不使用第三个变量交换两个整数a-b的值</title>
      <link href="/2020/05/21/%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0a-b%E7%9A%84%E5%80%BC/"/>
      <url>/2020/05/21/%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0a-b%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>通常交换两个整数a,b的值，要使用第三方变量temp，但是在一些笔试或面试中，要求<strong>不使用第三个变量来实现交换</strong>，下面总结三种方法。</p><h2 id="方法一：加法">方法一：加法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a + b;<span class="comment">//a存储两数之和7</span></span><br><span class="line">b = a - b;<span class="comment">//两数之和减去一个就是另一个，相当于b = 7-2，此时b已经变成最初a的值了</span></span><br><span class="line">a = a - b;<span class="comment">//相当于a=7-2，a的值成为最初b的值</span></span><br></pre></td></tr></table></figure><h2 id="方法二：减法">方法二：减法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a - b;<span class="comment">//a存储两数之差  a=2-5=-3</span></span><br><span class="line">b = b + a;<span class="comment">//b加上a与b的差值即为最初a的值</span></span><br><span class="line">a = b - a; <span class="comment">//b此时为最初a的值，减去差值即为最初b的值</span></span><br></pre></td></tr></table></figure><h2 id="方法三：异或">方法三：异或</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a ^ b;   <span class="comment">//a存储ab"异或结果"</span></span><br><span class="line">b = a ^ b;  <span class="comment">//"异或结果"与b异或得到的是最初a的值</span></span><br><span class="line">a = a ^ b;  <span class="comment">// "异或结果"与此时变成a的b异或得到的是最初b的值</span></span><br></pre></td></tr></table></figure><h2 id="注意！">注意！</h2><p>上述三种方法都没有常规方法( tmp = a ; a = b ; b = tmp; )好，并且以上三种方法不能实现自己和自己的交换，自己和自己交换结果都会是0<br>例如异或方法，当a和b都是a时，就变为(a = a ^ a ; a = a ^ a ; a = a ^ a)，结果是0</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swap函数实现交换两个整数的值，易错总结</title>
      <link href="/2020/05/17/Swap%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/17/Swap%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正确做法">一、正确做法</h2><p><strong>首先正确的交换方式是如下代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用指针直接访问存储两个整数的内存空间，实现交换，下面归纳一下易错的地方</p><h2 id="二、只交换了形参">二、只交换了形参</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_err</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，只是交换了Swap函数里a，b的值（即只交换了形参的值），而主函数里的a，b是没有发生改变的，交换失败</p><h2 id="三、只是交换了形参的指向">三、只是交换了形参的指向</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_err2</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况看似形参传了引用，但函数体交换的是形参的指向，如下图所示<img src="https://img-blog.csdnimg.cn/20200517220942457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt=""><br>p1原本指向a，函数把p1指向了b，p2指向了a，交换了这两个形参的指向，但a，b并没有发生交换。<br>可以形象的理解为交换了两个房间的钥匙，房间里的内容并没有交换。</p><h2 id="四、小心野指针">四、小心野指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_err3</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp;<span class="comment">//野指针,悬挂指针,tmp是个局部变量,默认值为随机值</span></span><br><span class="line">*tmp = *p1;<span class="comment">//*tmp崩溃,野指针不能访问</span></span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = *tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况程序会崩溃<br><img src="https://img-blog.csdnimg.cn/20200517221636187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt=""><br>这里tmp指针没有被初始化，即成为所谓的野指针<br>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的），此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。<br>野指针不同于空指针，空指针是指一个指针的值为null，而野指针的值并不为null，野指针会指向一段实际的内存，只是它指向哪里我们并不知情，所以程序在这里崩溃了。<strong>编程时要小心避免野指针。</strong></p><h2 id="五、总结">五、总结</h2><p>交换成功的必要条件:<strong>1.传指针;2.解引用</strong><br>一个函数的改变要想影响另一个函数,必须满足两个条件:<strong>1.传指针;2.解引用</strong></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github与hexo搭建的个人博客网站更新后显示404</title>
      <link href="/2020/05/17/Github%E4%B8%8Ehexo%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E5%90%8E%E6%98%BE%E7%A4%BA404/"/>
      <url>/2020/05/17/Github%E4%B8%8Ehexo%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E5%90%8E%E6%98%BE%E7%A4%BA404/</url>
      
        <content type="html"><![CDATA[<p>更新博客后<br>hexo s 本地显示正常，但是hexo d提交线上后，用域名打开显示404</p><p><strong>解决办法</strong></p><p>hexo d后，登录Github找到自己博客的仓库，<br>点击settings<br><img src="https://img-blog.csdnimg.cn/20200516195546338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="Github settings"><br>拉到底部将自己的域名填入，（虽然之前填过，但更新后有时要再填一次）<br><img src="https://img-blog.csdnimg.cn/20200516195808997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="custom domain"><br>然后再点击rename，（虽然这没改动，但仍要点击一次）<br><img src="https://img-blog.csdnimg.cn/20200516195939782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="click rename"><br>操作完之后就可以用域名打开网站了</p><p><img src="https://img-blog.csdnimg.cn/20200516200508342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OneNote-for-win10本地存储文件的备份与查看</title>
      <link href="/2020/05/17/OneNote-for-win10%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%9F%A5%E7%9C%8B/"/>
      <url>/2020/05/17/OneNote-for-win10%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%9F%A5%E7%9C%8B/</url>
      
        <content type="html"><![CDATA[<p>今天win10预装的OneNote突然卡在了打开笔记本页面，一番重启之后无解，准备重装又担心之前的数据没有上传到云，于是手动备份。</p><p>OneNote本地存储的文件在C:\Users\wi\AppData\Local\Packages\Microsoft.Office.OneNote_8wekyb3d8bbwe\LocalState\AppData\Local\OneNote\16.0\AccessibilityCheckerIndex<br>该目录下成对出现的文件即为自己的笔记本，这些数据库文件为sqlite格式的db文件。使用SQLLiteSpy可以查看这些文件。<br>下载SQLLite数据库管理工具SQLLiteSpy<a href="http://www.winportal.com/sqlitespy" target="_blank" rel="noopener">下载地址</a>。<br>下载成功后解压缩，找到exe文件直接运行，在可视化窗口使用快捷键ctrl+F11打开数据库文件。使用该工具即可查看自己OneNote笔记本的数据结构。<br><img src="https://img-blog.csdnimg.cn/2020042609235772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="SQLLite界面"><br>重装OneNote之前备份数据库文件，这样就不用担心数据的丢失了。</p>]]></content>
      
      
      <categories>
          
          <category> OneNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查找两数之和</title>
      <link href="/2020/05/16/%E6%9F%A5%E6%89%BE%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/05/16/%E6%9F%A5%E6%89%BE%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="查找两数之和">查找两数之和</h2><p><strong><strong>Leetcode刷题笔记</strong></strong><br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p><p>我的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> *p1 = nums;</span><br><span class="line">    <span class="keyword">int</span> *a =(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);<span class="comment">//动态分配内存，给a分配2个int的大小//malloc返回分配的首地址</span></span><br><span class="line">                                          </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*(p1 + i) + *(p1 + j)) == target) </span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = i; a[<span class="number">1</span>] = j;</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   *returnSize=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力查找，时间复杂度 O(n^2)，本题逻辑较为简单，但要注意题注“The returned array must be malloced”.<br>算法可优化，具体参考leetcode该题讨论区。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求整数位数，以及顺序与逆序输出各位数字</title>
      <link href="/2020/05/16/%E6%B1%82%E6%95%B4%E6%95%B0%E4%BD%8D%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E4%B8%8E%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
      <url>/2020/05/16/%E6%B1%82%E6%95%B4%E6%95%B0%E4%BD%8D%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E4%B8%8E%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目背景：给一个正整数，-1-求它的位数，2-逆序输出每一位数字，3顺序输出每一位数字">题目背景：给一个正整数， 1.求它的位数，2.逆序输出每一位数字，3顺序输出每一位数字</h2><p><strong>1求位数，</strong><br>算法: 每次丢弃个位数字,计数器++,直到n为0<br>与我们用眼睛去数类似，即不断给该整数除以十，计数，此处要考虑当给的整数位0时的特殊情况，C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp++;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.逆序输出</strong><br>算法：求出低位，输出低位，再丢弃低位，重复执行直到n为0<br>这里关键是求低位的算法，用除十取余来得到低位，C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseOutput</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//提前结束该函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">n = -n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,n%<span class="number">10</span>);</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.顺序输出</strong><br>算法:得到高位,输出高位,丢弃高位,直到n为0，<br>这里关键是得到高位的算法，C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderOutput</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = Count(n); <span class="comment">//得到n是几位数字</span></span><br><span class="line"><span class="keyword">int</span> power = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10.0</span>, tmp - <span class="number">1</span>);<span class="comment">//获得高位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, n / power);<span class="comment">//输出最高位</span></span><br><span class="line">n %= power;<span class="comment">//丢弃最高位</span></span><br><span class="line">power /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
