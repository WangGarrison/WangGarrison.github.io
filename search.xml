<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux：I-O复用——poll、epoll</title>
      <link href="/2021/02/03/Linux%EF%BC%9AI-O%E5%A4%8D%E7%94%A8%E2%80%94%E2%80%94poll%E3%80%81epoll/"/>
      <url>/2021/02/03/Linux%EF%BC%9AI-O%E5%A4%8D%E7%94%A8%E2%80%94%E2%80%94poll%E3%80%81epoll/</url>
      
        <content type="html"><![CDATA[<hr><h1>poll</h1><hr><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。poll的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>fds：struct pollfd类型的数组，用来传递用户关注的文件描述符以及事件类型，pollfd结构体如下：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;  <span class="comment">// 文件描述符</span></span><br><span class="line">short events;  <span class="comment">// 关注的事件类型</span></span><br><span class="line">short revents; <span class="comment">// 由内核填充，poll返回时用来标注就绪的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>nfds：数组的大小</li><li>timeout：定时时间，单位毫秒，-1表示一直阻塞直到有事件就绪，timeout 为 0 时， poll 调用将立即返回。</li><li>返回值：成功返回就绪文件描述符的总数，超时返回 0，失败返回-1</li></ul><h2 id="poll支持的事件类型">poll支持的事件类型</h2><p>(可以在events中填充的事件类型，如果关注多种事件类型，可以使用按位或将这些事件合到一起)</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">POLLIN</td><td style="text-align:left">数据可读（包括普通数据和优先数据）</td></tr><tr><td style="text-align:left">POOLLOUT</td><td style="text-align:left">数据可写（包括普通数据和优先数据）</td></tr><tr><td style="text-align:left">POLLRDHUP</td><td style="text-align:left">TCP连接被对方关闭，对方关闭了写操作，它由 GNU 引入，使用时，需要在代码开始处定义_GNU_SOURCE</td></tr><tr><td style="text-align:left">POLLHUP</td><td style="text-align:left">挂起，管道写端关闭，读端会收到该事件</td></tr><tr><td style="text-align:left">POLLERR</td><td style="text-align:left">错误</td></tr><tr><td style="text-align:left">POLLNVAL</td><td style="text-align:left">文件描述符没有打开</td></tr></tbody></table><h2 id="使用poll实现TCP服务器">使用poll实现TCP服务器</h2><p>服务器端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ser.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE  <span class="comment">//POLLRDHUP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ip地址与端口号创建套接字，返回创建的套接字的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">CreateSocket</span><span class="params">(<span class="keyword">char</span> *ip, short port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = htons(port);</span><br><span class="line">    ser_addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = bind(listenfd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化文件描述符数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitFds</span><span class="params">(struct pollfd *fds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; NUM; ++i)</span><br><span class="line">&#123;</span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">fds[i].events = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//revents由内核填充，所以这里不用设置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向fds数组中插入一个fd, 关注的事件类型为events</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertFds</span><span class="params">(struct pollfd *fds, <span class="keyword">int</span> fd, short events)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;NUM; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fds[i].fd = fd;</span><br><span class="line">fds[i].events = events;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DealReadyEvent</span><span class="params">(struct pollfd *fds, <span class="keyword">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;NUM; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(fds[i].fd == listenfd)  <span class="comment">//是监听套接字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fds[i].revents &amp; POLLIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line"><span class="keyword">int</span> c =  accept(listenfd, (struct sockaddr*)&amp;cli_addr, &amp;len);</span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">-1</span>)  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"one client link success\n"</span>);</span><br><span class="line">InsertFds(fds, c, POLLIN | POLLRDHUP);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//是链接套接字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fds[i].revents &amp; POLLRDHUP)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d client over\n"</span>, fds[i].fd);</span><br><span class="line"><span class="built_in">close</span>(fds[i].fd);</span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">fds[i].events = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = recv(fds[i].fd, buff, <span class="number">127</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d client error\n"</span>, fds[i].fd);</span><br><span class="line"><span class="built_in">close</span>(fds[i].fd);</span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">fds[i].events = <span class="number">0</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>, fds[i].fd, buff);</span><br><span class="line">send(fds[i].fd, <span class="string">"OK"</span>,<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd  = CreateSocket(<span class="string">"192.168.133.132"</span>, <span class="number">6000</span>);</span><br><span class="line">assert(listenfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">NUM</span>];</span></span><br><span class="line">InitFds(fds);</span><br><span class="line"></span><br><span class="line">InsertFds(fds, listenfd, POLLIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n = poll(fds, NUM, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"poll error\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">DealReadyEvent(fds, listenfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cli.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; //字节序的转换</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  //IP地址转换</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//创建套接字</span></span><br><span class="line">assert(<span class="number">-1</span> != sockfd);</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">ser_addr.sin_family = AF_INET;</span><br><span class="line">ser_addr.sin_port = htons(<span class="number">6000</span>);</span><br><span class="line">ser_addr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.133.132"</span>); </span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));<span class="comment">//指定连接的服务器端的 IP 地址和端口</span></span><br><span class="line">assert(<span class="number">-1</span> != res);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input: "</span>);</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buff, <span class="number">127</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff, <span class="string">"end"</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">        </span><br><span class="line">        send(sockfd, buff, <span class="built_in">strlen</span>(buff) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">recv(sockfd, buff, <span class="number">127</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buff);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20210115123737942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="poll总结">poll总结</h2><p>1、poll所能关注的文件描述符的个数理论上是没有限制的。文件描述符的取值范围也是没有限制的</p><p>2、poll支持的事件类型比select更多</p><p>3、poll返回时，内核修改的是数组元素中revents成员，与用户填充的关注的事件类型不冲突，所以每次调用poll之前，不需要重新设置这个数组</p><p>==前三点是与select不一样的，后面的几点是与select相同的==</p><p>4、poll返回时，也仅仅是返回就绪文件描述符的个数，并没有指定是哪几个文件描述符就绪。所以用户程序检测就绪文件的时间复杂度为O(n)</p><p>5、poll每次调用时，也是需要将用户空间的数组传递拷贝给内核，poll返回时又将内核的拷贝到用户空间</p><p>6、poll内核也是采用轮询的方式</p><p>7、poll也只能工作在LT模式</p><h1>epoll</h1><hr><h2 id="epoll的原型">epoll的原型</h2><p>epoll 是 Linux 特有的 I/O 复用函数。它在实现和使用上与 select、 poll 有很大差异。</p><p>首先， epoll 使用一组函数来完成任务，而不是单个函数。其次， epoll 把用户关心的文件描述符上的事件放在内核里的一个事件表中。从而无需像 select 和 poll 那样每次调用都要重复传入文件描述符或事件集。但 epoll 需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。 该文件描述符由epoll_create创建</p><p>epoll 相关的函数如下：</p><ul><li>epoll_create()：用于创建内核事件表</li><li>epoll_ctl()：用于操作内核事件表</li><li>epoll_wait()：用于在一段超时时间内等待一组文件描述符上的事件</li></ul><p><strong>创建内核事件表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>成功返回内核事件表的文件描述符，失败返回-1</li><li>size：size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大</li><li>内核事件表：在内核中创建的一个记录用户关注的文件描述符和事件的集合，其数据结构为红黑树</li></ul><p><strong>操作内核事件表</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>epfd: epoll_create方法返回的文件描述符，指定要操作的内核事件表的文件描述符</li><li>op: 指定操作类型，添加 EPOLL_CTL_ADD, 修改 EPOLL_CTL_MOD, 删除 EPOLL_CTL_DEL</li><li>fd: 指定要操作的文件描述符</li><li>event：指定事件，它是 epoll_event 结构指针类型， epoll_event 的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> events;  <span class="comment">//事件的集合</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data;<span class="comment">//用户数据，data.fd 文件描述符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>其中， events 成员描述事件类型， epoll 支持的事件类型与 poll 基本相同，表示 epoll 事件的宏是在 poll 对应的宏前加上‘E’ ，比如 epoll 的数据可读事件是 EPOLLIN。但是 epoll 有两个额外的事件类型—EPOLLET 和 EPOLLONESHOT。 data 成员用于存储用户数据，是一个联合体，其定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fd;  <span class="comment">//文件描述符</span></span><br><span class="line"><span class="keyword">void</span> *ptr;<span class="comment">//用户数据</span></span><br><span class="line"><span class="keyword">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></li><li>成功返回0，失败返回-1</li></ul><p><strong>epoll_wait：真正执行I/O复用的方法</strong></p><p>epoll_wait函数在一段超时时间内等待一组文件描述符上的事件，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>expfd：这次处理的内核事件表的文件描述符</li><li>events：用户数组，这个用户数组所有的都是内核填充的，用来返回所有就绪的文件描述符以及事件，这个数组仅仅在 epoll_wait 返回时保存内核检测到的所有就绪事件，而不像 select 和 poll 的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率</li><li>maxevents：events数组的长度，即指定最多监听多少个事件</li><li>timeout：定时时间，单位为毫秒，如果 timeout 为 0，则 epoll_wait 会立即返回，如果timeout 为-1，则 epoll_wait 会一直阻塞，直到有事件就绪。</li><li>返回值：成功返回就绪的文件描述符的个数，出错返回-1，超时返回0</li></ul><h2 id="epoll实现TCP服务器">epoll实现TCP服务器</h2><p>服务器端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ser.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ip地址与端口号创建套接字，返回创建的套接字的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">CreateSocket</span><span class="params">(<span class="keyword">char</span> *ip, short port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = htons(port);</span><br><span class="line">    ser_addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = bind(listenfd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DealReadyEvents</span><span class="params">(struct epoll_event *events, <span class="keyword">int</span> n, <span class="keyword">int</span> epfd, <span class="keyword">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span>(fd == listenfd)  <span class="comment">//监听的套接字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line"><span class="keyword">int</span> c = accept(listenfd, (struct sockaddr*)&amp;cli_addr,&amp;len);</span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line">event.data.fd = c;</span><br><span class="line"><span class="keyword">int</span> res = epoll_ctl(epfd, EPOLL_CTL_ADD, c, &amp;event);</span><br><span class="line">assert(res != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"one client link success\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//链接的套接字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(events[i].events &amp; EPOLLRDHUP)  <span class="comment">//客户端关闭</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> res = epoll_ctl(epfd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">assert(res != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">close</span>(fd); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)  <span class="comment">//客户端发送来了数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = recv(fd, buff, <span class="number">127</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d client error\n"</span>, fd);</span><br><span class="line"><span class="keyword">int</span> res = epoll_ctl(epfd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">assert(res != <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">close</span>(fd); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//出错</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>,fd, buff);</span><br><span class="line">send(fd, <span class="string">"OK"</span>, <span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd = CreateSocket(<span class="string">"192.168.133.132"</span>, <span class="number">6000</span>);</span><br><span class="line">assert(<span class="number">-1</span> != listenfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>;</span></span><br><span class="line">events.events = EPOLLIN;</span><br><span class="line">events.data.fd = listenfd;</span><br><span class="line"><span class="keyword">int</span> res = epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;events);</span><br><span class="line">assert(res != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">NUM</span>];</span></span><br><span class="line"><span class="keyword">int</span> n = epoll_wait(epfd, events, NUM, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"epoll error \n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">DealReadyEvents(events, n,epfd, listenfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码同poll客户端</p><p><strong>执行结果</strong><br><img src="https://img-blog.csdnimg.cn/20210117102835967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="epoll总结">epoll总结</h2><p>1、epoll不再是一个接口，而是一组接口</p><p>2、能够监听的文件描述符个数没有限制，值的范围也没有限制</p><p>3、关注的事件类型更多，比poll多了EPOLLET和EPOLLONESHOT</p><p>4、epoll在内核中维护用户关注的事件类型，每次epoll_wait时不需要传递用户空间的数据。epoll_wait返回时，仅仅返回就绪的文件描述符和事件，相比于select和poll效率更高</p><p>5、epoll_wait返回的仅仅是就绪的事件，所以用户程序检测就绪文件描述符的时间复杂度就为O(1)</p><p>6、epoll内核采用的是回调的方式检测事件就绪</p><p>7、epoll不仅支持LT模式，也支持高效的ET模式</p><h2 id="epoll的LT与ET模式">epoll的LT与ET模式</h2><ul><li>LT模式：Level Trigger，电平触发，当epoll_wait将就绪事件返回后，如果用户程序没有处理该就绪事件，下一次epoll_wait还会通知这个就绪事件，LT是默认的工作模式</li><li>ET模式：Edge Trigger，边沿触发，当epoll_wait将就绪事件返回后，用户没有处理该就绪事件，则下一次epoll_wait不会通知该就绪事件。即同一个就绪事件只会通知一次，相比于LT模式，效率更高</li></ul><h2 id="EPOLLONESHOT事件">EPOLLONESHOT事件</h2><p>即使使用高效的ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中是线程不安全的，可能会出现两个线程同时操作一个socket的局面。如果希望一个socket连接的任一时刻都只被一个线程处理，可以使用 ==EPOLLONESHOT== 事件实现。</p><p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。</p><p>注意：注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket</p><h1>三组I/O复用函数的比较</h1><hr><p>这3组系统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定的超时时间，直到一个或多个文件描述符上有事件发生时返回，返回值就是就绪的文件描述符的数量。返回0表示没有事件发生，出错返回-1</p><p>select、poll、epoll区别：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">select</th><th style="text-align:left">poll</th><th style="text-align:left">epoll</th></tr></thead><tbody><tr><td style="text-align:left">事件集合</td><td style="text-align:left">用户通过3个参数分别传入感兴趣的可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。这使得用户每次调用select都要重置这3个参数</td><td style="text-align:left">统一处理所有事件类型，因此只需要一个事件集参数，用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件</td><td style="text-align:left">内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无须反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件</td></tr><tr><td style="text-align:left">应用程序索引就绪文件的时间复杂度</td><td style="text-align:left">O(n)</td><td style="text-align:left">O(n)</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">最大支持文件描述符个数</td><td style="text-align:left">一般有最大值限制</td><td style="text-align:left">65535（系统允许打开的最大文件描述符数目）</td><td style="text-align:left">65535</td></tr><tr><td style="text-align:left">工作模式</td><td style="text-align:left">LT</td><td style="text-align:left">LT</td><td style="text-align:left">LT与ET</td></tr><tr><td style="text-align:left">内核实现和工作效率</td><td style="text-align:left">采用轮询方式来检测就绪事件，算法时间复杂度为O(n)</td><td style="text-align:left">采用轮询方式来检测就绪事件，算法时间复杂度为O(n)</td><td style="text-align:left">采用回调方式来检测就绪事件，算法时间复杂度为O(1)</td></tr></tbody></table><h1>参考文献</h1><blockquote><p>[1]游双. Linux高性能服务器编程. 机械工业出版社，2013.5</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：I-O复用——select</title>
      <link href="/2021/02/03/Linux%EF%BC%9AI-O%E5%A4%8D%E7%94%A8%E2%80%94%E2%80%94select/"/>
      <url>/2021/02/03/Linux%EF%BC%9AI-O%E5%A4%8D%E7%94%A8%E2%80%94%E2%80%94select/</url>
      
        <content type="html"><![CDATA[<h1>I/O复用简介</h1><hr><p>一般TCP服务器的运行模型如下：<br><img src="https://img-blog.csdnimg.cn/20210109133858328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>客户端1先与服务器进行交互，这时候又有客户端2与客户端3与服务器建立连接，想要与服务器交互，但是由于服务器在与客户端1交互，所以客户端2、3就只能在listen()创建的内核的等待队列中等待</p><p>从上图可以看出问题：一个TCP服务器程序同时只能和一个客户端交互，其他链接上的客户端只能在TCP服务器的内核中等待。这个实现方式是不合理的，所以人们提出了I/O多路复用这个模型，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力</p><p>==I/O复用==：一个程序可以同时监听多个（上千个）文件描述符上是否有事件发生，如果某些文件描述符有事件发生，则去处理发生了事件的文件描述符，其他没有事件发生的文件描述符，则不予理睬</p><p>加上I/O复用之后的TCP服务器模型<br><img src="https://img-blog.csdnimg.cn/20210109134521410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>I/O复用使程序能同时监听多个文件描述符，这对于提高程序的性能至关重要。通常，网络程序在下列情况下需要使用I/O复用技术：</p><ul><li>TCP服务器同时处理监听套接字和连接套接字</li><li>服务器要同时处理TCP请求和UDP请求</li><li>程序要同时处理多个套接字</li><li>客户端程序要同时处理用户输入和网络连接</li><li>服务器要同时监听多个端口</li></ul><p>注意：I/O复用虽然能同时监听多个文件描述符，但<strong>它本身是阻塞的</strong>，并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器看起来好像是串行工作的。如果要提高并发处理的能力，可以配合使用多线程或多进程等编程方法</p><p>Linux下实现I/O复用的系统调用主要有：</p><ul><li>select</li><li>poll</li><li>epoll  （Linux独有的一种I/O复用方式）</li></ul><h1>select</h1><hr><p>select系统调用：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p><p>用户通过3个参数分别传入感兴趣的可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。所以用户每次调用select都要重置这3个参数</p><h2 id="select系统调用原型">select系统调用原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>nfds：所监听的所有文件描述符中的最大值 + 1，加一的原因是：文件描述符从0开始，使用nfds可以告知系统所需关注的文件描述符最大值到哪，提高内核执行效率</p></li><li><p>readfds，writefds，exceptfds：</p><p>作用①：监听的文件描述符的集合，分别是读事件的文件描述符集合，写事件的文件描述符集合，异常事件的文件描述符集合</p><p>作用②：在线修改：内核监听到某些文件描述符有事件发生时，也是通过这三个参数告知应用程序的。因此每次调用select之前必须重新设置这三个fd_set</p></li><li><p>timeout：定时时间，在这段时间内监听所有关注的文件描述符，如果定时时间到了，依旧没有事件就绪，select也会返回。如果需要select永久阻塞，则将timeout置为NULL，timeval结构体如下：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmieval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec;  <span class="comment">//秒数</span></span><br><span class="line"><span class="keyword">long</span> tv_usec; <span class="comment">//微秒数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>返回值：正常返回有事件发生的文件描述符的个数；超时返回0；出错返回负值。</p><p>由于select方法返回的是就绪个数，并不返回具体哪个就绪，所以在用户执行时还是需要再进行一次查询，查询具体哪个文件描述符就绪</p></li></ul><h2 id="select的参数-fd-set">select的参数 fd_set</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">int</span>  _fd_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _NFDBITS  (8 * (int)sizeof(_fd_mask))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">_fd_mask _fds_bits[<span class="number">32</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _FDS_BITS(set)  ((set)-&gt;_fds_bits)</span></span><br><span class="line">&#125;fd_set;</span><br></pre></td></tr></table></figure><p>fd_set记录文件描述符的方式：按照位来记录，因为只关注发生没发生，所以0没发生，1发生<br>(32个元素，每个元素32位，所以一共1024bit，如下图，假如现在要记录文件描述符3，只需要1左移三位再执行或运算<br><img src="https://img-blog.csdnimg.cn/20210109142113118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于位操作比较烦琐，可以通过下列宏函数来操作fd_set结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FD_SET(<span class="keyword">int</span>  fd, fd_set  *fdset)        <span class="comment">//设置fdset中的位fd 即把fd加入到fdset</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span>  fd, fd_set  *fdset)        <span class="comment">//清除fdset的位fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span>  fd, fd_set  *fdset)</span><span class="comment">//判断fd在不在fdsetp上</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> *fdset)</span>                   <span class="comment">//清除fdset中的所有位</span></span></span><br></pre></td></tr></table></figure><h2 id="用select实现TCP服务器">用select实现TCP服务器</h2><p><strong>总体思路：</strong><br><img src="https://img-blog.csdnimg.cn/20210110151034526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>服务器端代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ser.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDNUMBER 1024  <span class="comment">//文件描述符数组的大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ip地址与端口号创建套接字，返回创建的套接字的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">CreateSocket</span><span class="params">(<span class="keyword">char</span> *ip, short port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = htons(port);</span><br><span class="line">    ser_addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = bind(listenfd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有的文件描述符设置到fd_set结构体变量上, 找到当前最大的文件描述符的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">InitFdSet</span><span class="params">(<span class="keyword">int</span> *all_fd, fd_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FD_ZERO(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; FDNUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(all_fd[i] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FD_SET(all_fd[i], <span class="built_in">set</span>);</span><br><span class="line">            <span class="keyword">if</span>(all_fd[i] &gt; maxfd)</span><br><span class="line">            &#123;</span><br><span class="line">                maxfd = all_fd[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化文件描述符数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitAllFd</span><span class="params">(<span class="keyword">int</span> *all_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; FDNUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        all_fd[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向all_fd数组中插入fd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertFd</span><span class="params">(<span class="keyword">int</span> *all_fd, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; FDNUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(all_fd[i] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            all_fd[i] = fd;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据val在all_fd中进行删除，flag为1，则val为文件描述符， flag是0，则val是数组的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteFd</span><span class="params">(<span class="keyword">int</span> *all_fd, <span class="keyword">int</span> val, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; FDNUMBER; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(all_fd[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                all_fd[i] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        all_fd[val] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理就绪的事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DealReadyEvent</span><span class="params">(<span class="keyword">int</span> *all_fd, fd_set *<span class="built_in">set</span>, <span class="keyword">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对所有就绪事件的处理还依旧是串行的</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; FDNUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(all_fd[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(all_fd[i], <span class="built_in">set</span>))  <span class="comment">// 如果返回为真，说明这个文件描述符在set中，也就是文件描述符事件就绪</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                tcp服务器程序的所有文件描述符可以分成两类： 监听客户端链接的文件描述符、 与一个客户端链接的文件描述符</span></span><br><span class="line"><span class="comment">                如果是监听文件描述符就绪，处理就是accept</span></span><br><span class="line"><span class="comment">                如果是链接文件描述符，处理就是recv/send</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(all_fd[i] == listenfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line">                <span class="keyword">int</span> c = accept(listenfd, (struct sockaddr*)&amp;cli_addr, &amp;addr_len);</span><br><span class="line">                <span class="keyword">if</span>(c &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将接收客户端链接的文件描述符添加到all_fd数组中</span></span><br><span class="line">                InsertFd(all_fd, c);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Get New Clinet Link\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> n = recv(all_fd[i], buff, <span class="number">127</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)  <span class="comment">//  recv失败，或者客户端关闭了链接</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close</span>(all_fd[i]);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d Over\n"</span>, all_fd[i]);</span><br><span class="line">                    DeleteFd(all_fd, i, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>, all_fd[i], buff);</span><br><span class="line">                    send(all_fd[i], <span class="string">"OK"</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"DealReadyEvent over\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> listenfd = CreateSocket(<span class="string">"192.168.133.132"</span>, <span class="number">6000</span>);</span><br><span class="line">    assert(listenfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前程序所打开的所有的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span>  all_fd[FDNUMBER];</span><br><span class="line">    InitAllFd(all_fd);</span><br><span class="line">    InsertFd(all_fd, listenfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            select的三个参数：最大文件描述符值+1，关注读、写、异常事件的文件描述符集合fd_set，超时时间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        fd_set read_set;</span><br><span class="line">        <span class="keyword">int</span> maxfd = InitFdSet(all_fd, &amp;read_set);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>  <span class="title">timeout</span> = &#123;</span><span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = select(maxfd+<span class="number">1</span>, &amp;read_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//&amp;timeout);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select return\n"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"select error\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"timeout\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DealReadyEvent(all_fd, &amp;read_set, listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cli.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; //字节序的转换</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  //IP地址转换</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//创建套接字</span></span><br><span class="line">assert(<span class="number">-1</span> != sockfd);</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">ser_addr.sin_family = AF_INET;</span><br><span class="line">ser_addr.sin_port = htons(<span class="number">6000</span>);</span><br><span class="line">ser_addr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.133.132"</span>); </span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));<span class="comment">//指定连接的服务器端的 IP 地址和端口</span></span><br><span class="line">assert(<span class="number">-1</span> != res);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input: "</span>);</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buff, <span class="number">127</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff, <span class="string">"end"</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">        </span><br><span class="line">        send(sockfd, buff, <span class="built_in">strlen</span>(buff) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"><span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">recv(sockfd, buff, <span class="number">127</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buff);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20210110142347185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>结果分析：</strong></p><p>select调用最后一个参数定时时间timeout代码中设置为<code>NULL</code>，若所监听的文件描述符都没有事件发生，select将永久阻塞</p><p>当有客户端发起链接，select返回，并且select修改了fd_set结构体，打印<code>select return</code>，DealReadyEvent函数中accept()处理链接，打印<code>Get New Client Link </code>，接着打印<code>DealReadyEvent over </code></p><p>然后返回主函数while循环再次调用select，select再次阻塞，客户端这时候输入<code>i am 1</code>，select调用返回，DealReadyEvent函数中recv接收客户端发送的数据，打印出<code>4: i am 1 </code>,处理结束后打印<code>DealReadyEvent over</code></p><blockquote><p>执行结果中服务器程序创建的与客户端链接的文件描述符为什么从4开始？</p><ul><li><p>Linux上启动的进程默认会打开三个文件描述符：0：标准输入stdin；1：标准输出stdout；2：标准错误输出stderr</p></li><li><p>文件描述符3被服务器用socket()创建套接字返回的文件描述符占用</p></li><li><p>因此服务器程序创建的与客户端链接的文件描述符可取：4 – 1023（共1000个）</p></li><li><p>终端中使用<code>ulimit  -a</code>可以查看当前的各种用户进程限制<br><img src="https://img-blog.csdnimg.cn/20210109204950856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul></blockquote><h2 id="select总结">select总结</h2><p>1、最多只能监听1024个文件描述符（理论上），文件描述符从0开始，即最大值为1023，实际上最多监听的文件描述符数量要减去4</p><p>2、select只能关注3种事件类型：读事件、写事件、异常事件</p><p>3、内核会在线修改用户传递的关注事件的文件描述符的集合的变量（即修改fd_set结构），每次调用select之前都必须重新设置三个fd_set结构变量</p><p>4、select返回后，只是告诉用户程序有几个文件描述符就绪，但是并没有指定是具体的哪几个。因此用户程序就需要遍历所有的文件描述符来探测具体是哪些文件描述符处于就绪，所以时间复杂度为O(n)</p><p>5、用户程序得自己维护所有的文件描述符。然后，每一次调用select的时候，都需要将用户空间的fd_set集合传递给内核空间，select返回时，又需要将内核的fd_set传递给用户空间。这样调用select的时候，会存在两次的数据拷贝（如下内核代码所示），效率不是很高<br><img src="https://img-blog.csdnimg.cn/20210109211324181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6、select内核采用的是轮询的方式去监测哪些文件描述符上的事件就绪（底层是个for循环）<br><img src="https://img-blog.csdnimg.cn/20210109212516203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7、select的工作模式只能是LT模式（Level Trigger，电平触发）</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：多态、虚函数</title>
      <link href="/2021/02/03/C-%EF%BC%9A%E5%A4%9A%E6%80%81%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2021/02/03/C-%EF%BC%9A%E5%A4%9A%E6%80%81%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><hr><p>==多态==：多态性是面向对象的关键技术之一。多态可以认为就是同一接口有不同的形态。即利用多态技术，可以调用同一个函数名的时候，实现完全不同的功能。</p><p>多态分为静态多态和动态多态。函数重载、运算符重载以及模板都是属于静态多态，也称编译时多态。动态多态也称运行时多态，即在程序运行阶段才能确定的关系，例如某些函数的调用关系在编译阶段无法确定，到了运行阶段才能确定。运行时的多态性是通过继承关系和虚函数来实现的。目的也是建立一种通用的程序。通用性是程序追求的主要目标之一</p><p>实现运行时多态的三个条件：公有继承、虚函数、指针或引用去调动</p><p>==联编==：联编是指计算机程序彼此关联的过程，是把一个标识符和一个存储地址联系在一起的过程，也就是把一条消息和一个对象的操作相结合的过程，可以狭义的认为是函数间调用关系的确定。按照联编所确定的时刻不同，可分为：静态联编和动态联编。</p><p>==静态联编==：静态联编（绑定）是指联编出现在编译链接阶段，又称为早期联编，通过静态联编可实现静态多态。函数重载，运算符重载，模板是静态联编的，函数的调用关系的确定是在编译阶段</p><p>==动态联编==：动态联编（绑定）是指在程序运行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定，动态联编对函数的选择不是基于指针或者引用，而是基于对象类型，不同的对象类型将做出不同的编译结果，C++中提供的动态联编技术是通过虚函数实现的</p><h2 id="虚函数">虚函数</h2><hr><p>虚函数是动态联编的基础，虚函数可以使得函数调用关系推迟到运行时，在类中将成员函数定义成虚函数的格式为（类外不可加虚）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 类型 函数名(参数列表)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>只有类的成员函数才能加虚（有this指针才能虚化），因为虚函数仅适用于有继承关系的类对象。由某一个类的一个成员函数被定义为虚函数，则由该类派生出来的所有派生类中，该函数始终保持虚函数的特征</p><p>virtua只能加在类设计中，类外不可以，类内声明处加virtual就好  （扩充：参数的默认值也是在声明处给或者理解为函数名字第一次出现的地方）</p><p>当在派生类中重新定义虚函数时，可以不加关键字virtual（基类的那个有virtual），但名称、参数列表、返回类型必须与基类中的虚函数一样</p><p>虚函数其他部分和正常函数一样，只是最前面加个virtual关键字</p><p>虚函数示例如下：<br><img src="https://img-blog.csdnimg.cn/20201208114315598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>虚函数的覆盖如下图：子类中若重写了父类的虚函数，子类中就会用重写的覆盖掉继承来的父类的</p><p>虚表：<br><img src="https://img-blog.csdnimg.cn/20201208114702105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>==虚表==：含有虚函数的类编译时会建立起虚表（虚表存在.data区的.rodata区），虚函数记录在虚表中，继承的时候会拷贝一份父类的虚表，若派生类中重写了虚函数则用新的覆盖掉父类的，若有新设计的函数则添加进去，在运行的时候通过查虚表来确定对应的关系，含有虚表的类除了正常的成员外，还会含有一个虚表指针（4字节）<br><img src="https://img-blog.csdnimg.cn/20201208114922234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果使用基类指针或引用指明派生类对象并使用该指针调用虚函数（成员选择符用-&gt;），则程序动态地（运行时）选择该派生类的虚函数，动态联编；如果使用对象名和点成员选择运算符&quot; . &quot;引用特定的一个对象来调用虚函数，则被调用的虚函数是在编译时确定的，静态联编</p><p>注意：</p><ul><li><p>当在基类中把成员函数定义为虚函数后，若派生类欲定义同名虚函数，则派生类中的虚函数必须与基类中的虚函数同名，且函数的参数个数、参数类型必须完全一致。如果基类中返回基类指针，派生类中返回派生类指针是允许的，这是一个例外</p></li><li><p>基类中virtual关键字不可省，派生类中可以省，该函数仍为虚函数，但是函数名、返回类型、参数列表必须与基类一样</p></li><li><p>动态多态必须通过基类对象的引用或基类对象的指针调用虚函数才能实现</p></li><li><p>友元函数不能定义为虚函数，因为友元函数不是类的成员函数</p></li><li><p>静态成员函数不能定义为虚函数，因为静态成员函数属于类，与具体的某个对象无关</p></li><li><p>内联函数不能定义为虚函数，因为内联函数的调用处理是在编译时刻，即在编译时刻，用内联函数的实现代码去替换函数调用，运行时内联函数已不存在；而虚函数的调用是动态联编，即运行时刻调用哪一个函数</p></li><li><p>不能将构造函数定义为虚函数，但可将析构函数定义为虚函数。如果类的构造函数中有动态申请的存储空间，则应在析构函数中释放该空间，此时，可以将析构函数定义为虚函数，以便实现撤销对象时的多态性</p></li><li><p>虚函数与一般函数相比，调用时的执行速度要慢一些。这是因为，为了实现动态联编，编译器为每个含有虚函数的对象增加指向虚函数表的指针，通过该指针实现虚函数的间接调用</p></li><li><p>在一般成员函数中调用虚函数，遵循的动态多态规则，但若在构造函数中调用虚函数，不遵循动态多态规则，即调用的是类自身的虚函数</p></li><li><p>当基类的指针指向派生类对象时，若通过它调用虚函数，则它指向的是哪个类的对象，调用的就是哪个类的虚函数</p></li></ul><p><strong>虚函数表指针(vptr)创建时机</strong></p><p>vptr跟着对象走，所以对象什么时候创建出来，vptr就什么时候创建出来，也就是==运行==的时候。<br>当程序在编译期间，编译器会为构造函数中增加为vptr赋值的代码(这是编译器的行为)，当程序在运行时，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有为这个对象的vptr赋值的语句。</p><p><strong>虚函数表创建时机</strong></p><p>虚函数表创建时机是在==编译==期间。编译期间编译器就为每个类确定好了对应的虚函数表里的内容。<br>所以在程序运行时，编译器会把虚函数表的首地址赋值给虚函数表指针，所以，这个虚函数表指针就有值了。</p><h2 id="final与override">final与override</h2><hr><p>override：派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的（重载关系）。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，我们可能是想用派生类中的去覆盖基类的，但不小心参数列表写错了。这类错误如果想让编译器能发现，可以使用override关键字来说明派生类中的那个函数。<strong>如果使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报错</strong></p><p>override示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span>B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">//正确：f1与基类中的f1匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;       <span class="comment">//错误：B没有形参如f2(int)的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">//错误：f3不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">//错误：B没有名为f4的虚函数</span></span><br><span class="line">&#125;;<span class="comment">//本段代码摘自C++Primer，结构体也是可以继承的</span></span><br></pre></td></tr></table></figure><p>final：当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错</p><p>final示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// Error: 父类中没有 bar虚函数可以被重写或final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="区分函数重载、同名隐藏、覆盖">区分函数重载、同名隐藏、覆盖</h2><hr><p><img src="https://img-blog.csdnimg.cn/20201208112847925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="虚函数与默认实参">虚函数与默认实参</h2><hr><p>和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则<strong>该实参值由本次调用的静态类型决定</strong></p><p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符</p><p>所以如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致</p><p>如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base:: print a: "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> b = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived:: print b: "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d1;</span><br><span class="line">    Base *bp = &amp;d1;</span><br><span class="line">    bp-&gt;print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20201208112913947.png" alt="在这里插入图片描述"><br>编译时确定可访问属性和默认值（10），运行时不在乎可访问属性也不看派生类的那个默认值（20）</p><h2 id="虚析构函数">虚析构函数</h2><hr><p>如果类的构造函数中有动态申请的存储空间，在析构函数中需要释放该空间，此时可以将析构函数定义为虚函数，以实现通过基类指针释放它所指向的派生类对象时的动态多态</p><p>构造函数不能定义为虚函数，因为构造函数的任务之一就是填充虚表指针，如果把构造函数定义为虚的，那么调动构造函数就需要通过虚表指针去查虚表，但是，虚表指针还没填充，因为虚表指针是由构造函数来填充的，这就出现了矛盾，因此不能把构造函数定义为虚函数</p><h2 id="回避虚函数的机制">回避虚函数的机制</h2><hr><p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>该代码强行调用Quote的net_price函数，而不管实际baseP指向的对象类型到底是什么。该调用将在编译时完成解析</p><blockquote><p>通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制</p></blockquote><p>什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作</p><blockquote><p>如果一个派生类虚函数调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本的自身调用，从而导致无限递归</p></blockquote><h2 id="纯虚函数和抽象类">纯虚函数和抽象类</h2><hr><p>==纯虚函数==：在定义一个基类时，如果不能给出某些成员函数的具体实现，而在派生类中才可以给出具体的实现，则可以把基类中没有给出具体实现的函数定义为纯虚函数，定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 类型 函数名(参数列表) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>=0表明程序员将不定义该函数，函数声明是为派生类保留一个位置。“=0”本质上是将指向函数体的指针指定为NUL</p><p>注意：该定义中没有函数体，即没有函数体的具体实现部分，函数体代之以=0。这与函数体定义成空函数是有区别的，如若将函数体定义为空函数，即有大括号但是大括号里什么都不写，它表示在函数体中不做任何工作</p><p>==抽象类==：含有纯虚函数的类称为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构中的较上层。抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问权限</p><p>注意：</p><ul><li>抽象类只能做派生类的基类，不能定义抽象类的对象，即抽象类不能实例化对象，但抽象类可以定义指针</li><li>若派生类实现了基类的所有重虚函数，则派生类就不再是抽象类了。若派生类没有实现基类所有的纯虚函数，则该派生类依然是抽象类</li><li>在一般正常使用的情况下，纯虚函数没有函数体。从语法角度上说，纯虚函数可以写函数体，即=0后面再跟大括号函数体，即使给出了纯虚函数的函数体，该函数依然是纯虚函数</li></ul><blockquote><p>C语言里void就是一种抽象类型，无类型的地址可以指向任何类型的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> dx = <span class="number">12.23</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *vp = <span class="literal">NULL</span>;</span><br><span class="line">vp = &amp;a;</span><br><span class="line">vp = &amp;dx;</span><br><span class="line">vp = &amp;p;</span><br><span class="line">vp = &amp;vp;</span><br><span class="line"><span class="comment">//这些都是可以的</span></span><br></pre></td></tr></table></figure></blockquote><p>总结：抽象类的规定</p><ul><li>抽象类只能用作其他类的基类，不能建立抽象类对象</li><li>抽象类不能用作参数类型、函数返回类型或显示转换的类型</li><li>可以定义指向抽象类的指针或引用，此指针可以指向它的派生类，进而实现多态性</li></ul><h2 id="虚函数与虚基类的区分">虚函数与虚基类的区分</h2><hr><p>虚函数：类成员函数的声明中有 virtual 关键字  //定义方式<code>virtual double Area() </code>;</p><p>虚函数作用：实现动态多态 ，运行时确定函数调用关系</p><p>虚基类：virtual继承的类，为使共同基类在派生类中只有一个拷贝 //定义方式<code>class B：virtual public A</code></p><p>虚基类作用：当一个派生类中有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接基类的数据成员的多份同名成员，就会造成二义性，将这个共同基类设置为虚基类时，同名的数据成员就会只存在一个副本，同一个函数名只有一个映射，就解决了二义性</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：线程-2-——线程安全、线程与fork</title>
      <link href="/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-2-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8Efork/"/>
      <url>/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-2-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8Efork/</url>
      
        <content type="html"><![CDATA[<h2 id="4-线程安全">4. 线程安全</h2><hr><h3 id="4-1-概念">4.1 概念</h3><p>线程安全：一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，则称其为线程安全的</p><p>线程不安全：由于线程是并发运行的，并且一个进程中的线程之间共享地址空间。如果这个多线程的程序运行过程中存在多线程去修改共享的数据时，会造成执行的结果存在二义性</p><h3 id="4-2-线程不安全示例">4.2 线程不安全示例</h3><p>多线程修改共享的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gdata = <span class="number">1</span>; <span class="comment">// .data段保存的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// fun的栈区定义的变量</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">gdata++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程和函数线程并发执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// main的栈区定义的变量</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">gdata++; <span class="comment">// 1、读取内存当前的值 2、在寄存器上执行++操作 3、写回内存</span></span><br><span class="line">&#125; </span><br><span class="line">pthread_join(id, <span class="literal">NULL</span>);<span class="comment">//等待函数线程执行结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下的代码只有main线程执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"gdata = %d\n"</span>, gdata);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20201127125637965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行结果分析：因为gdata是全局区的数据，主线程和函数线程共享gdata，而++操作不是一个原子操作，分成读改写三步：读取内存当前值，在寄存器上执行++操作，写回内存。所以在执行的时候，就有可能一个线程读了之后，还未写回内存，另一个线程又执行了读，导致结果本来要加2，但是只加了1，使得执行结果不符合我们的预期</p><p>对于该类多线程修改共享数据的问题，可以使用线程同步（互斥锁）来解决</p><h3 id="4-3-可重入函数">4.3 可重入函数</h3><p>可重入函数：可以被重复进入的函数，即可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误</p><p>不可重入函数：由于使用了一些系统资源，比如全局变量区，中断向量表等，因此不能被中断的函数，如果多线程环境下使用可能会出现问题</p><p><strong>strtok与strtok_r</strong></p><p>strtok()是不保证线程安全的，在多线程程序中，就可能会出现问题，strtok()实现的代码使用了线程间共享的数据，它是不可重入函数</p><p>与其对应的保证线程安全的方法： strtok_r()，strtok_r()就是可重入函数</p><p>strtok不保证线程安全代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buff[] = <span class="string">"1 2 3 4 5 6 7 8"</span>; <span class="comment">// fun的栈区</span></span><br><span class="line"><span class="keyword">char</span> *p = strtok(buff, <span class="string">" "</span>); <span class="comment">// 不保证线程安全</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun : %s\n"</span>, p);</span><br><span class="line">p = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>); <span class="comment">// 不保证线程安全</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发执行的代码</span></span><br><span class="line"><span class="keyword">char</span> buff[] = <span class="string">"a b c d e f g h"</span>; <span class="comment">// main线程的栈区</span></span><br><span class="line"><span class="keyword">char</span> *p = strtok(buff, <span class="string">" "</span>); <span class="comment">// 不保证线程安全</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main: %s\n"</span>, p);</span><br><span class="line">p = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>); <span class="comment">// 不保证线程安全</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20201127133015751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主线程main本来是切割&quot;abcdefg&quot;的，但过一会也跟着函数线程fun去切割&quot;12345678&quot;了</p><p>把strtok换成strtok_r，保证线程安全代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buff[] = <span class="string">"1 2 3 4 5 6 7 8"</span>; <span class="comment">// fun的栈区</span></span><br><span class="line"><span class="comment">//char *p = strtok(buff, " "); // 不保证线程安全</span></span><br><span class="line"><span class="keyword">char</span> *q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *p = strtok_r(buff, <span class="string">" "</span>, &amp;q);</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun : %s\n"</span>, p);</span><br><span class="line"><span class="comment">// p = strtok(NULL, " "); // 不保证线程安全</span></span><br><span class="line">p = strtok_r(<span class="literal">NULL</span>, <span class="string">" "</span>, &amp;q);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发执行的代码</span></span><br><span class="line"><span class="keyword">char</span> buff[] = <span class="string">"a b c d e f g h"</span>; <span class="comment">// main线程的栈区</span></span><br><span class="line"><span class="comment">//char *p = strtok(buff, " "); // 不保证线程安全</span></span><br><span class="line"><span class="keyword">char</span> *q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *p = strtok_r(buff, <span class="string">" "</span>, &amp;q);</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main: %s\n"</span>, p);</span><br><span class="line"><span class="comment">//p = strtok(NULL, " "); // 不保证线程安全</span></span><br><span class="line">p = strtok_r(<span class="literal">NULL</span>, <span class="string">" "</span>, &amp;q);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20201127132540192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主线程main始终切割&quot;abcdefg&quot;，函数线程fun始终切割的是&quot;12345678&quot;，因为并发执行所以顺序是不确定的，但是两个线程始终切割的内容没变</p><h3 id="4-4-不保证线程安全的常见函数">4.4 不保证线程安全的常见函数</h3><p><img src="https://img-blog.csdnimg.cn/20201127133314715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-线程与fork">5. 线程与fork</h2><hr><h3 id="5-1-多线程中调用fork">5.1 多线程中调用fork</h3><p>多线程中某一个线程调用了fork创建子进程，在子进程中线程的运行情况是怎样的？</p><p>或者说：多线程中某个线程调用 fork()，子进程会有和父进程相同数量的线程吗？</p><p>对于如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun start\n"</span>);</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">assert(pid != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: mypid = %d\n"</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: mypid = %d\n"</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);<span class="comment">//创建函数线程</span></span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main and mypid = %d\n"</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20201127135454347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以：==多线程中某个线程调用 fork()，子进程不会有和父进程相同数量的线程，子进程中只有调用fork的线程会被执行，其他线程不会被执行==</p><h3 id="5-2-多线程中调用fork的锁的继承问题">5.2 多线程中调用fork的锁的继承问题</h3><p>父进程被加锁的互斥锁 fork 后在子进程中是否也是已经加锁状态？</p><p>对于如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun start\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pthread_mutex_lock(&amp;mutex);</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork(); <span class="comment">// 调用fork时，互斥锁的状态是加锁状态</span></span><br><span class="line">assert(pid != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// pthread_mutex_unlock(&amp;mutex); // 父子进程都会执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child: mypid = %d\n"</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"father: mypid = %d\n"</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main and mypid = %d\n"</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20201127141307137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，子进程并没有输出，而是被阻塞了，这是因为：调用fork时，子进程会复制父进程的锁（父子进程所使用的锁不是同一把锁），==子进程会继承父进程的互斥锁的状态==。而由于fork之后子进程中只有调用fork的线程会被执行，其他线程不会被执行，所以子进程不会执行main里面剩余的，即main刚开始加的锁在子进程中无法被解开，子进程就阻塞在了<code>pthread_mutex_lock(&amp;mutex);</code>这里；而对于父进程，在执行<code>pthread_mutex_lock(&amp;mutex);</code>时也会阻塞，但是等到父进程的主线程执行完毕，解锁之后，父进程的函数线程就可以继续输出了</p><p>那么如何解决这种情况呢？即如何使得fork出来的子进程能解开之前的锁同时保证线程安全呢？</p><p>解决方案：使用互斥锁对fork()调用做一个保护， 使得在fork调用的过程中锁是被自己加锁的，即在fork之前执行加锁，解锁操作写在fork下面，这样父子进程都会执行解锁操作。线程库提供了一个注册方法pthread_atfork()来做这件事情</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_atfork</span><span class="params">(<span class="keyword">void</span> (*<span class="built_in">prepare</span>)(), <span class="keyword">void</span> (*parent)(), <span class="keyword">void</span> (*child)())</span></span>;</span><br><span class="line"><span class="comment">// 注册方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">prepare这个方法 -- 对所有的锁执行加锁操作，它会在fork调用之前调用</span></span><br><span class="line"><span class="comment">parent这个方法  -- 对所有的锁执行解锁操作，它会在fork调用之后在父进程中执行</span></span><br><span class="line"><span class="comment">child这个方法  -- 对所有的锁执行解锁操作，它会在fork调用之后在子进程中执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>pthread_atfork在fork()之前调用，当调用fork时，内部创建子进程前在父进程中会调用prepare，内部创建子进程成功后，父进程会调用parent ，子进程会调用child</p><p>添加如下三个函数到上例代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span><span class="comment">//对所有的锁执行加锁操作，它会在fork调用之前调用</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">pthread_mutex_lock(&amp;mutex); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span><span class="comment">//对所有的锁执行解锁操作，它会在fork调用之后在父进程中执行</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">pthread_mutex_unlock(&amp;mutex); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child</span><span class="params">()</span><span class="comment">//对所有的锁执行解锁操作，它会在fork调用之后在子进程中执行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在fork之前调用pthread_atfork方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_atfork(<span class="built_in">prepare</span>, parent, child);</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20201127145529620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>子进程如愿输出</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：继承</title>
      <link href="/2021/02/03/C-%EF%BC%9A%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/02/03/C-%EF%BC%9A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="基本概念">基本概念</h2><hr><p>==继承==（inheritance）机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构。体现了由简单到复杂的认识过程。</p><p>==多态性==（polymorphism）是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。函数的重载，运算符的重载，属于编译时的多态性(早期绑定)。以虚基类为基础的运行时的多态性(晚绑定，只有在运行时才知道和哪个函数有关系)是面向对象程序设计的标志性特征。体现了类推和比喻的思想方法。</p><p>层次概念是计算机的重要概念。通过继承的机制可对类分层，提供类型/子类型的关系</p><p>C++通过类派生的机制来支持继承。被继承的类称为基类(base class)或超类或父类，新派生的类称为派生类(derived class)或子类</p><p>基类和派生类的集合称作类继承层次结构，如果基类和派生类共享相同的接口，则派生类称作基类的子类型</p><p>派生反映了事物之间的联系，事物的共性与个性之间的关系。派生与独立设计的若干类，前者工作量少，重复的部分可以从基类继承来，不需要单独编程</p><p>==单一继承==：一个派生类只有一个直接基类，如下：(single inheritance)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 访问限定符 基类</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    成员表<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>==多重继承==：一个派生类同时有多个基类，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 访问限定符 基类<span class="number">1</span>, 访问限定符 基类<span class="number">2.</span>..</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    成员表<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：很多时候避免多重继承，多重继承会引入很多麻烦和其好处不成正比</p><p>==继承方式==：公有继承public、保护继承protected、私有继承private，继承方式如果省略，表示私有继承，即类的默认继承方式是私有的</p><p>==继承机制优点==：代码重用，基类被派生类继承后，派生类中就不需要重复编写基类中的成员</p><h2 id="访问控制和继承">访问控制和继承</h2><hr><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p><table><thead><tr><th style="text-align:left">访问</th><th style="text-align:left">public</th><th style="text-align:left">protected</th><th style="text-align:left">private</th></tr></thead><tbody><tr><td style="text-align:left">同一个类(本类的成员函数)</td><td style="text-align:left">yes</td><td style="text-align:left">yes</td><td style="text-align:left">yes</td></tr><tr><td style="text-align:left">派生类中(派生类的成员函数)</td><td style="text-align:left">yes</td><td style="text-align:left">yes</td><td style="text-align:left">no</td></tr><tr><td style="text-align:left">外部的类(如该类的对象)</td><td style="text-align:left">yes</td><td style="text-align:left">no</td><td style="text-align:left">no</td></tr></tbody></table><p>一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h2 id="私有继承">私有继承</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">private</span> Base</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>私有继承时，基类中的public和protected成员在派生类中均变成了private成员，在派生类中可直接访问；而基类中的private成员虽然被继承下来了，但在派生类中不可直接访问</p><h2 id="保护继承">保护继承</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">protected</span> Base</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>保护继承时，基类中的public和protected成员在派生类中均变成了protected成员，在派生类中可直接访问；而基类中的private成员虽然被继承下来了，但在派生类中不可直接访问</p><h2 id="公有继承">公有继承</h2><hr><p>公有继承时，基类中的public和protected成员在派生类中仍为public和protected成员，在派生类中可直接访问；而基类中的private成员虽然被继承下来了，但在派生类中不可直接访问</p><p>==公有继承代表是一个的意思：is a==</p><p>学生继承自人类(Student  is  a  person) ，人类是基类，学生类是派生类，“人类是个泛泛的概念，学生类是它的特例，学生是人，但是人不一定是学生”</p><p>==派生类的内存结构==</p><p><img src="https://img-blog.csdnimg.cn/20201123223928691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>对于派生类Derived来说，它一共有四个成员，分别是：隐藏的父类Base、x、y、z</p><p>两层继承内存结构如下：</p><p><img src="https://img-blog.csdnimg.cn/20201123223943234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="可访问性">可访问性</h2><hr><p>公有继承方式下，对于派生类的成员函数，本类的private,protected,public数据成员都可以访问，“自己可以访问自己的私有公有保护”，但是不可以访问父类的private成员，父类的protected和public成员可以访问</p><p>如下图：==本类的成员函数不可以访问父类的私有数据成员，其余的都可以访问==</p><p><img src="https://img-blog.csdnimg.cn/20201123223955144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如果是私有继承方式，仍旧不能访问父类的私有数据成员，其余的可以访问，<strong>私有继承只是把父类的保护和公有成员的属性改为私有的了</strong>，公有继承不改变父类保护和公有成员的属性</p><p>如果是保护继承方式，仍旧不能访问父类的私有数据成员，其余的可以访问，保护继承只是把父类的保护和公有成员的属性改为保护的了</p><p>总结：继承关系中，在派生类中可以访问继承来的对象的保护和公有，继承来的对象的私有不可访问</p><p>多层继承关系中也是一样的</p><p>私有继承来的则有一个私有的隐藏父类对象，保护继承来的则有一个保护的隐藏父类对象，公有继承来的则有一个公有的隐藏父类对象，继承方式决定了隐藏的父类的对象的可访问性</p><p>在派生类中指的是派生类的成员函数(Derived::set())，在派生类外则如该派生类的对象(Derived der;)，在派生类中可以访问继承来的对象的保护和公有，派生类外只有公有成员可以直接访问</p><p>保护成员的优势：无论何种继承方式，父类的私有都不可访问，而对于保护成员，无论何种继承方式在派生类中都是可直接访问的</p><p><img src="https://img-blog.csdnimg.cn/20201123224012199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="成员属性为protected的优点">成员属性为protected的优点</h2><hr><p>对于一个单独的类来说，private成员和protected成员都是在类内可以直接访问的，在类外不可以直接访问，在这方面没什么区别。</p><p>在有继承的情况下，无论何种继承方式，private成员都无法在派生类中直接被访问。而对于protected成员，无论何种继承方式，在派生类中都是可以直接访问的，这就是protected成员的优点</p><p>那么在什么情况下基类的protected成员的类内直接访问特性能传递到派生类的派生类中呢？这要根据不同的派生方式决定：</p><ul><li>对于公有派生或保护派生，基类的protected成员在派生类中依然保持protected访问权限。因此，protected成员的类内直接访问特性可以被继承传递到派生类的派生类中</li><li>对于私有派生，基类的protected成员在派生类中变成了private成员，此时基类的protected成员在派生类内部可以直接访问，但是无法在派生类的派生类中被直接访问。在继承或派生链中，一旦出现私有继承，基类成员的“类内直接访问特性”就无法在派生类中继续传递下去</li></ul><p>小结：protected成员的优点：既可以在本类中实现数据的隐藏（类内可直接访问，类外不可被直接访问），又可以将其类内直接访问特性传递到派生类中（在派生类中可以直接访问，类外不可直接访问）。而private成员不具备将类内直接访问特性传递到派生类中</p><h2 id="构造、析构顺序">构造、析构顺序</h2><hr><p>若一个类是由多个基类派生出来的，则在定义派生类构造函数时，需要调用基类的构造函数，初始化基类成员</p><p>派生类构造函数的一般格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类外定义时</span></span><br><span class="line">ClassName::ClassName(args) : Base1(arg_1),Base2(arg_2),...</span><br><span class="line">&#123;</span><br><span class="line">    派生类自身的构造函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类构造函数的执行顺序为：首先依次调用基类的构造函数Base1(arg_1), Base2(arg_2), … ,然后执行派生类自身的构造函数体</p><p>析构顺序为：首先执行派生类自身的析构函数体，然后按~Basen()…~Base2(), ~Base1()，的顺序调用基类的析构函数，即析构函数的执行顺序与构造函数相反</p><p>若在派生类中除了包含基类成员，还包含对象成员，则在派生类的构造函数的初始化成员列表中不仅要列出基类的构造函数，也要列举对象成员的构造函数。构造时，先调用基类的构造函数，再调用对象成员的构造函数，最后进入派生类自身的构造函数，析构顺序与之相反</p><h2 id="构造函数、析构函数继承问题">构造函数、析构函数继承问题</h2><hr><p>C++中派生类继承基类的成员，包括数据成员和成员函数。例如基类的私有数据成员被派生类继承后，即使在派生类中不能直接访问，但它也被继承了。</p><p>但是基类的构造函数和析构函数不会被派生类继承，而只能通过派生类的构造函数或析构函数自动调用，完成对基类数据成员的构建或清理工作</p><h2 id="二义性和支配规则">二义性和支配规则</h2><hr><p>==二义性==（访问冲突）：在多重继承中，当在派生类中出现两个以上的同名可直接访问的基类成员函数时，便出现了二义性，即访问冲突，如下图：（A类和B类具有同名成员x和Show()，它们均被继承到C类中）</p><p><img src="https://img-blog.csdnimg.cn/20201123224028728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>解决方法：</p><ul><li>定义基类时，保证一个基类中的成员名与另一个基类中的成员名不相同</li><li>在派生类中使用作用域运算符来限定所访问的成员是属于哪一个基类的</li></ul><p>由于C++是通过作用域运算符来解决访问二义性问题，因此规定任一基类在派生类中只能被直接继承一次，否则访问冲突无法通过作用域运算符解决。</p><p>==支配规则==：在C++中，允许派生类中新增加的成员名与其基类的成员名相同，这种同名并不产生访问二义性。在派生类中访问同名成员时，若直接用成员名访问，则访问的是派生类自身的成员（就近）；要访问基类的同名成员，可以使用作用域运算符来限定。即对同名成员的访问，派生类优先，这种优先关系称为支配规则</p><h2 id="虚基类">虚基类</h2><hr><p>对于如下左图的多重继承关系中，在D类中包含了基类A的两个拷贝，所以一个D类对象包含了两份A类对象的数据成员。此时在D类的成员函数中，若欲访问A的成员x，则必须以B::x和C::x区分（注意：::不能嵌套使用）</p><p><img src="https://img-blog.csdnimg.cn/20201123224040809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><p>若欲得到上图右边的继承关系，即要使得公共的基类在派生类中只有一个拷贝，则需要将A类说明成<strong>虚基类</strong>，说明虚基类的方法是在派生类B、C的定义中，在基类A的类名前加上关键字virtual，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> C</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>说明成虚基类的一般格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> <span class="keyword">virtual</span> 继承方式 基类名<span class="comment">//virtual也可以放在继承方式和基类名中间，但一般放在前面</span></span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>有虚基类时构造函数的调用顺序：若派生类中有多个基类，这些基类中有虚基类也有非虚基类，则先调用虚基类的构造函数，再调用非虚基类的构造函数。虚基类的构造函数按虚基类的继承顺序调用，非虚基类的构造函数按非虚基类的继承顺序调用，代码验证如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" A "</span>;&#125;</span><br><span class="line">    ~A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~A "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" B "</span>;&#125;</span><br><span class="line">    ~B() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~B "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" C "</span>;&#125;</span><br><span class="line">    ~C() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~C "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" D "</span>;&#125;</span><br><span class="line">    ~D() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~D "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A,<span class="keyword">public</span> D,<span class="keyword">virtual</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://img-blog.csdnimg.cn/20201123224057562.png#pic_center" alt="在这里插入图片描述"></p><h2 id="赋值兼容与切片现象">赋值兼容与切片现象</h2><hr><p>==赋值兼容规则==：在任何需要基类对象的地方都可以用公有派生类的对象来代替（只适合公有派生），即可以将公有派生类的对象赋值给基类对象，反之不允许</p><ol><li>派生类的对象可以赋值给基类的对象，这时是把派生类对象中从对应基类中继承来的隐藏对象赋值给基类对象。反过来不行，因为派生类的新成员无值可赋。</li><li>可以将一个派生类的对象的地址赋给其基类的指针变量，但只能通过这个指针访问派生类中由基类继承来的隐藏对象，不能访问派生类中的新成员。同样也不能反过来做。</li><li>派生类对象可以初始化基类的引用。引用是别名，但这个别名只能包含派生类对象中的由基类继承来的隐藏对象。</li></ol><p>总结：派生类对象可以给基类对象赋值，<code>base = derived;</code>，<code>person = student;</code></p><p>子对象可以赋值给父对象的原因：公有派生代表”是一个“的意思，is a，Student  is  a person. 所以student可以赋值给person</p><p>例如下：人可以跳舞，学生是人，学生也就可以跳舞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> x = <span class="number">0</span>):value(x)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">int</span> x = <span class="number">0</span>):num(x),Person(x+<span class="number">10</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">(Person &amp; per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">se</span><span class="params">(<span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">st</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    Person &amp;ps = st;<span class="comment">//派生类对象可以初始化基类的引用</span></span><br><span class="line">    Person *p = &amp;st;<span class="comment">//派生类的对象的地址赋给其基类的指针变量</span></span><br><span class="line">    se = st;<span class="comment">//派生类的对象可以赋值给基类的对象</span></span><br><span class="line">    </span><br><span class="line">    dance(se);<span class="comment">//人可以跳舞</span></span><br><span class="line">    <span class="comment">//在任何需要基类对象的地方都可以用公有派生类的对象来代替</span></span><br><span class="line">    dance(st);<span class="comment">//学生也可以跳舞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何基类出现的地方，派生类都应当可以出现，但是反过来不行</p><p>==C++切片现象==：当子类对象去给父类对象赋值的时候，手起刀落，把子类中隐藏的父对象切出来赋值给父对象</p><p><img src="https://img-blog.csdnimg.cn/20201123224110394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gVrUa7TO-1606142299958)(img/C++%EF%BC%9A%E7%BB%A7%E6%89%BF.img/image-20201121180510522.png)]"><br>派生类的对象的地址(st)赋给其基类的指针变量§时，p只能识别派生类隐藏的父对象那一部分(value)，p不能识别num那一部分，因为p的类型是Person类型，它只能识别Person类型那么多的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *p = &amp;st;<span class="comment">//派生类的对象的地址赋给其基类的指针变量</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：线程-1-——线程、线程库、线程同步</title>
      <link href="/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-1-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%BA%93%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-1-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%BA%93%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程的概念">1. 线程的概念</h2><hr><h3 id="1-1-基本概念">1.1 基本概念</h3><p>线程是进程内部的一条执行序列（执行流），线程不能单独存在，它是进程里面的一部分，一个进程至少有一条线程，该条线程称之为主线程（main方法代表的执行序列）</p><p>对于Linux系统而言，线程就是一个轻量级的进程</p><p>执行序列：一组有序指令的集合</p><p>函数线程：可以通过线程库创建其他的线程（给线程指定一个它要执行的函数），将创建的线程称之为函数线程</p><p>单线程与多线程示意图如下：（蓝色的框代表进程，竖线代表该进程里的线程）   <img src="https://img-blog.csdnimg.cn/20201120103459428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="1-2-线程的实现方式">1.2 线程的实现方式</h3><p>在操作系统中，线程的实现有以下三种方式：</p><p><strong>内核级线程</strong>：线程的实现（线程的创建、调度、销毁）由操作系统内核来完成</p><p>优点：用户程序比较简单，内核复杂一些，所有的工作都交给内核来完成</p><p>缺点：只要涉及到线程的切换，就要从用户空间进入到内核空间，增大了时间的开销</p><p><strong>用户级线程</strong>：操作系统内核并不支持多线程，线程的实现都是在用户态，即用户态里是多线程，但在内核态是单线程，如下图左1</p><p>优点：操作系统内核简单一些</p><p>缺点：用户程序比较复杂，程序员要自己控制线程的切换；如果用户态一条线程发生阻塞，操作系统会认为整个进程都阻塞</p><p><strong>组合(混合)级线程</strong>：结合以上两种方式来实现，即一部分在内核态实现，一部分在用户态实现，如下图最右：<br><img src="https://img-blog.csdnimg.cn/20201120104155897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="1-3-Linux系统实现多线程的方式">1.3 Linux系统实现多线程的方式</h3><p>Linux 实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。Linux 把所有的线程都当做进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表示线程。相反，线程仅仅被视为一个与其他进程共享某些资源进程。每个线程都拥有唯一隶属于自己的task_struct（PCB），所以<font color='blue'>在内核中，它看起来就像是一个普通的进程（只是线程和其他一些进程共享某些资源，如地址空间）</font></p><h3 id="1-4-线程和进程的区别">1.4 线程和进程的区别</h3><p>① 进程是系统资源分配的最小单位，线程是CPU调度的最小单位</p><p>② 进程的切换开销大，线程的切换开销较小，线程间的切换效率相比于进程间的要高</p><p>③ 进程的创建消耗资源大，线程的创建相对较小，所以创建线程的效率相对高一些</p><p>④ 进程都是相互独立的，而一个进程内的线程共享很多资源（如地址空间）</p><p>⑤ 因为进程间是相互独立的，所以进程间的通信需要一些特殊的技术(管道，信号量，共享内存，消息队列)，而对于一个进程中的线程之间来说，由于共享了很多资源，线程间的通信就比较简单（线程就要考虑安全问题）</p><h2 id="2-线程库的使用">2. 线程库的使用</h2><hr><h3 id="2-0-头文件">2.0 头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-1-创建线程">2.1 创建线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *id, <span class="keyword">pthread_attr_t</span>, *attr, <span class="keyword">void</span>*(*fun)(<span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span></span></span><br></pre></td></tr></table></figure><p>id：传递一个pthread_t类型的变量的地址，用来获取创建成功后创建的线程的id（TID）</p><p>attr：传递线程的属性，默认使用NULL</p><p>fun：线程函数的地址</p><p>arg：传递给线程函数fun的参数</p><p>返回值：成功返回0，失败返回错误码</p><p>创建线程示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun</span><span class="params">(<span class="keyword">void</span> *)</span></span>;<span class="comment">//声明一个线程函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main start\n"</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> id;<span class="comment">//用来保存创建的线程的id值</span></span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);<span class="comment">//创建函数线程并且指定函数线程要执行的函数fun</span></span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main running\n"</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main over\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">//定义线程函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun start\n"</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun running\n"</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun over\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，编译的时候要链接线程库<code>-lpthread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;gcc -o pthread pthread.c -lpthread</span><br></pre></td></tr></table></figure><p>如果gcc编译代码时报&quot;undefined reference to …&quot;错误，是因为程序中调用了一些方法，但是没有链接该方法所在的库文件</p></blockquote><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/2020112013043025.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>根据执行结果可以得出：</p><ul><li>创建线程并执行线程函数，和调用函数是完全不同的概念，并不是fun执行完毕main才接着执行，main与fun穿插着执行</li><li>主线程与函数线程是并发执行的</li><li>创建函数线程后，哪个线程先被执行是由操作系统的调度算法和机器环境决定的</li></ul><h3 id="2-2-给线程函数传参">2.2 给线程函数传参</h3><p>值传递：将变量的值直接强转成void*类型进行传递，示例如下：<br><img src="https://img-blog.csdnimg.cn/20201120162601467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意：因为线程函数接收的是一个void*类型的指针，只要是指针，32位系统上都是4个字节。值传递就只能传递小于等于4字节的值</p><p>地址传递：将变量（所有类型的变量）的地址强转成void*类型进行传递，就和在普通函数调用之间传递变量的地址类似。主线程和函数线程通过这个地址就可以共享地址所指向的空间，示例如下：<br><img src="https://img-blog.csdnimg.cn/20201120163846679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201120163923693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一个进程内的所有线程共享这个进程的物理地址空间</p><h3 id="2-3-多线程下进程的4G虚拟地址空间">2.3 多线程下进程的4G虚拟地址空间</h3><p><img src="https://img-blog.csdnimg.cn/20201120164707642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><font color='blue'>一个进程内的所有线程对于全局数据、静态数据、堆区空间都是共享的</font></p><p>所以线程之间传递数据很简单，但是随之带来的问题就是线程并发运行时无法保证线程安全</p><p>共享数据代码验证如下：<br><img src="https://img-blog.csdnimg.cn/20201120171212397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201120170701614.png#pic_center" alt="在这里插入图片描述"><br>在函数线程里面对数据修改会影响到主线程</p><h3 id="2-4-线程库的其他方法">2.4 线程库的其他方法</h3><p><strong>结束线程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结束线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *result)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_exit使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun</span><span class="params">(<span class="keyword">void</span> *)</span></span>;<span class="comment">//声明一个线程函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main start\n"</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> id;<span class="comment">//用来保存创建的线程的id值</span></span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);<span class="comment">//创建函数线程并且指定函数线程要执行的函数fun</span></span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main running\n"</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main over\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">//定义线程函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun start\n"</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun running\n"</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun over\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中主线程for循环3次，函数线程for循环5次，则会导致主线程执行完毕直接结束掉整个进程，而函数线程还没有执行完毕，运行结果如下图：（fun本来要打印5次）主线程结束时用的是exit方法，exit会直接结束掉进程<br><img src="https://img-blog.csdnimg.cn/20201120172406695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>要想让主线程退出，但是其他线程继续运行，就要用pthread_exit方法来结束主线程<br><img src="https://img-blog.csdnimg.cn/20201120173337782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201120173301865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>main执行结束后，函数线程仍在继续执行</p><p><strong>等待一个线程的结束</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> id, <span class="keyword">void</span> **result)</span></span>;</span><br><span class="line"><span class="comment">//result用来获取等待的线程通过pthread_exit结束时设置的退出数据</span></span><br></pre></td></tr></table></figure><p>一个线程只要知道另一个线程的id，就可以通过join方法来等待该线程的结束，join方法示例如下：<br><img src="https://img-blog.csdnimg.cn/20201120174325872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201120174528689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>由运行结果可以看出：调用join方法的主线程会被阻塞，直到指定的fun函数线程结束</p><h2 id="3-线程同步">3. 线程同步</h2><hr><p>线程同步和进程同步一样，同步就是线程或者进程需要协同执行。（直接或者间接制约）</p><h3 id="3-1-互斥锁">3.1 互斥锁</h3><p>互斥锁只有两种状态，解锁状态和加锁状态，如果一个线程对已经处于加锁状态的互斥锁进行加锁操作，则加锁操作会阻塞，直到正在对互斥锁加锁状态线程进行解锁操作</p><p><strong>互斥锁的接口</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span>  mutex;<span class="comment">//创建一个互斥锁mutex，pthread_mutex_t是互斥锁的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的初始化, 互斥锁使用前要进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(pthread_mutex *mutex, <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(pthread_mutex *mutex)</span></span>;<span class="comment">//尝试加锁，不会阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destriy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：模拟两个线程竞争一个打印机，A线程使用打印机输出一个a，使用完成后输出一个a，这样我们的输出结果必须是成对出现</p><p>两个线程要操作同一个互斥锁：把互斥锁定义在全局中就可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mutex.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//定义互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFun</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">//函数线程，B线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);<span class="comment">//加锁</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"B"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> n = rand()%<span class="number">3</span>;</span><br><span class="line">sleep(n);<span class="comment">//模拟打印机正在执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"B"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);<span class="comment">//打印机执行完毕</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">n = rand()%<span class="number">3</span>;</span><br><span class="line">sleep(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadMain</span><span class="params">()</span> <span class="comment">//主线程里执行的函数，主线程模拟A线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);<span class="comment">//加锁</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"A"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> n = rand()%<span class="number">3</span>;</span><br><span class="line">sleep(n);<span class="comment">//模拟打印机正在执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"A"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);<span class="comment">//打印机执行完毕</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">n = rand()%<span class="number">3</span>;</span><br><span class="line">sleep(n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);<span class="comment">//互斥锁使用之前必须初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line"><span class="keyword">int</span> res = pthread_create(&amp;id, <span class="literal">NULL</span>, threadFun, <span class="literal">NULL</span>);<span class="comment">//创建函数线程</span></span><br><span class="line">assert(res == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">threadMain();</span><br><span class="line">pthread_join(id,<span class="literal">NULL</span>);<span class="comment">//等待函数线程结束</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);<span class="comment">//销毁互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20201123114719419.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-2-信号量">3.2 信号量</h3><p>线程级信号量和进程级信号量原理是相同的，使用接口不同。信号量是特殊的计数器，当值大于0时，记录临界资源个数，值等于0时，表示没有临界资源可用，这时对信号量执行P操作，则线程会被阻塞</p><p><strong>信号量接口</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> sem;<span class="comment">//sem_t是线程级信号量的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化信号量并且给定初值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> shared, <span class="keyword">int</span> val)</span></span>;<span class="comment">//shared代表是否在进程间共享，0表示不共享</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量执行P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量执行V操作, 注意P操作是wait，V操作是post</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure><p>信号量和互斥锁区别：（接口很像）</p><ul><li>互斥锁只有两种状态，而信号量的值可以大于1</li><li>在一个线程中对互斥锁的加锁和解锁必须成对出现，而信号量PV操作可以在线程间交叉使用（整体是成对的）</li></ul><h3 id="3-3-读写锁">3.3 读写锁</h3><p>读写锁在互斥锁的基础上，允许一个更高的并行性。读写锁一共有三种状态：解锁状态，读加锁状态，写加锁状态</p><ul><li>解锁状态：任何线程任何方式都可以加锁成功</li><li>读加锁状态：一个线程对锁执行读加锁，则可以成功返回；但是一个线程如果执行写加锁，则会被阻塞，直到所有读加锁的线程都执行了解锁操作，即所有读操作结束，才可写</li><li>写加锁状态：一个线程只要处于写加锁状态，所有的加锁操作都会被阻塞</li></ul><p><strong>读写锁的接口</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span>  rwlock;<span class="comment">//pthread_rwlock_t是读写锁的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化读写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock, <span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>扩充：<br>自旋锁(Spin Locks)：和互斥锁类似，只是当加锁操作被阻塞，阻塞的方式不同：互斥锁是通过将线程睡眠，而自旋锁则是通过忙等待的方式。自旋锁一般的适用场景是：锁被其他线程短期持有（很快会被释放），而且等待该锁的线程不希望在阻塞期间被取消调度（被取消调度会带来一些开销），这时使用自旋锁，避免了等待该锁的线程被睡眠，避免了调度切换的开销</p><p>自旋锁通常被用作实现其他类型的锁的低级原语。当一个线程在自旋等待一个锁的时候，CPU不能做其他任何事了，这就浪费了CPU的资源。这就是为什么要求自旋锁只能被短期保持的原因<br>参考博客：<a href="https://www.cnblogs.com/nufangrensheng/p/3521654.html" target="_blank" rel="noopener">https://www.cnblogs.com/nufangrensheng/p/3521654.html</a></p></blockquote><blockquote><p>悲观锁：任何情况下都去加锁，（悲观地认为只要不加锁就会出问题），执行效率就低了<br>乐观锁：不加锁，（乐观地认为不加锁也没问题），只是监视一下</p></blockquote><h3 id="3-4-条件变量">3.4 条件变量</h3><p>条件变量的作用是用于多线程之间关于共享数据状态变化的通信。当一个动作需要另外一个动作完成时才能进行，即：当一个线程的行为依赖于另外一个线程对共享数据状态的改变时，这时候就可以使用条件变量。</p><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。它给多个线程提供了一个会和的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生</p><p><strong>条件变量的接口</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;<span class="comment">//pthread_cond_t是条件变量的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待条件的发生</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;<span class="comment">//与互斥锁一起使用，传递的是加锁状态的锁(内核中会对mutex解锁，内核退出时又会对mutex加锁), 使用mutex目的是：以允许线程以无竞争的方式等待特定的条件发生</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒所有等待的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//互斥锁</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag = (<span class="keyword">int</span>)arg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_cond_wait(&amp;cond,&amp;mutex);<span class="comment">//mutex是一个互斥锁，以互斥方式将当前线程添加到等待条件变量的队列中</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff, <span class="string">"end"</span>, <span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun%d: %s\n"</span>,flag, buff);</span><br><span class="line"><span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="number">128</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fun end!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> id1,id2;</span><br><span class="line">pthread_create(&amp;id1, <span class="literal">NULL</span>, fun, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">pthread_create(&amp;id2, <span class="literal">NULL</span>, fun, (<span class="keyword">void</span>*)<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input: "</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">fgets(buff, <span class="number">127</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff,<span class="string">"end"</span>,<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_cond_broadcast(&amp;cond);<span class="comment">//唤醒全部线程</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//输入的不是end</span></span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_cond_signal(&amp;cond);<span class="comment">//唤醒一个线程</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_join(id1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(id2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20201123183910754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>刚开始两个函数线程都在等待队列中，当用户输入数据时，主线程进入if else去唤醒函数线程，函数线程才执行。最后输入end，执行的是pthread_cond_broadcast，唤醒全部线程，所以两个函数线程会都打印fun end!</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：进程间通信——共享内存、消息队列</title>
      <link href="/2021/02/03/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2021/02/03/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="共享内存">共享内存</h2><hr><h3 id="共享内存-2">共享内存</h3><p>Linux上进程的地址空间都是相互独立的，每个进程有3G的属于自己的虚拟地址空间，操作系统为每一个进程维护一个页表，进程所映射的物理空间都是不同的。而共享内存就是为了打破这一点，共享内存通过内核对象使得不同的进程在自己的虚拟地址空间上分配一块空间映射到相同的物理内存空间上。这块物理空间对于映射到上面的每个进程而言都是可以访问的 ，这就达到了内存共享的目的。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20201116184030106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>共享内存为了实现不同进程之间的互斥访问，需要手动用信号量和PV操作来控制</p><h3 id="操作接口">操作接口</h3><p><strong>0、头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>1、获取或者创建内核对象，并且指定共享内存的大小（系统分配物理空间时，按照页进行分配）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> flag)</span></span>; <span class="comment">//创建内核对象并申请物理空间 shm: shared memory共享内存</span></span><br></pre></td></tr></table></figure><p>key：标识，两个进程要使用相同的共享内存，key要相同</p><p>size：创建共享内存时，指定共享内存的大小</p><p>flag：可选，指定操作权限，IPC_CREAT，IPC_EXCEL</p><p>返回值：返回共享内存id</p><p>执行完第一步只是把空间申请了出来，还没有把虚拟地址空间映射到这块内存上，要接着执行以下第二步</p><p><strong>2、将虚拟地址空间映射到共享内存的物理空间</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span>* shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>shmid：由shmget返回的共享内存id</p><p>shmaddr：一般给NULL，由系统自动选择映射的虚拟地址空间</p><p>shmflg：一般给0，可以给SHM_RDONLY为只读模式，其他的为读写</p><p>返回值：成功返回共享内存的首地址，出错返回-1，注意出错返回的是-1不是NULL</p><p><strong>3、断开当前进程进程虚拟地址空间与共享内存的物理空间的映射</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>shmaddr：断开当前进程的shmaddr 指向的共享内存映射</p><p>返回值：成功返回 0， 失败返回-1</p><p><strong>4、操作共享内存</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;<span class="comment">//第三个参数必须有</span></span><br></pre></td></tr></table></figure><p>shmid：shmget返回的共享内存ID号</p><p>cmd：删除：IPC_RMID， 设置：IPC_SET，cmd其他参数如下：</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20201116175624484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（摘自《UNIX环境高级编程》）</p><p>注意：使用IPC_RMID删除共享内存时，因为有连接计数器，除非最后一个进程与该共享段断开连接，则删除该共享存储段，否则，并不会真正删除该共享段，但是该段标识符（内核对象）会被立即删除，不能再使用shmat方法与该段建立映射</p><p>以上说明了：一个进程调用该方法删除共享存储，不会影响之前已经和该共享存储段建立映射关系的进程</p></blockquote><p>buf：内核为每一个共享存储段设置了一个shmid_ds结构，如下：<br><img src="https://img-blog.csdnimg.cn/20201116181124539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>返回值：成功返回0，失败返回-1</p><h3 id="共享内存的特点">共享内存的特点</h3><p>共享内存通信是最快的IPC。在通信过程中相比于管道少了两次数据的拷贝：写入时不用从缓冲buf中写入，读取时不用从内存中读取到缓冲buf中</p><h3 id="查看与删除共享内存的命令">查看与删除共享内存的命令</h3><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -m</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m shmid</span><br></pre></td></tr></table></figure><p>关于ipcs/ipcrm命令的更多介绍请查看上一篇博客末尾：<a href="https://blog.csdn.net/huifaguangdemao/article/details/109675406" target="_blank" rel="noopener">Linux：进程间通信——管道、信号量</a></p><h3 id="例：通过共享内存通信">例：通过共享内存通信</h3><p>题目：A进程执行写，然后B进程读并且转换成大写输出，且对该块内存的读写不能同时进行<br><img src="https://img-blog.csdnimg.cn/20201116184453398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>A进程.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem.h"</span>  <span class="comment">//上一篇博客封装好的信号量操作方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="keyword">int</span> shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">128</span>, <span class="number">0664</span> | IPC_CREAT);</span><br><span class="line">assert(shmid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//映射虚拟地址与共享内存</span></span><br><span class="line"><span class="keyword">char</span> *ptr = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">assert(ptr != (<span class="keyword">char</span>*)<span class="number">-1</span> );<span class="comment">//shmar出错返回的是-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建信号量</span></span><br><span class="line"><span class="keyword">int</span> initVal[] = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> semid = SemGet(<span class="number">1234</span>, initVal, <span class="number">2</span>);</span><br><span class="line">assert(semid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//A进程写</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SemP(semid, <span class="number">0</span>);<span class="comment">//写信号量在initVal里下标是0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input: "</span>);</span><br><span class="line">fgets(ptr, <span class="number">127</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">SemV(semid,<span class="number">1</span>); <span class="comment">//唤醒读操作，读信号量在initVal里下标是1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(ptr,<span class="string">"end"</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开连接</span></span><br><span class="line">shmdt(ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B进程.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem.h"</span>  <span class="comment">//上一篇博客封装好的信号量操作方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取共享内存</span></span><br><span class="line"><span class="keyword">int</span> shmid = shmget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">128</span>, <span class="number">0664</span> | IPC_CREAT);</span><br><span class="line">assert(shmid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//映射虚拟地址与共享内存</span></span><br><span class="line"><span class="keyword">char</span> *ptr = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">assert(ptr != (<span class="keyword">char</span>*)<span class="number">-1</span> );<span class="comment">//shmar出错返回的是-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取信号量</span></span><br><span class="line"><span class="keyword">int</span> initVal[] = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> semid = SemGet(<span class="number">1234</span>, initVal, <span class="number">2</span>);</span><br><span class="line">assert(semid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//B进程读</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SemP(semid, <span class="number">1</span>);<span class="comment">//阻塞读操作，读信号量在initVal里下标是1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(ptr,<span class="string">"end"</span>,<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;<span class="built_in">strlen</span>(ptr)<span class="number">-1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,<span class="built_in">toupper</span>(ptr[i]));</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">SemV(semid,<span class="number">0</span>);<span class="comment">//唤醒写操作，写信号量在initVal里下标是0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开连接</span></span><br><span class="line">shmdt(ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20201116195054596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意：进程执行完毕记得使用ipcs/ipcrm命令删除信号量内核对象和共享内存内核对象</p><h2 id="消息队列">消息队列</h2><hr><h3 id="消息队列-2">消息队列</h3><p>管道和共享内存传输的是流数据（字节流形式），传输的数据是不可分割的整体；</p><p>消息则是一段一段的，数据报形式（类型+数据）</p><p>队列：先进先出，消息队列类似优先级队列，消息队列里的是类型+数据，可以指定类型来读取，在相同类型下，按照先进先出的顺序，消息队列在内核空间<br><img src="https://img-blog.csdnimg.cn/20201116200909130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="操作接口-2">操作接口</h3><p><strong>0、头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>1、创建或者获取一个消息队列</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msqflg)</span></span>;</span><br></pre></td></tr></table></figure><p>key：用户标识，使用相同消息队列的进程key值要求一样</p><p>msqflg：IPC_CREAT</p><p>返回值：成功返回消息队列ID，失败返回-1</p><p><strong>2、发送消息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>*msqp, <span class="keyword">size_t</span> msqsz, <span class="keyword">int</span> msqflg)</span><span class="comment">//msq: message queue消息队列</span></span></span><br></pre></td></tr></table></figure><p>msqid：msgget返回的消息队列ID</p><p>msqp：struct msgbuf结构体指针</p><blockquote><p>struct msgbuf结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&gt;&#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype; <span class="comment">//消息类型，必须大于0</span></span><br><span class="line"><span class="keyword">char</span> mtext[SIZE]; <span class="comment">// 消息数据，SIZE为最长的消息数据的长度</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>msqsz：指定mtext中有效数据的长度</p><p>msqflg：一般设置为0，可以设置为IPC_NOWAIT非阻塞标志</p><p>返回值：成功返回0，失败返回-1</p><p><strong>3、接收消息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msqp, <span class="keyword">size_t</span> msqsz, <span class="keyword">long</span> msqtyp, <span class="keyword">int</span> msqflg)</span></span>;</span><br></pre></td></tr></table></figure><p>msqid：消息队列ID值</p><p>msqp：msgbuf结构体指针</p><p>msqsz：接收数据的大小</p><p>msqtyp：指定接收到的数据类型，类型可以为0</p><p>msqflg：一般设置为0，可以设置为IPC_NOWAIT</p><p>返回值：成功返回消息的数据部分(mtext)的长度，失败返回-1</p><p>msgcv成功执行时，内核更新与该消息队列相关联的msqid_ds结构，并将队列中的消息数减一</p><p><strong>4、控制消息队列</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds*buf)</span></span>;</span><br></pre></td></tr></table></figure><p>msqid：</p><p>cmd：删除：IPC_RMID，cmd其他参数如下<br><img src="https://img-blog.csdnimg.cn/20201116204132306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>buf：每一个消息队列都有一个msqid_ds结构体与其相关联，msqid_ds结构体如下：<br><img src="https://img-blog.csdnimg.cn/20201116204341480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>返回值：成功返回0，失败返回-1</p><h3 id="例：通过消息队列通信">例：通过消息队列通信</h3><p>题目：a进程发送消息，b进程从消息队列中接收消息并输出</p><p>发送的消息的数据报结构体：msgbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">128</span>];</span><br><span class="line">&#125;MsgBuf;</span><br></pre></td></tr></table></figure><p>msqa.c发送消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msgbuf.h"</span><span class="comment">//数据报结构体</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><span class="comment">//argc[1]放类型，argv[2]里放数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please  input type and data\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据报中填充数据</span></span><br><span class="line">MsgBuf mess;</span><br><span class="line"><span class="built_in">memset</span>(&amp;mess, <span class="number">0</span> , <span class="keyword">sizeof</span>(mess));</span><br><span class="line"><span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">"%d"</span>, &amp;mess.mtype);<span class="comment">//设置数据</span></span><br><span class="line"><span class="built_in">strcpy</span>(mess.mtext, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建消息队列</span></span><br><span class="line"><span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">assert(msgid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">msgsnd(msgid, &amp;mess, <span class="built_in">strlen</span>(mess.mtext), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>msqb.c接收消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msgbuf.h"</span><span class="comment">//数据报结构体</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><span class="comment">//根据类型来获取信息，argv[1]放类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input type\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建接收消息的缓冲区</span></span><br><span class="line">MsgBuf mess;</span><br><span class="line"><span class="built_in">memset</span>(&amp;mess, <span class="number">0</span>, <span class="keyword">sizeof</span>(mess));</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据类型接收消息队列中的消息</span></span><br><span class="line"><span class="keyword">long</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">"%d"</span>, &amp;type);</span><br><span class="line"><span class="keyword">int</span> msgid = msgget((<span class="keyword">key_t</span>)<span class="number">1234</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">assert(msgid != <span class="number">-1</span>);</span><br><span class="line">msgrcv(msgid, &amp;mess, <span class="number">127</span>, type, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"type: %d, data: %s\n"</span>, mess.mtype, mess.mtext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：按顺序依次发送消息（类型+数据），接收时按类型优先级依次读取（先进先出）<br><img src="https://img-blog.csdnimg.cn/20201116222304459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>测试：msgrcv成功执行时，内核更新与该消息队列相关联的msqid_ds结构，并将队列中的消息数减一<br><img src="https://img-blog.csdnimg.cn/20201116223217681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：进程间通信——管道、信号量</title>
      <link href="/2021/02/03/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E7%AE%A1%E9%81%93%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2021/02/03/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E7%AE%A1%E9%81%93%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="IPC">IPC</h2><hr><p>进程间通信：IPC(InterProcessCommunication)，并发的进程同时处理多个业务模块。多个业务模块的执行可能需要相互传递数据，也可能需要同步控制，因而进程间需要进行通信。</p><p>操作系统为每一个进程维护独立的虚拟地址空间，即进程的4G虚拟地址空间，而两个实体需要交互通信，必须能够有可以共享的资源，对于不同的进程来说，磁盘上的文件是共享的，系统的内核空间是共享的，基于这两个共享的资源，就有如下几种进程间通信的方式：<br><img src="https://img-blog.csdnimg.cn/20201113161825825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020111315145774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>对于点对点之间的通信，按照消息传送的方向与时间关系，通信方式可分为单工通信、半双工通信及全双工通信三种</p><ol><li>单工通信：消息只能单方向传输，例：广播</li><li>半双工通信：可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行，例：对讲机</li><li>全双工通信：允许数据同时在两个方向上传输，例：电话</li></ol></blockquote><h2 id="管道">管道</h2><hr><p>管道可以用来在两个进程之间传递数据，如： <code>ps -ef | grep &quot;bash&quot;</code>, 其中‘|’就是管道，其作用就是将 ps 命令的结果写入管道文件，然后 grep 再从管道文件中读出该数据进行过滤，管道通信属于半双工通信</p><h3 id="命名管道">命名管道</h3><p>命名管道即有名管道，同一台主机上，同一个系统有权限操作管道文件的任意进程都可以通过其完成进程间通讯。</p><p>注意：命名管道文件存储在磁盘上，但管道传递的数据是在内存中存储的，通过文件描述符指向的是一块内存空间，如下图，磁盘上并没有数据，所以管道文件属性信息里大小始终为0<br><img src="https://img-blog.csdnimg.cn/20201113161902489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>创建管道文件</strong>：</p><p>1.命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo name</span><br></pre></td></tr></table></figure><p>2.系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>管道文件的操作</strong></p><p>管道文件也是文件，它同Linux其他文件的操作方式一样：<a href="https://blog.csdn.net/huifaguangdemao/article/details/109268126" target="_blank" rel="noopener">Linux：文件操作的系统调用</a></p><p>1.打开文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag, <span class="comment">/*int mode*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2.读取文件内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>3.向文件中写入内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>4.关闭文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="无名管道">无名管道</h3><p>无名管道只能应用在有关系的两个进程之间，例如fork的父子进程之间，它通过共享fork之前的文件描述符来实现进程之间的通信</p><p><strong>无名管道的创建及打开</strong><br>注意：无名管道创建的时候就要打开，因为它没名字，创建时不打开后期就找不到了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];<span class="comment">//fds[0]读端，fds[1]写端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fds[<span class="number">2</span>])</span></span>;<span class="comment">//形参是有两个整型值的数组，2只是给用户一个提示：只需要两个整型值，2并没有实际意义，因为C编译时直接按指针来处理</span></span><br></pre></td></tr></table></figure><p><code>pipe(fds[2])</code>成功返回 0，失败返回-1，</p><p><code>fds[0]</code>是管道读端的描述符</p><p><code>fds[1]</code>是管道写端的描述符</p><p><strong>无名管道例题</strong></p><p>题目：A进程接收用户输入的数据，B进程将用户输入的字符全部转换为大写并输出</p><p>分析：fork之前创建无名管道，父进程接收用户输入的数据，子进程处理字符并输出</p><p>注意：因为管道属于半双工通信，信息不能同时双向传递，所以使用无名管道时要先关闭一对读写，只留一对读端和写端，且必须有读有写才有意义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A进程接收用户输入的数据，B进程将用户输入的字符串全部转换为大写并输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Toupper</span><span class="params">(<span class="keyword">char</span> buff[])</span><span class="comment">//小写转大写</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(buff))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isalpha</span>(buff[i]))</span><br><span class="line">&#123;</span><br><span class="line">buff[i] = <span class="built_in">toupper</span>(buff[i]);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];<span class="comment">//0读端，1写端</span></span><br><span class="line">pipe(fds);<span class="comment">//创建无名管道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line">assert(pid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程将用户输入的字符串全部转换为大写并输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">close</span>(fds[<span class="number">1</span>]);<span class="comment">//关闭写端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">read</span>(fds[<span class="number">0</span>],buff,<span class="number">127</span>);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Toupper(buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>,buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//父进程接收用户输入的数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">close</span>(fds[<span class="number">0</span>]);<span class="comment">//关闭读端</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please enter the string:\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buff,<span class="number">127</span>,<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff,<span class="string">"end"</span>,<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">write</span>(fds[<span class="number">1</span>],buff,<span class="built_in">strlen</span>(buff)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量">信号量</h2><hr><h3 id="基本概念">基本概念</h3><p><strong>信号量</strong></p><p>是一个特殊的计数器，来完成多进程环境下的进程执行的同步控制，信号量是在内核空间的，操作系统为每个进程提供4G的虚拟地址空间，其中3G是相互独立的用户空间，1G是内核空间。代码中的任何变量都是在3G的用户空间中，而进程的1G内核空间是所有进程共用的，如下图所示<br><img src="https://img-blog.csdnimg.cn/20201113165210985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>信号量是一个值，当信号量的值&gt;0时，记录的是临界资源的个数，此时对信号量执行P操作不会阻塞，当信号量的值为0时，执行P操作，会阻塞，直到另一个进程对该信号量执行V操作</p><p><strong>临界资源</strong></p><p>同一时刻只能被一个进程/线程访问使用的资源，如打印机</p><p><strong>临界区</strong></p><p>程序中访问临界资源的代码块</p><p><strong>原子操作</strong></p><p>不能被中断的操作就是原子操作</p><p><strong>P、V操作</strong></p><p>PV操作都是原语，是实现进程同步和互斥的常用方法</p><p>p操作定义：申请一个资源，s:=s-1，若s&lt;0,则设置该进程为阻塞状态，并将其插入阻塞队列；若s&gt;=0,则执行p操作的进程继续执行</p><p>v操作定义：释放一个资源，s:=s-1,若s&lt;=0,则从阻塞状态唤醒另一个进程，并将其插入就绪队列，执行v操作的进程继续执行；若s&gt;0,则执行v操作的进程继续执行<br><img src="https://img-blog.csdnimg.cn/20201113171327360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="进程需要同步执行的场景">进程需要同步执行的场景</h3><p>1、间接制约关系：多个进程竞争使用同一个资源</p><p>2、直接制约关系：一个进程为另一个进程提供服务</p><h3 id="信号量的操作接口">信号量的操作接口</h3><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>创建或者获取信号量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> flag)</span></span>;<span class="comment">//创建或者获取的是一个信号量集合（数组）</span></span><br></pre></td></tr></table></figure><p>如果是第一次访问（无论哪个进程），则需要创建；如果不是第一次访问，则直接获取</p><p>key：是一个用户标识，如果多个进程使用同一个信号量集，要求在调用semget方法时的key值相同</p><p>nsems：在创建时使用，用来执行创建的信号量集中的信号量个数</p><p>flag：可选，指定操作权限，可以设置IPC_CREAT，来指明本次需要创建信号量集</p><p>返回值：成功返回内核信号量的ID值，用于后续其他方法；失败返回-1，信号量ID事实上是信号量集合的ID，一个ID对应的是一组信号量</p><p><strong>信号量的PV操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sempop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *buf, <span class="keyword">int</span> buflength)</span></span>;</span><br></pre></td></tr></table></figure><p>semid：semget返回的信号量ID</p><p>buf：sembuf类型的数组的首地址</p><p>buflength：buf数组的元素个数</p><p>返回值：成功返回0，失败返回-1</p><p>其中sembuf结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> short sem_num; <span class="comment">//指定信号量集中的信号量下标</span></span><br><span class="line">short          sem_op;  <span class="comment">//其值为-1代表P操作，1代表V操作</span></span><br><span class="line">short          sem_flg; <span class="comment">//通常为SEM_UNDO,使操作系统跟踪信号，并在进程没有释放该信号量而终止时，操作系统释放信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>设置信号量信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd,...<span class="comment">/* union semun arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>semid：semget返回的信号量ID</p><p>semnum：指定信号量集中的信号量下标</p><p>cmd：SETVAL用来把信号量初始化为一个已知的值，设置的是成员semnum的semval值，该值由第四个参数联合体的arg.val指定；IPCRMID用于删除一个已经无需继续使用的信号量标识符，这种删除是立即发生的，仍在使用此信号量集合的其他进程在它们下次试图对此信号量集合进行操作时，将出错返回</p><p>第四个参数<code>union semun</code>结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>              val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *_<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="信号量接口的封装">信号量接口的封装</h3><p>0、头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>1、获取一个信号量集合</p><ul><li>创建，信号量的值进行初始化 (指定创建信号量的个数及信号量的初始值)</li><li>获取，直接返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> SemUn  <span class="comment">//semctl的第四个参数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;SemUn;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建nsems个信号量存在initVal数组中，用户标识为key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SemGet</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> initVal[], <span class="keyword">int</span> nsems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//先获取，获取失败就创建</span></span><br><span class="line"><span class="keyword">int</span> semid = semget((<span class="keyword">key_t</span>)key, <span class="number">0</span>, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(semid == <span class="number">-1</span>)<span class="comment">//获取失败说明没有，就创建</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建信号量集合</span></span><br><span class="line">semid = semget((<span class="keyword">key_t</span>)key, nsems, <span class="number">0664</span> | IPC_CREAT);</span><br><span class="line"><span class="keyword">if</span>(semid == <span class="number">-1</span>)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对信号量集合中的所有信号量进行初始化</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i&lt; nsems; ++i)</span><br><span class="line">&#123;</span><br><span class="line">SemUn arg;</span><br><span class="line">arg.val = initVal[i];</span><br><span class="line">semctl(semid, i, SETVAL, arg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> semid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、对信号量集合中的信号量执行P操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对semid信号量集合中下标为index的信号量执行P操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SemP</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">buf.sem_num = index;</span><br><span class="line">buf.sem_op = <span class="number">-1</span>;  <span class="comment">//值为-1代表P操作</span></span><br><span class="line">buf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、对信号量集合中的信号量执行V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对semid信号量集合中下标为index的信号量执行V操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SemV</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">buf.sem_num = index;</span><br><span class="line">buf.sem_op = <span class="number">1</span>; <span class="comment">//值为1代表V操作</span></span><br><span class="line">buf.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、删除信号量集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除semid信号量集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SemDel</span><span class="params">(<span class="keyword">int</span> semid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> semctl(semid, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上把系统提供的接口封装成使用起来更方便的方法，接下来的例题便是基于这些自己封装的方法的</p><h3 id="例：模拟访问打印机">例：模拟访问打印机</h3><p>题目：进程 a 和进程 b 模拟访问打印机，进程 a 输出第一个字符‘a’表示开始使用打印机，输出第二个字符‘a’表示结束使用， b 进程操作与 a 进程相同。（由于打印机同一时刻只能被一个进程使用，所以输出结果不应该出现 abab），如图所示：<br><img src="https://img-blog.csdnimg.cn/20201114113654453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码如下：</p><p>进程a：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem.h"</span>     <span class="comment">//上面封装好的方法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> initVal = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> semid = SemGet(<span class="number">1234</span>, &amp;initVal, <span class="number">1</span>);<span class="comment">//只需要1个信号量</span></span><br><span class="line">assert(semid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>(count--)</span><br><span class="line">&#123;</span><br><span class="line">SemP(semid,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);<span class="comment">//刷新输出缓冲区</span></span><br><span class="line"><span class="keyword">int</span> n = rand() % <span class="number">3</span>;<span class="comment">//模拟打印机正在使用</span></span><br><span class="line">sleep(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);<span class="comment">//刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line">SemV(semid,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">n = rand() % <span class="number">3</span>;<span class="comment">//模拟使用完打印机去干其他事</span></span><br><span class="line">sleep(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程b：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sem.h"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> initVal = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> semid = SemGet(<span class="number">1234</span>, &amp;initVal, <span class="number">1</span>);<span class="comment">//两个进程要使用同一个信号量key值1234要一样</span></span><br><span class="line">assert(semid != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>(count--)</span><br><span class="line">&#123;</span><br><span class="line">SemP(semid,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);<span class="comment">//刷新输出缓冲区</span></span><br><span class="line"><span class="keyword">int</span> n = rand() % <span class="number">3</span>;<span class="comment">//模拟打印机正在使用</span></span><br><span class="line">sleep(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b"</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);<span class="comment">//刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line">SemV(semid,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">n = rand() % <span class="number">3</span>;<span class="comment">//模拟使用完打印机去干其他事</span></span><br><span class="line">sleep(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20201114150331431.png#pic_center" alt="在这里插入图片描述"></p><h3 id="例：模拟进程间直接制约">例：模拟进程间直接制约</h3><p>题目：三个进程a, b, c分别输出’A’, ‘B’, ‘C’，要求输出结果必须是&quot;ABCABCABCABC…&quot;</p><p>上个例子打印机模拟间接制约关系，该例模拟进程间直接制约关系，A到B需要一个信号量，B到C需要一个，C到A还需要一个，abc进程代码如下图：</p><p><img src="https://img-blog.csdnimg.cn/20201115164834247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20201115165315740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意：进程结束之后，创建的信号量仍然在内核之中，需要使用<code>ipcs</code>和<code>ipcrm</code>命令来进行查看与手动删除</p><h3 id="ipcs-ipcrm">ipcs/ipcrm</h3><p>ipcs/ipcrm命令  是linux/uinx上提供关于一些进程间通信方式的信息，包括共享内存，消息队列，信号</p><p><code>ipcs</code> 可以查看消息队列、共享内存、信号量的使用情况，使用 <code>ipcrm </code>可以进行删除操作</p><p>ipcs选项如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ipcs -a  默认输出信息：打印出当前系统中所有的进程间通信方式的信息</span><br><span class="line">ipcs -m  查看使用共享内存进行进程间通信的信息</span><br><span class="line">ipcs -q  查看使用消息队列进行进程间通信的信息</span><br><span class="line">ipcs -s  查看使用信号进行进程间通信的信息</span><br></pre></td></tr></table></figure><p>ipcrm选项如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -M shmkey   删除用shmkey创建的共享内存段</span><br><span class="line">ipcrm -m shmid    删除用shmid标识的共享内存段</span><br><span class="line">ipcrm -Q msgkey   删除用msqkey创建的消息队列</span><br><span class="line">ipcrm -q msqid    删除用msqid标识的消息队列</span><br><span class="line">ipcrm -S semkey   删除用semkey创建的信号</span><br><span class="line">ipcrm -s semid    删除用semid标识的信号</span><br></pre></td></tr></table></figure><p>例：<br><img src="https://img-blog.csdnimg.cn/20201114150822471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：函数模板、类模板</title>
      <link href="/2021/02/03/C-%EF%BC%9A%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
      <url>/2021/02/03/C-%EF%BC%9A%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="函数模板的引入">函数模板的引入</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b? a : b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Max</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">char</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b? a : b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b? a : b; &#125;</span><br></pre></td></tr></table></figure><p>以上是C++里函数的重载，C语言不支持函数重载，C语言汇编的时候对于如上三个Max, 都会起名为_Max, 对于C语言就会发生命名冲突，所以C不可以函数重载；而对于C++，C++编译的时候会用名字粉碎技术，对如上三个Max函数名进行改写，</p><p><img src="https://img-blog.csdnimg.cn/20201108110335301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>虽然源码里三个函数都是Max但是编译器编译之后，三个函数名就不一样了</p><blockquote><p>注意：虽然经过名字粉碎技术，返回值也作了标记，但是返回值类型仍不能作为区分重载函数的依据，因为调用时编译器无法根据返回值类型识别具体调用的函数，例如对于如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123; <span class="keyword">return</span> a&gt;b? a : b;&#125; </span><br><span class="line">&gt;<span class="function"><span class="keyword">char</span> <span class="title">Max</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123; <span class="keyword">return</span> a&gt;b? a : b;&#125; </span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">Max(<span class="string">'x'</span>,<span class="string">'y'</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>在主函数中调用Max函数，由于两个Max形参列表都一样，所以主函数无法识别Max具体要调用哪一个，似乎两个都可以调动，这样就产生了二义性，所以这样的重载是错误的</p></blockquote><p>对于最开始给出的三个函数，我们发现这三个函数处理的过程都是一样的，只是处理类型不同而已，那能不能把类型与算法分离开呢，这就要用到函数模板</p><h2 id="函数模板">函数模板</h2><hr><p>函数模板的标准形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;  //<span class="title">template</span>与<span class="title">class</span>是关键字，<span class="title">class</span>也可以为<span class="title">Typename</span>，<span class="title">Type</span>是占位符，可简写为<span class="title">T</span></span></span><br><span class="line"><span class="class">返回类型 函数名(<span class="title">Type</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">Type</span> &amp; <span class="title">Max</span>(<span class="title">const</span> <span class="title">Type</span> &amp;<span class="title">a</span>, <span class="title">const</span> <span class="title">Type</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> a&gt;b? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = Max(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">char</span> ch = Max(<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">double</span> db = Max(<span class="number">12.23</span>, <span class="number">23.45</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在编译的时候，会根据调用的具体类型对函数模板进行推演到具体的模板函数，这个过程就是模板推演过程<br><img src="https://img-blog.csdnimg.cn/20201108130250639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果不需要编译器用实参和形参去推演，可以在调用的时候显示地给出类型的参数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = Max&lt;<span class="keyword">int</span>&gt;(<span class="number">12</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">char</span> ch = Max&lt;<span class="keyword">char</span>&gt;(<span class="string">'a'</span>,<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">double</span> db = Max&lt;<span class="keyword">double</span>&gt;(<span class="number">12.23</span>, <span class="number">23.45</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：模板的推演不能理解为宏替换，而是重命名typedef，宏替换和typedef是不一样的，例如对于如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> PINT  int*</span></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">int</span>* SINT</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">PINT x,y;</span><br><span class="line">SINT a,b;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>PINT宏替换，所以x是int*类型，y是int类型，因为指针是和变量名进行结合的；而SINT是取别名，则a和b都是int*类型<br>又如下函数模板代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">&gt;<span class="title">void</span> <span class="title">fun</span>(<span class="title">T</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class">&gt;&#123;</span></span><br><span class="line">T x,y;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(x).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(y).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">fun(p); </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>p是int*类型，所以x和y都是int*类型, 输出结果如下：<br><img src="https://img-blog.csdnimg.cn/20201109164202905.png#pic_center" alt="在这里插入图片描述"></p></blockquote><p>模板把功能代码段的“算法”和算法中“数据的数据类型”区分开来。这样编程者可以先写算法，而在定义算法时不确定实际计算数据的数据类型，然后在使用算法时再根据实际获得的数据类型来确定使用何种数据类型进行数值计算</p><h3 id="使用函数模板的注意事项：">使用函数模板的注意事项：</h3><ol><li>在定义模板形参表时，每一个数据类型参数的前面必须书写关键字class或typename，以下的定义格式是错误的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, T2&gt;<span class="comment">//错误，T2前也要加关键字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 a, T2 b)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li>调用模板函数时，&lt;模板实参表&gt;在大多数情况下可以缺省，但在某些情况下不可以：函数模板有多个虚拟类型参数，而在生成模板函数时函数实际参数不足以让编译器确认每一个虚拟类型参数，此时必须明确给出&lt;模板实参表&gt;，例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">fun</span>(<span class="title">T2</span> <span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line">b = fun&lt;<span class="keyword">float</span>,<span class="keyword">int</span>&gt;(a);<span class="comment">//T1是float，T2是int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>函数模板：函数模板的重点是模板。表示的是一个模板，专门用来生产函数。<br>模板函数：是函数模板的实例化，是一个函数。函数模板与模板函数是抽象与具体的关系</p></blockquote><h2 id="函数模板的重载">函数模板的重载</h2><hr><p>函数的重载就是函数名相同，参数个数或类型不同，函数模板的重载与一般函数的重载在概念和方法上是完全一样的，利用函数模板的参数列表的不同，可以为函数模板提供重载。例如如下multiply函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">multiply</span>(<span class="title">T</span> <span class="title">var1</span>, <span class="title">T</span> <span class="title">var2</span>) &#123;</span>.......&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">multiply</span>(<span class="title">T</span> <span class="title">var1</span>, <span class="title">int</span> <span class="title">var2</span>) &#123;</span>.......&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">multiply</span>(<span class="title">T</span> <span class="title">var1</span>, <span class="title">T</span> <span class="title">var2</span>, <span class="title">T</span> <span class="title">var3</span>) &#123;</span>.......&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面定义的三个函数模板，其函数名称，返回值的类型完全相同，只是函数参数类型或参数个数不同，这和普通函数的重载一样的，利用函数模板的重载不仅可以解决不同数据类型的参数问题，还可以解决参数个数不同的问题，使得函数模板的应用能力进一步增强</p><p><strong>注意</strong>：<br>1、函数返回值不能作为区分重载函数的依据<br>2、以下两个函数模板也不是重载的关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">multiply</span>(<span class="title">T1</span> <span class="title">var1</span>, <span class="title">T1</span> <span class="title">var2</span>) &#123;</span>.......&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T2</span> <span class="title">multiply</span>(<span class="title">T2</span> <span class="title">var1</span>, <span class="title">T2</span> <span class="title">var2</span>) &#123;</span>.......&#125;</span><br></pre></td></tr></table></figure><p>虚拟类型参数T1和T2所代表的实际数据类型只是在函数被真正调用时才由编译器确定，虚拟类型参数的名称本身没有任何实际意义，即参数名T1或者T2并没有任何差别，因此上面的两个函数模板其实是一模一样的函数模板。如果将上面的两个定义写在同一个程序段中，就会造成函数模板的重复定义，编译器会在编译的过程中发现这个错误并向用户报警。</p><h2 id="类模板">类模板</h2><hr><p>如同利用函数模板技术可以解决如何用一个函数定义处理不同数据类型的数据问题，利用类模板也可以解决如何让一个类定义能够处理不同数据类型的问题。</p><p>通过一个类模板，可以生成一系列数据类型不同的模板类，类模板与模板类的关系如同函数模板与函数模板的关系，都是抽象与具体的关系</p><p>对于类模板，在使用类模板去实例化形成模板类时，要显示地给出类型，它不同于函数模板，它没有办法去推演。</p><p>类模板的定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//<span class="title">class</span>也可以是<span class="title">typename</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在完成类模板的定义后，可以像普通类一样定义类的对象，用类模板定义对象的格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 &lt;模板实参表&gt; 对象名</span><br></pre></td></tr></table></figure><p>模板类定义对象的时候，由于不能通过参数传递的方法来确定虚拟类型参数对应的具体数据类型，所以必须使用&lt;模板实参表&gt;来告诉编译器具体的数据类型</p><p>类模板示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> <span class="built_in">vector</span>&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> elems.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：标准模板库简介、vector</title>
      <link href="/2021/02/03/C-%EF%BC%9A%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%80%E4%BB%8B%E3%80%81vector/"/>
      <url>/2021/02/03/C-%EF%BC%9A%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E7%AE%80%E4%BB%8B%E3%80%81vector/</url>
      
        <content type="html"><![CDATA[<h2 id="标准模板库简介">标准模板库简介</h2><hr><p>C++标准模板库(Standard Template Library，STL)是一个标准化的模板化的对象容器库，包含多种数据结构和算法，STL的核心包括以下三个组件:</p><ul><li>容器类：容器类是管理序列的类，是容纳一组对象或对象集的类。通过容器类提供的成员函数，可以实现诸如向序列中插入元素，删除元素，查找元素等操作，这些成员函数通过返回迭代器来指定元素在容器中的位置</li><li>迭代器：迭代器是面向对象版本的指针，它可以用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集</li><li>算法：算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作</li></ul><p>这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务</p><h2 id="容器类">容器类</h2><hr><p>容器类分为三大类：顺序容器、关联容器和容器适配器<br><img src="https://img-blog.csdnimg.cn/20201109144216402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中顺序容器与关联容器称为第一类容器。另外有四种容器称为近容器：C语言风格数组、字符串string、操作1/0标志值的bitset和进行高速数学矢量运算的valarray，近容器虽然提供与第一类容器类似的功能，但没有第一类容器的全部功能</p><p>STL为容器提供类似的接口，许多基本操作是所有容器都适用的</p><p><strong>所有标准容器库共有的函数有如下</strong>：<br><img src="https://img-blog.csdnimg.cn/2020110915031627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>只在第一类容器中的函数有如下</strong>：<br><img src="https://img-blog.csdnimg.cn/20201109151021895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="vector容器">vector容器</h2><hr><blockquote><p>参考：<a href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/container/vector</a></p></blockquote><p>vector(向量)是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><p>vector具有如下特点：</p><ol><li>vector是表示可以改变大小的数组的序列容器</li><li>vector与数组一样，元素使用连续的存储空间，就可以使用常规指针，指向其元素，使用偏移量来访问存储空间中的元素</li><li>vector与数组不同的是，vector的大小可以动态变化，容器会自动扩容存储空间</li><li>vector使用一个动态分配的连续存储空间存储元素。在插入新元素时存储空间可能需要重新分配，以便增大大小，这意味着分配一个新存储空间要将所有元素移动到其中。就处理时间而言，这是一项相对昂贵的任务，因此，向量在扩容时有时会预留一定大小的存储空间，这样vector不必每次向容器中添加元素都重新分配，即vector容器可以额外分配一些存储空间以适应可能的增长，因此容器的实际容量可能大于严格需要的存储容量</li><li>vector与C数组相比，向量消耗更多的内存，以换取管理存储和高效动态增长的能力</li><li>与其他动态序列容器(deques, list和forward_list)相比，vector可以相对高效地对元素进行访问、删除和尾部添加，但对于在末尾以外的位置插入或删除元素，其性能较差</li></ol><p>vector的使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ar = &#123;<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">56</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ar.begin();</span><br><span class="line"><span class="keyword">for</span>(;it != ar.end();++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector也可以同C数组那样去访问元素，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ar = &#123;<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">56</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = ar.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//也可以：cout&lt;&lt;ar.at(i)&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector的构造函数">vector的构造函数</h3><p><img src="https://img-blog.csdnimg.cn/20201109192118240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以在使用vector的时候，有如下多种初始化方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; veca;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vecb</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//给vecb10个整型的初始值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vecc</span><span class="params">(<span class="number">10</span>,<span class="number">23</span>)</span></span>;<span class="comment">//给vecb 10个23</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vecd</span><span class="params">(arr,arr+n)</span></span>;<span class="comment">//用ar到ar+n地址之间的数据去初始化vecd</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecf = &#123;<span class="number">12</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;<span class="comment">//C11标准</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecg &#123;<span class="number">12</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector元素的访问">vector元素的访问</h3><p><img src="https://img-blog.csdnimg.cn/20201110132123588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>访问元素示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = vec.at(<span class="number">1</span>); <span class="comment">//访问下标为1的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = vec[<span class="number">1</span>];<span class="comment">//访问下标为1的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = vec.front();<span class="comment">//访问第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d = vec.back();<span class="comment">//访问最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* e = vec.data();<span class="comment">//返回指向容器中第一个元素的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110133440199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="vector迭代器">vector迭代器</h3><table><thead><tr><th style="text-align:left">迭代函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><font color='blue'>iterator</font> begin()</td><td style="text-align:left">返回指向起始的迭代器</td></tr><tr><td style="text-align:left"><font color='blue'>iterator</font> end()</td><td style="text-align:left">返回指向末尾的迭代器</td></tr><tr><td style="text-align:left"><font color='blue'>reverse_iterator </font> rbegin()</td><td style="text-align:left">返回指向起始的逆向迭代器</td></tr><tr><td style="text-align:left"><font color='blue'>reverse_iterator</font> rend()</td><td style="text-align:left">返回指向末尾的逆向迭代器</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2020110919414911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>正向迭代器例：<br><img src="https://img-blog.csdnimg.cn/20201109152012598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>逆向迭代器例：<br><img src="https://img-blog.csdnimg.cn/20201109200722156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>正向迭代器与逆向迭代器都分为普通迭代器与常性迭代器，普通迭代器不但可以读值也可以改值，而常性迭代器就只可以读取容器里元素的值但是不能改变容器里元素的值</p><p>迭代器有越界检查，一旦越界就会抛出异常，但C数组里指针并没有这个特性，所以迭代器比指针更安全</p><h4 id="迭代器失效问题">迭代器失效问题</h4><p>对于如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vec.begin();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">vec.insert(it,<span class="number">100</span>);<span class="comment">//it位置前插入100</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个cout会输出失败，因为在插入元素过后，迭代器it就失效了。如下图，在插入元素的时候，可能原来空间不够用，vector会新开一个空间来存储元素，但是it迭代器仍旧迭代的是旧的那个空间，所以it迭代器已然失效，输出它迭代的内容就会失败<br><img src="https://img-blog.csdnimg.cn/2020111019011126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意：插入数据的时候，容器空间可能够用，系统并未开空间，但是迭代器仍然失效，因为用户并不清除插入数据的时候系统有没有增空间，为了安全性，只要插入数据或调用了push_back或pop_back，迭代器就会失效，所以在使用完这几个函数之后，要更新迭代器</p><h3 id="vector容量">vector容量</h3><table><thead><tr><th style="text-align:left">容量函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><font color='blue'>bool</font> empty() <font color='blue'>const</font></td><td style="text-align:left">检查容器是否为空</td></tr><tr><td style="text-align:left"><font color='LightSeaGreen'>size_type </font> size() <font color='blue'>const</font></td><td style="text-align:left">返回容纳的元素数</td></tr><tr><td style="text-align:left"><font color='LightSeaGreen'>size_type</font> max_size() <font color='blue'>const</font></td><td style="text-align:left">返回可容纳的最大元素数</td></tr><tr><td style="text-align:left"><font color='blue'>void</font> reserve(<font color='LightSeaGreen'>size_type </font>new_cap)</td><td style="text-align:left">预留存储空间</td></tr><tr><td style="text-align:left"><font color='blue'>void</font> capacity() <font color='blue'>cosnt</td><td style="text-align:left">返回当前容器的容量</td></tr><tr><td style="text-align:left"><font color='blue'>void</font> shrink_to_fit()</td><td style="text-align:left">通过释放未使用的内存减少内存的开销</td></tr></tbody></table><p>vector容器可以额外分配一些存储空间以适应可能的增长，因此容器的实际容量可能大于严格需要的存储容量, 如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i + <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"size:  "</span>&lt;&lt; vec.size() &lt;&lt; <span class="string">"\t"</span> &lt;&lt;<span class="string">"capacity:  "</span>&lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110115848745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>运行结果中，容量的值因为会预留存储空间所以会大于等于当前元素个数</p><blockquote><p>关于max_size函数，如下代码，分别计算出对于int型和double型的可容纳的最大元素个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dvec;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"int: "</span>&lt;&lt;ivec.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"double: "</span>&lt;&lt;dvec.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110120924844.png#pic_center" alt="在这里插入图片描述"><br>max_size函数返回的结果其实是STL认为堆区的可分配存储空间的大小除以元素类型的大小，STL认为堆区有4G空间可分配（其实达不到4G），4G/4B = 1073741824, 4G/8B = 536870912<br>其实给C进程的虚拟地址空间有4G，堆区只占一部分（2G左右），示意图如下：<br><img src="https://img-blog.csdnimg.cn/20201110122254132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><h3 id="vector修改器">vector修改器</h3><p><img src="https://img-blog.csdnimg.cn/20201109153356528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>clear函数只清楚容器里的元素，并不会改变容器的容量，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.size() &lt;&lt;<span class="string">"\t"</span>&lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">vec.clear();  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After clear:"</span> &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="string">"\t"</span>&lt;&lt;<span class="string">"capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：clear过后，元素个数为0了，容量不变<br><img src="https://img-blog.csdnimg.cn/20201110123413440.png#pic_center" alt="在这里插入图片描述"><br>但是对于shrink_to_fit函数，它会压缩空间至适当尺寸，容器的容量也会跟着减少，例如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">vec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.size() &lt;&lt;<span class="string">"\t"</span>&lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">vec.shrink_to_fit(); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After shrink_to_fit:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20201110124306225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>shrink_to_fit会回收容器多余的空间，使得容器容量与元素个数相匹配<br>注意：过多地调用shrink_to_fit会产生多的内存碎片</p><p>insert函数的使用：<br><img src="https://img-blog.csdnimg.cn/20201110130034944.png#pic_center" alt="在这里插入图片描述"><br>insert函数例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ForwardPrint</span>(<span class="title">const</span> <span class="title">vector</span>&lt;T&gt; &amp; <span class="title">vec</span>)//打印<span class="title">vec</span>里的元素</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size:  "</span> &lt;&lt; vec.size() &lt;&lt; <span class="string">"\t"</span> &lt;&lt; <span class="string">"capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = vec.begin();</span><br><span class="line"><span class="keyword">for</span> (; it != vec.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vec.begin();</span><br><span class="line">vec.insert(it, <span class="number">10</span>);<span class="comment">//it位置前插入10</span></span><br><span class="line"><span class="comment">//vec.insert(it,10,23); //it位置前插入10个23</span></span><br><span class="line"><span class="comment">//vec.insert(it,ar,ar+n);//it位置前插入数组ar到ar+n的元素</span></span><br><span class="line"><span class="comment">//vec.insert(it,&#123;2,3,5,7,8,212,4&#125;);//it位置前插入给出的列表</span></span><br><span class="line">ForwardPrint(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110125719529.png#pic_center" alt="在这里插入图片描述"><br>erase函数的使用：<br><img src="https://img-blog.csdnimg.cn/2020111013061773.png#pic_center" alt="在这里插入图片描述"></p><h3 id="vector容器成员类型">vector容器成员类型</h3><p><img src="https://img-blog.csdnimg.cn/20201110133807217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>vector定义二维数组：<code>vector&lt;vector&lt;int&gt;&gt; arr;</code></p><h3 id="vector中reserve-resize-assign的区别">vector中reserve,resize,assign的区别</h3><h4 id="reserve">reserve</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(size_type n)</span></span>;</span><br></pre></td></tr></table></figure><p>reserve函数用来给vector预分配存储区大小，即capacity的值，但是没有给这段内存进行初始化。reserve的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值。</p><p>当调用函数时，n的值如果大于capacity的值，就会重新分配内存，使得容量大于n，这样，当调用push_back函数使得size超过原来默认分配的capacity值时避免了内存重分配开销</p><p>需要注意的是：reserve函数分配出来的内存空间未初始化对象，只是表示vector可以利用这部分空间，但vector不能有效访问这些内存空间，如果访问就会出现越界现象，导致程序崩溃</p><h4 id="resize">resize</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">const</span> size_type Newsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">const</span> size_type Newsize, <span class="keyword">const</span> T &amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>resize函数重新分配大小，并且创建对象。</p><p>当Newsize小于当前size()值的时候，vector首先会减少size()值保存前Newsize个元素，然后将超出Newsize的元素删除（remove and destory），但是容器容量并未减少，仍是原来的容量，如下图：<br><img src="https://img-blog.csdnimg.cn/20201110183652516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>当Newsize大于当前size()值的时候，vector会插入相应数量的元素使得size()的值达到Newsize，并对这些元素进行初始化，如果调用上面的第二个resize函数，指定val，vector会用val去初始化这些新插入的元素</p><p>当Newsize大于capacity()值的时候，会自动重新分配内存存储空间</p><h4 id="assign">assign</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(size_type n, <span class="keyword">const</span> T &amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(Input first, Input last)</span></span>;</span><br></pre></td></tr></table></figure><p>assign函数是将n个值为value的元素赋值到vector容器中，或者将first到last区间的元素赋值到当前vector容器中，这个容器会清除掉vector中以前的内容</p><p>这三个函数都有增加容量的能力，但没有减少容量的能力，只有shrink_to_fit才有减少容量的能力</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>reserve</td><td>预分配空间，未初始化</td></tr><tr><td>resize</td><td>重新调整空间大小，会初始化空间</td></tr><tr><td>assign</td><td>清除掉以前内容，放置新内容</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：运算符重载</title>
      <link href="/2021/02/03/C-%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2021/02/03/C-%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符重载的引入">运算符重载的引入</h2><hr><p>对于如下类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Int(<span class="keyword">int</span> x = <span class="number">0</span>):value(x) &#123;&#125; <span class="comment">//构造函数</span></span><br><span class="line">Int(<span class="keyword">const</span> Int &amp; it):value(it.value) &#123;&#125; <span class="comment">//拷贝构造函数</span></span><br><span class="line">~Int() &#123;&#125; <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想在主函数实现Int类型的相加，则需要在类里定义一个Add函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Int a(10),b(10);</span><br><span class="line">Int c;</span><br><span class="line">c=a.Add(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add函数的功能相当于<code>c.value = a.value + b.value</code><br>Add函数如下：(类的成员函数)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line"><span class="function">Int <span class="title">Add</span><span class="params">(Int x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;value + x.value;</span><br><span class="line"><span class="function">Int <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如上Add函数，C++编译器在编译时会作如下改写, (加this指针)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line"><span class="function">Int <span class="title">Add</span><span class="params">(Int * <span class="keyword">const</span> <span class="keyword">this</span>, Int x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;value + x.value;</span><br><span class="line"><span class="function">Int <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数调用中，<code>c=a.Add(b)</code>会被改写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = Add(&amp;a,b);</span><br></pre></td></tr></table></figure><p>该Add函数可以优化，在如上实现的Add函数里，创建了三个对象，如下图示：<br><img src="https://img-blog.csdnimg.cn/20201107202136694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>为了防止创建这么多的对象，我们可以做如下优化：（传引用，直接返回）<br>优化后的Add函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line"><span class="function">Int <span class="title">Add</span><span class="params">(Int &amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Int(<span class="keyword">this</span>-&gt;value + x.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样return时候会直接把对象建立在临时空间，就只创建一个对象<br><img src="https://img-blog.csdnimg.cn/20201107203123470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来我们又注意到，Add函数并不改变x与当前对象的状态，即x.value和this-&gt;value都是不希望被改变的，因此要用const去修饰Add的参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line"><span class="function">Int <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Int &amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Int(<span class="keyword">this</span>-&gt;value + x.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个const修饰&amp;x, 第二个const修饰该方法是一个常方法，修饰的是*this<br><img src="https://img-blog.csdnimg.cn/20201107204652111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这样，在Add函数里若出现修改x.value或this-&gt;value的情况，就会直接报错，Add函数就比较完美的实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line"><span class="function">Int <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Int &amp; x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Int(<span class="keyword">this</span>-&gt;value + x.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就实现了两个变量进行相加的函数Add, 但我们知道内置类型使用 ’ + ’ 进行相加，那能不能把Add直接换成+号呢？即想让+号变成个函数名，但是可惜的是，C++遵循了C的要求，运算符不能作为函数名，C++给出了解决办法：<font color='blue'>在运算符前面加上operator关键字，opertaor与运算符一起使用构成一个函数名，这样就间接地实现了让运算符作为函数名去使用的功能， 这就是运算符的重载</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>+(<span class="keyword">const</span> Int &amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Int(<span class="keyword">this</span>-&gt;value + x.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符的重载">运算符的重载</h2><hr><p>运算符的重载实际上是一种特殊的函数重载，必须定义一个函数，并告诉C++编译器，当遇到该重载的运算符时调用此函数。这个函数叫做运算符重载函数（通常为类的成员函数）</p><p>类外定义运算符重载函数的一般格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  所属类::<span class="keyword">operator</span>运算符(参数表)</span><br><span class="line">&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><p><font color='blue'>operator是关键字，它与重载的运算符一起构成函数名</font>，因重载函数函数名的特殊性，C++编译器可以将这类函数识别出来</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>+(<span class="keyword">const</span> Int &amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Int(<span class="keyword">this</span>-&gt;value + x.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Int a(10),b(20);</span><br><span class="line">Int c;</span><br><span class="line">c = a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c = a + b;</code>就等价于<code>c = a.operator+(b);</code>编译时会改写成：<code>c = operator+(&amp;a, b);</code></p><p>明白了加法的运算符重载以后，我们可以很容易地写出下面一系列运算符的重载</p><p>减法运算符的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>-(<span class="keyword">const</span> Int &amp; x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;value - x.value;</span><br><span class="line"><span class="keyword">return</span> Int(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乘法运算符的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>*(<span class="keyword">const</span> Int &amp;x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;value * x.value;</span><br><span class="line"><span class="keyword">return</span> Int(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除法运算符的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>/(<span class="keyword">const</span> Int &amp;x)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x.value == <span class="number">0</span>)<span class="built_in">exit</span>(EXIT_FAILUE);</span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;value/x.value;</span><br><span class="line"><span class="keyword">return</span> Int(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上运算符左右都是同类型对象，那如果左右是不同种类型，运算符的重载又该如何写呢？例对如下加法，是<code>自定义类型 + 整型</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Int a(10),b(20),c;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">c = a + x;<span class="comment">// 自定义类型  +  整型</span></span><br><span class="line"><span class="comment">//c = a + x; c = a.operator+(x); 编译器改写：c = a.opeartor(&amp;a, x);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的运算符重载函数应该如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = <span class="keyword">this</span>-&gt;value + x;</span><br><span class="line"><span class="keyword">return</span> Int(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：函数参数是内置类型时不加引用比较好，因为引用的本质是指针，编译器编译的时候引用是用指针解释的，用指针对内存访问时会访问两次（读地址，读地址里的值），而不加引用访问内置类型时只访问一次内存，所以不加引用比较好。而若是自己定义的类型，如果不加引用，形参实参结合就会调动拷贝构造函数构建对象，等到函数结束，又要调动析构函数析构对象，所以自定义类型加引用好</p></blockquote><p>其实在前面我们已经实现了Int类对象与对象的相加，那么对象与整型相加可以化为对象与对象相加，就是用那个整型作为构造函数的参数去构造一个对象，所以<code>自定义类型 + 整型</code>的构造函数还可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> x)  <span class="comment">//自定义型 + 整型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> + Int(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是如下情况：<code>整型 + 自定义类型</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Int a(10),b(20),c;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">c = x + a;<span class="comment">// 整型  +  自定义型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把x和a都作为参数传给重载函数，则会出现参数过多的错误，因为重载函数作为类的成员函数还隐含一个this指针，这样加法就有三个参数了，而+是个双目运算符，所以不能这样做！</p><p><img src="https://img-blog.csdnimg.cn/20201107222416755.png#pic_center" alt="在这里插入图片描述"></p><p>可以把重载函数放在类外，使之成为一个全局函数，这样它就没有this指针了，但是全局函数又不能访问类的私有数据成员，因此不能直接<code>x + it.value</code>，但是我们之前已经实现了<code>自定义类型 + 整型</code>, 所以全局函数只需要改变一下+号两边位置即可，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">Int <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> Int &amp;it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> it + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在主函数中出现<code>整型 + 自定义的Int类型</code>时，调动的是全局上的operator+函数，该函数把这两个类型的相加转换为<code>自定义类型 + 整型</code>，从而再去调动类里面的<code>自定义类型 + 整型</code>的重载函数</p><blockquote><p>运算符经重载后有两种使用方式：例如对于c = x + a;</p><ol><li>运算符加：c = x + a;</li><li>函数加：c = operator+(x,a);</li></ol><p>这两种调动方式是等价的</p></blockquote><p><strong>赋值语句的重载</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Int &amp;it) <span class="comment">//不能定义为常方法，赋值语句要修改当前对象的状态</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;value = it.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码虽然可以实现简单的赋值，但不能实现类似c=a=b这样的连续赋值，而我们内置类型是可以的，因此要改进上述代码，使之也可实现连续赋值</p><p>拆解c=a=b, 如下图，可以知道赋值号的重载函数要返回当前对象<br><img src="https://img-blog.csdnimg.cn/20201107233455543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所以修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int <span class="keyword">operator</span>=(<span class="keyword">const</span> Int &amp; it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;value = it.value;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以用引用返回，因为this的生存期不受该重载函数的影响，所以可以用引用返回，这样好处是return时候不会构建一个临时对象了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Int &amp; it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;value = it.value;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要能实现c=c这样的情况，则可以再加一个if判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的成员函数</span></span><br><span class="line">Int &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Int &amp; it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> != &amp;it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;value = it.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩充：以值返回和以引用返回<br>对于如下两个函数，fun1以传值返回，fun2以引用返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">fun1</span><span class="params">(Object &amp; it)</span><span class="comment">//以值返回</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="function">Object &amp; <span class="title">fun2</span><span class="params">(Object &amp; it)</span><span class="comment">//以引用返回</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">Object obj3,obj4;</span><br><span class="line"></span><br><span class="line">obj3 = fun1(obj1);</span><br><span class="line">obj4 = fun2(obj2);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>在主函数中，调动fun1，fun1return时候，fun1函数生存期结束，会构建一个临时对象返回给主函数；而若是调动fun2，以传引用方式返回，编译器就知道it就是obj2的别名，会直接把obj2返回<br><font color='blue'>即传值返回需要构建一个临时对象作为过渡，而引用返回不会构建临时对象作为过渡</font></p></blockquote><h2 id="重载-、–前置后置的问题">重载++、–前置后置的问题</h2><hr><p>前置++的格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回类型  所属类::<span class="keyword">operator</span>++()</span><br><span class="line">&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><p>后置++的格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回类型  所属类::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><p>后置++中的参数int仅用作区分，并无实际意义，可以给变量名，也可以不给变量名只写个int</p><p>例如对于如下Money类型++运算符的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> yuan,jiao;<span class="comment">//1元等于10角</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Money <span class="keyword">operator</span>++();<span class="comment">//前置++</span></span><br><span class="line">Money <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">//后置++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置++，先加再用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Money &amp; Money::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">Jiao++;</span><br><span class="line"><span class="keyword">if</span>(Jiao&gt;=<span class="number">10</span>)<span class="comment">//10角等于1元</span></span><br><span class="line">&#123;</span><br><span class="line">Yuan += <span class="number">1</span>;</span><br><span class="line">Jiao -= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置++，先用再加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Money Money::<span class="keyword">operator</span>++(<span class="keyword">int</span>)<span class="comment">//int区分这是后置++</span></span><br><span class="line">&#123;</span><br><span class="line">Money temp = *<span class="keyword">this</span>;</span><br><span class="line">Jiao++;</span><br><span class="line"><span class="keyword">if</span>(Jiao&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">Yuan+=<span class="number">1</span>;</span><br><span class="line">Jiao -= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置++中，由于要返回对象未加之前的值，所以用一个临时对象保存原始对象，然后再对对象进行++运算，最后返回对象的原始值。后置++不能以引用返回，因为返回的是局部对象，函数结束局部对象就被销毁</p><h2 id="不允许重载的运算符">不允许重载的运算符</h2><hr><p>C++允许重载的运算符有42个，如下表：<br><img src="https://img-blog.csdnimg.cn/20201109114758854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>C++中不可以重载的运算符有五个，如下表：<br><img src="https://img-blog.csdnimg.cn/20201109115515375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="重载运算符的限制">重载运算符的限制</h2><hr><ul><li>不可臆造新的运算符，只能对C++自身提供的运算符进行重载</li><li>不能改变运算符原有的优先级、结合性和语法结构，不能改变运算符操作数的个数</li><li>重载运算符含义必须清楚，不能有二义性</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：new与malloc的区别</title>
      <link href="/2021/02/03/C-%EF%BC%9Anew%E4%B8%8Emalloc%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/02/03/C-%EF%BC%9Anew%E4%B8%8Emalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>new与malloc都是动态管理内存的入口，都可以动态创建内存</p><p>new的三种用法：（下面三种用法经常使用的是第一种用法，第一种用法包含了用法2和用法3，以下区别的讨论也是基于第一种用法讨论的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object *op = <span class="keyword">new</span> Object(<span class="number">10</span>);  <span class="comment">//new作为运算符的使用：开辟空间、调动构造函数</span></span><br><span class="line"></span><br><span class="line">Object *os = (Object*)::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Object));<span class="comment">//该用法与malloc一样，只开辟空间不会调动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>(os) Object(<span class="number">100</span>);<span class="comment">//定位new：不会开辟空间，只去调动构造函数，构造出来的对象放在os地址</span></span><br><span class="line"><span class="comment">//定位new可以实现对象的重新构建：Object a(10); new(&amp;a) Object(10000);</span></span><br></pre></td></tr></table></figure><p>malloc的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * SIZE);</span><br></pre></td></tr></table></figure><p>它们之间有如下差异：</p><h2 id="1-属性">1.属性</h2><p>malloc/free是C/C++标准库的函数</p><p>new/delete是C++的关键字、运算符</p><h2 id="2-是否调用构造函数">2.是否调用构造函数</h2><p>malloc/free只是动态分配内存空间和释放空间</p><p>new/delete除了分配空间还会调用构造析构函数进行对象的创建/清理</p><h2 id="3-参数">3.参数</h2><p>malloc的参数是需要开辟的字节数</p><p>new申请内存分配时无需指定内存块的大小，编译器会根据类型信息自行计算(sizeof)</p><h2 id="4-返回值">4.返回值</h2><p>分配成功：</p><p>malloc返回开辟的空间的首地址，类型是void*，接收时需要强制类型转换</p><p>new返回对象类型的指针，类型严格与对象匹配，无需进行类型转换</p><p>分配失败：</p><p>malloc内存分配失败返回NULL，因此C中malloc之后经常跟着判断指针为不为空的语句</p><p>new内存分配失败会抛出bad_alloc异常</p><h2 id="5-调用关系">5.调用关系</h2><p>new/delete的底层调用了malloc/free，new的实现可以基于malloc</p><p>malloc的实现不可以去调用new</p><h2 id="6-是否可以重载">6.是否可以重载</h2><p>new/delete可以重载</p><p>malloc/free不可以</p><hr><hr><blockquote><p>以下内容转载自：<a href="https://www.cnblogs.com/QG-whz/p/5140930.html" target="_blank" rel="noopener">https://www.cnblogs.com/QG-whz/p/5140930.html</a></p></blockquote><h1>new与malloc的10点区别</h1><h2 id="1-申请的内存所在位置">1. 申请的内存所在位置</h2><p>new操作符从<strong>自由存储区（free store）<strong>上为对象动态分配内存空间，而malloc函数从</strong>堆</strong>上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p><p>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p><p>特别的，new甚至可以不为对象分配内存！<strong>定位new</strong>的功能可以办到这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br></pre></td></tr></table></figure><p>place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span> *)</span> <span class="comment">//不允许重定义这个版本的operator new</span></span></span><br></pre></td></tr></table></figure><p>这个operator new<strong>不分配任何的内存</strong>，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。</p><h2 id="2-返回类型安全性">2.返回类型安全性</h2><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合<strong>类型安全</strong>性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。</p><h2 id="3-内存分配失败时的返回值">3.内存分配失败时的返回值</h2><p>new内存分配失败时，会抛出bac_alloc异常，它<strong>不会返回NULL</strong>；malloc分配内存失败时返回NULL。<br>在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a  = (<span class="keyword">int</span> *)<span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> (<span class="keyword">int</span> ));</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从C语言走入C++阵营的新手可能会把这个习惯带入C++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这样做<strong>一点意义也没有</strong>，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (bad_alloc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想顺便了解下异常基础，可以看http://www.cnblogs.com/QG-whz/p/5136883.htmlC++ 异常机制分析。</p><h2 id="4-是否需要指定内存大小">4.是否需要指定内存大小</h2><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>...&#125;</span><br><span class="line">A * ptr = <span class="keyword">new</span> A;</span><br><span class="line">A * ptr = (A *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(A)); <span class="comment">//需要显式指定所需内存大小sizeof(A);</span></span><br></pre></td></tr></table></figure><p>当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。</p><h2 id="5-是否调用构造函数-析构函数">5.是否调用构造函数/析构函数</h2><p>使用new操作符来分配对象内存时会经历三个步骤：</p><ul><li>第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，<strong>原始</strong>的，未命名的内存空间以便存储特定类型的对象。</li><li>第二步：编译器运行相应的<strong>构造函数</strong>以构造对象，并为其传入初值。</li><li>第三部：对象构造完成后，返回一个指向该对象的指针。</li></ul><p>使用delete操作符来释放对象内存时会经历两个步骤：</p><ul><li>第一步：调用对象的析构函数。</li><li>第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</li></ul><p>总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A() :a(<span class="number">1</span>), b(<span class="number">1.11</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A * ptr = (A*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在return处设置断点，观看ptr所指内存的内容：<br><img src="https://img-blog.csdnimg.cn/img_convert/959a1450e30d6928d27d0cbb90b8a2c7.png" alt="img"></p><p>可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。</p><p>而使用new来分配对象时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A * ptr = <span class="keyword">new</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e755ba0df72a03aa4204b58fa1d8715d.png" alt="img"></p><h2 id="6-对数组的处理">6.对数组的处理</h2><p>C++提供了new[]与delete[]来专门处理数组类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * ptr = <span class="keyword">new</span> A[<span class="number">10</span>];<span class="comment">//分配10个A对象</span></span><br></pre></td></tr></table></figure><p>使用new[]分配的内存必须使用delete[]进行释放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] ptr;</span><br></pre></td></tr></table></figure><p>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p><p>至于malloc，它并不知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">int</span>)* <span class="number">10</span> );<span class="comment">//分配一个10个int元素的数组</span></span><br></pre></td></tr></table></figure><h2 id="7-new与malloc是否可以相互调用">7.new与malloc是否可以相互调用</h2><p>operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">sieze_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">void</span> * mem = <span class="built_in">malloc</span>(size)</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *mem) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-是否可以被重载">8.是否可以被重载</h2><p>opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> * )</span><span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *<span class="number">0</span>）<span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">//这些版本承诺不抛出异常</span></span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">size_t</span> ,<span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp; );</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span> (<span class="keyword">void</span> *,<span class="keyword">nothrow_t</span>&amp; )<span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *<span class="number">0</span>,<span class="keyword">nothrow_t</span>&amp; ）<span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。</p><p>而malloc/free并<strong>不允许重载</strong>。</p><h2 id="9-能够直观地重新分配内存">9. 能够直观地重新分配内存</h2><p>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p><p>new没有这样直观的配套设施来扩充内存。</p><h2 id="10-客户处理内存分配不足">10. 客户处理内存分配不足</h2><p>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是<strong>new-handler</strong>。new_handler是一个指针类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p )</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p><p>对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p><h1>总结</h1><p>将上面所述的10点差别整理成表格：</p><table><thead><tr><th style="text-align:center">特征</th><th style="text-align:center">new/delete</th><th style="text-align:center">malloc/free</th></tr></thead><tbody><tr><td style="text-align:center">分配内存的位置</td><td style="text-align:center">自由存储区</td><td style="text-align:center">堆</td></tr><tr><td style="text-align:center">内存分配成功的返回值</td><td style="text-align:center">完整类型指针</td><td style="text-align:center">void*</td></tr><tr><td style="text-align:center">内存分配失败的返回值</td><td style="text-align:center">默认抛出异常</td><td style="text-align:center">返回NULL</td></tr><tr><td style="text-align:center">分配内存的大小</td><td style="text-align:center">由编译器根据类型计算得出</td><td style="text-align:center">必须显式指定字节数</td></tr><tr><td style="text-align:center">处理数组</td><td style="text-align:center">有处理数组的new版本new[]</td><td style="text-align:center">需要用户计算数组的大小后进行内存分配</td></tr><tr><td style="text-align:center">已分配内存的扩充</td><td style="text-align:center">无法直观地处理</td><td style="text-align:center">使用realloc简单完成</td></tr><tr><td style="text-align:center">是否相互调用</td><td style="text-align:center">可以，看具体的operator new/delete实现</td><td style="text-align:center">不可调用new</td></tr><tr><td style="text-align:center">分配内存时内存不足</td><td style="text-align:center">客户能够指定处理函数或重新制定分配器</td><td style="text-align:center">无法通过用户代码进行处理</td></tr><tr><td style="text-align:center">函数重载</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center">构造函数与析构函数</td><td style="text-align:center">调用</td><td style="text-align:center">不调用</td></tr></tbody></table><p>malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种<br><img src="https://img-blog.csdnimg.cn/img_convert/b8de5fb2309f995be521486816498bb5.png" alt="img"></p><p>而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用:<br><img src="https://img-blog.csdnimg.cn/img_convert/1c6ae7293a86c0acd55ceecd218a769b.png" alt="img"></p><p>当然，malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。</p><blockquote><p>作者：<a href="https://www.cnblogs.com/QG-whz/" target="_blank" rel="noopener">melonstreet</a><br>出处：<a href="https://www.cnblogs.com/QG-whz/" target="_blank" rel="noopener">https://www.cnblogs.com/QG-whz/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：构造、析构、引用与拷贝构造</title>
      <link href="/2020/10/27/C-%EF%BC%9A%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0/"/>
      <url>/2020/10/27/C-%EF%BC%9A%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数">构造函数</h2><hr><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p><p>类的数据成员多为私有的，要对它们进初始化，必须用一个公有函数来进行。同时这个函数应该==在且仅在定义对象时自动执行一次==。这个函数就是构造函数。它由系统自动调动，用户不可以调动。</p><p>构造函数是类的特殊的公有成员函数，有如下特征：</p><ul><li><p><strong>函数名与类名相同</strong>，如：<code>CGoods();</code></p></li><li><p><strong>无函数返回类型说明</strong>（注意：是没有而不是void，即什么也不写，不可写void。实际上构造函数有返回值，返回的是构造函数所创建的对象）</p></li><li><p><strong>系统自动调用</strong>。在程序运行时，当新的对象被建立，该对象所属的类的构造函数被系统自动调用，在该对象生存期中也只调用这一次，程序员不允许手动调动构造函数，例如<code>a.CGoods(&quot;C#&quot;,76,78);</code>是不允许的，构造函数它是对象创建时系统自动调用的</p></li><li><p>可以重载，由不同的参数表区分重载</p></li><li><p>构造函数可以在类中定义，亦可以在类外定义</p><p>在类外定义构造函数时要加作用域限定符，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CGoods::CGoods(<span class="keyword">char</span> *name, <span class="keyword">int</span> amount, <span class="keyword">float</span> price)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(Name,name);</span><br><span class="line">    Amount = amount;</span><br><span class="line">    Price = price;</span><br><span class="line">    Total_value = price * amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若类中没有给出构造函数，则C++编译器自动给出一个缺省的构造函数: <code>类名(void){}</code>，只要我们定义了一个构造函数，系统就不会自动生成缺省的构造函数；如果对象的数据成员全为公有的，也可以在对象名后加<code>={}</code>,在花括号中顺序填入全体数据成员的初始值</p></li></ul><p><strong>注意：构造函数是在已经分配好的空间上初始化对象成员。给对象分配空间是在进入主函数时系统就分配了(静态创建的对象)或者new的时候运行时分配的(动态创建的对象)</strong></p><blockquote><p>补充：空间与对象</p><p>不同于C面向过程中内置类型的有空间即可操纵，面向对象中空间与对象是分离的，有空间不一定有对象，面向对象中有空间了，对象被构造函数初始化之后才可操纵。空间要回收的时候，必须先执行析构函数，再回收空间。Java有垃圾回收机制，程序员只需要关注对象就可以了，而C++里程序员既需要关注对象，还要关注空间。</p></blockquote><blockquote><p>扩充：C++类的默认函数</p><p>对于任何一个类，即便它没有任何函数，编译器将会自动地给它添加6个缺省函数，分别是构造函数、拷贝构造函数、重载=的函数、析构函数、重载&amp;的函数(2个) (如果程序员显示地给出，编译器就不会添加)，如下Empty类的6个默认函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Empty() &#123;&#125;  <span class="comment">//构造函数</span></span><br><span class="line">    Empty(<span class="keyword">const</span> Empty &amp;e) &#123;&#125;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    Empty &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty &amp;e)  <span class="comment">//重载=的函数</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ~Empty() &#123;&#125;  <span class="comment">//析构函数</span></span><br><span class="line"> </span><br><span class="line"> Empty *<span class="keyword">operator</span>&amp;() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;  <span class="comment">//重载&amp;的函数</span></span><br><span class="line"> <span class="keyword">const</span> Empty * <span class="keyword">operator</span>&amp;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;  <span class="comment">//重载&amp;的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="构造函数的使用">构造函数的使用</h4><p>创建对象：</p><p><code>CGoods Car1(&quot;Ford&quot;,30,9999); </code>等效于 <code>CGoods Car1 = CGoods(&quot;Ford&quot;,30,9999)</code></p><p>若不带参数：</p><p><code>CGoods Car1;</code></p><p>注意：定义不带参对象时，不能加括号，例如：CGoods Car1()，它定义的是一个返回值类型是CGoods类型的无参函数</p><h2 id="析构函数">析构函数</h2><hr><blockquote><p>”生而不同，死而相同“：对象可由不同的重载构造函数来初始化，但是销毁的时候都用相同的析构函数</p></blockquote><p>当一个对象被定义时，C++自动调用构造函数对该对象进行初始化，那么当一个对象的生命周期结束时，C++也会自动调用一个函数进行扫尾工作，这个特殊的成员函数就是析构函数。</p><p>析构函数有如下特点：</p><ul><li>析构函数名与类名相同，但在前面加上取反符号’~’，如：<code>~CGoods()</code></li><li>析构函数无函数返回类型</li><li>析构函数不带任何参数</li><li>一个类有一个也只有一个析构函数，这与构造函数不同</li><li>析构函数可以缺省</li><li>对象注销时，系统自动调用析构函数，但是程序员也可以在对象生存期没到时，手动调动析构函数，完成对象的自杀动作，如<code>a.~Object();</code>是可以的</li></ul><p><strong>注意：析构函数本身并不释放对象占用的内存空间,它只是在系统收回对象的内存空间之前执行扫尾工作</strong></p><h4 id="构造与析构顺序">构造与析构顺序</h4><p>对于如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Object(<span class="keyword">int</span> x = <span class="number">0</span>) :value(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Create Object: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Object()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Destory Object: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">fun();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><p><img src="https://img-blog.csdnimg.cn/20201027225248961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>分析：</p><p>当程序编译链接通过时，形成可执行文件，运行可执行文件时，系统给该进程分配了四个空间：代码区.text、数据区.data、堆区.heap、栈区.stack<br><img src="https://img-blog.csdnimg.cn/20201027225306819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>程序主函数执行时，先处理全局变量，放入.data区，所以先创建b和d；然后主函数接着执行，执行<code>object c(3)</code>，创建c；再执行<code>fun()</code>，创建a，退出fun函数时，收回fun函数栈帧，所以局部变量对象a被销毁，对象a的析构函数被执行；再回到主函数接着执行return，主函数结束，主函数栈帧回收，主函数里的对象c被销毁；接着程序结束，给该进程分配的用户空间要回收，全局对象被依次销毁，所以打印出来的顺序就是2 4 3 1 1 3 4 2</p><h4 id="构造函数与析构函数的this指针">构造函数与析构函数的this指针</h4><p>构造函数和析构函数也有this指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>其实就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object(&amp;c,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>构造的时候把c这个对象传给this指针，构造函数就知道它要操纵的具体是哪个对象了</p><p>C++中除了静态函数和友元函数，其他所有类的成员函数都含有this指针</p><p>更多关于this指针的介绍，请参考我的另一篇博客：<a href="https://blog.csdn.net/huifaguangdemao/article/details/109260485" target="_blank" rel="noopener">C++：类、对象、this指针、内联函数</a></p><h4 id="用new创建对象">用new创建对象</h4><p>new是C++关键字中比较特殊的一个，它是一种运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object *op = <span class="literal">NULL</span>;</span><br><span class="line">op = <span class="keyword">new</span> Object(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>new做了两个动作</p><ul><li>从堆区申请空间</li><li>调动构造函数初始化对象</li></ul><p>与C中malloc不同，malloc只申请空间</p><h4 id="用delete删除对象">用delete删除对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> op;</span><br></pre></td></tr></table></figure><p>delete做了两个动作</p><ul><li>调动对象的析构函数</li><li>释放空间</li></ul><h2 id="引用">引用</h2><hr><p>C++函数中参数的传递方式是传值。在函数域中为参数重新分配内存，而把实参的数值传递到新分配的内存中。它的优点是有效避免函数的副作用。</p><p>如果要求改变实参的值呢？如果实参是一个复杂的对象，重新分配内存会引起程序执行效率大大下降，怎么办呢？</p><p>在C++中有一种新的导出型数据类型——引用(reference)，可以解决上面的难题，引用又称为别名。</p><h4 id="引用-2">引用&amp;</h4><p>就是别名/外号, 一旦引用初始化为某个变量，就可以使用引用名称直接使用该变量，就是给该变量起了个别名</p><p>引用不是定义一个新的变量，而是给一个已经定义的变量重新起一个别名，也就是C++系统不为引用类型变量分配内存空间。引用主要用于函数之间的数据传递。</p><p>引用的定义格式：<code>类型 &amp; 引用变量名 = 已定义过的变量名</code></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> number;</span><br><span class="line"><span class="keyword">double</span> &amp;newnum = number;<span class="comment">//newnum是新定义的引用类型变量，newnum也就是number的别名</span></span><br></pre></td></tr></table></figure><h4 id="引用的特点">引用的特点</h4><ol><li>没有空引用</li><li>定义引用时必须进行初始化</li><li>没有二级引用，即没有引用的引用</li></ol><h4 id="引用的使用">引用的使用</h4><p>C语言使用指针交换a，b</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_c</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = *pa;</span><br><span class="line">*pa = *pb;</span><br><span class="line">*pb = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++使用引用交换a，b</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_cpp</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><span class="comment">//在函数中对a，b的交换，就是对实参的交换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C中使用指针间接交换了a，b；而C++使用引用直接操纵实参进行了交换</p><blockquote><p>补充：&amp;的使用</p><ol><li>位运算与：数字之间：1 &amp; 0 --&gt; 0</li><li>取地址符：变量名前：&amp;a</li><li>引用：类型与标识符中间：int &amp;c = a;</li></ol></blockquote><h4 id="引用的本质">引用的本质</h4><p>对于如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> &amp;ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;ap;</span><br><span class="line">    ap = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;p = x;<span class="comment">//p就是x的别名</span></span><br><span class="line">    p = <span class="number">200</span>;</span><br><span class="line">    fun(x);</span><br><span class="line">    fun(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候，编译器会把引用改写成常指针，上述代码就变成如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> ap)</span><span class="comment">//const修饰ap指针自身，ap自身不可变，但*ap可变</span></span></span><br><span class="line"><span class="function">    <span class="comment">//const修饰直接右边，基本类型对const透明</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = ap;</span><br><span class="line">    *ap = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;x;</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    fun(&amp;x);</span><br><span class="line">    fun(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201027225354740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>从逻辑角度看，引用就是别名，指针是地址；从底层来看，引用就是常性的指针</p><h4 id="注意：函数内局部变量的地址不能作为返回值">注意：函数内局部变量的地址不能作为返回值</h4><p>对于如下代码：编译的时候都会报警告</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">funp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">funy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">funarr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">124</span>;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201027225415379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>函数执行完毕后函数栈就被释放了，不能再对函数内局部变量的地址进行操作，因而不能返回局部变量的地址，可以返回局部变量的值，函数返回局部变量值时实际上是返回变量值的拷贝。作为局部变量，在栈区存储，虽然在函数调用结束后所在内存会被释放回收掉，但返回值会有一个拷贝副本，供调用者使用</p><p>==变量的生存期不受函数生存期影响，才能返回其地址==，如动态创建的(堆区)、全局的、静态的</p><p><a href="https://www.cnblogs.com/qinguoyi/p/10154804.html" target="_blank" rel="noopener">关于函数返回局部变量的更多介绍</a></p><h2 id="拷贝构造函数">拷贝构造函数</h2><hr><p>拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用。拷贝构造函数的功能是用一个已经存在的对象的数据成员去初构造同类型的新对象的数据成员</p><p>同一个类的对象在内存中有完全相同的结构，如果作为一个整体进行拷贝是完全可行的。这个拷贝过程只需要拷贝数据成员，而函数成员是共用的。在建立对象时可用同一类的另一个对象作为参数来构造该对象，这时所用的构造函数称为拷贝构造函数</p><p>对于CGoods类，缺省拷贝构造函数形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CGoods(<span class="keyword">const</span> CGoods &amp; cgd) </span><br><span class="line">&#123;</span><br><span class="line">    Strcpy(Name,cgd.Name);</span><br><span class="line">    Price = cgd.Price;</span><br><span class="line">    Amount = cgd.Amount;</span><br><span class="line">    Total_value = cgd.Total_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用拷贝构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CGoods <span class="title">x</span><span class="params">(<span class="string">"C++"</span>, <span class="number">22</span>, <span class="number">97</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">CGoods <span class="title">a</span><span class="params">(x)</span></span>;<span class="comment">//用x的数据成员去初始化新对象a的数据成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：拷贝构造函数不是把一个对象赋值给一个空间，面向对象思维里对象是对象，空间是空间，拷贝构造函数仍然是构造函数，只不过参数是同类型的另一个对象</p><h4 id="拷贝构造函数的应用场景">拷贝构造函数的应用场景</h4><p>1.当函数的形参是类的对象，调用函数时，进行形参与实参结合时使用。这时要在内存新建立一个局部对象，并把实参拷贝到新对象中</p><p>如下代码：fun函数的形参是类的对象，在car所指定的空间中构造一个对象时系统就要用到拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CGoods <span class="title">fun</span><span class="params">(CGoods car)</span><span class="comment">//函数的形参是类的对象，在car所指定的空间中构造一个对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGoods(<span class="string">"C#"</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CGoods <span class="title">x</span><span class="params">(<span class="string">"C++"</span>,<span class="number">22</span>,<span class="number">97</span>)</span></span>;</span><br><span class="line">    CGoods a;</span><br><span class="line">    a = fun(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.当函数的返回值是类的对象，函数执行完成返回调用者时使用。理由也是要建立一个临时对象，再返回调用者</p><p>如上代码中，fun函数的返回值是类的对象，在主函数中用a来接收fun函数的返回值，系统不能把c1直接赋值给a，因为局部对象是在离开建立它的函数时就消亡了，不可能在返回调用函数后继续生存，所以在处理这种情况时，编译系统会在调用函数的表达式中创建一个无名临时对象，该临时对象的生存期只在函数调用处的表达式中。即return对象时，实际上是调用拷贝构造函数把该对象的值拷入临时对象，主函数调用者使用的是该临时对象。如果返回的是局部变量，处理过程类似，只是不调用构造函数，只创建一个临时变量副本。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：信号、僵尸进程</title>
      <link href="/2020/10/26/Linux%EF%BC%9A%E4%BF%A1%E5%8F%B7%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/10/26/Linux%EF%BC%9A%E4%BF%A1%E5%8F%B7%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="信号的引入：">信号的引入：</h2><h4 id="僵尸进程：">僵尸进程：</h4><p>进程中的指令已经执行完成，但是进程PCB结构还没有回收；父进程未结束，子进程结束，但是父进程没有处理子进程的退出状态，没有释放子进程占用的资源，该子进程就成为一个僵尸进程</p><h4 id="处理僵尸进程的系统调用：">处理僵尸进程的系统调用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *result)</span></span>;<span class="comment">//获取调用此方法的进程的子进程的退出码</span></span><br></pre></td></tr></table></figure><p>父进程调用wait方法处理子进程的僵尸状态，调用wait时，</p><ul><li>如果没有子进程则出错返回；</li><li>如果有子进程，子进程还没结束，则wait调用会阻塞等待子进程的结束；</li><li>如果有子进程并且已经结束，则销毁子进程，返回子进程的pid，退出码用result返回</li></ul><p>一次wait调用只能处理一个子进程(最先结束的)</p><p>wait的调用时机要放在子进程刚刚结束之后，那么父进程如何知道子进程结束了呢？这就要用到信号</p><p>子进程结束后给父进程发送信号，当父进程接收到信号，在信号处理函数中调用wait</p><h2 id="信号">信号</h2><h4 id="信号-2">信号</h4><p>信号是操作系统中进程间通讯的一种有限制的方式。它是一种<strong>异步</strong>的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p><p>即系统预先定义好的某些特定的事件。信号可以被发送，也可以被接收，发送和接收的主体都是进程</p><h4 id="查看Linux信号">查看Linux信号</h4><p>路径：<code>/usr/include/bits/signum.h</code><br><img src="https://img-blog.csdnimg.cn/20201026202312851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="信号的响应方式">信号的响应方式</h4><p>一个进程接收到信号后有三种处理方式：</p><ul><li>忽略：即忽略此信号，用SIG_IN(函数指针类型)指定</li><li>默认：针对大多数信号的系统默认动作是终止进程，用SIG_DFL指定</li><li>自定义(捕获)由用户自己指定</li></ul><h4 id="修改信号响应方式">修改信号响应方式</h4><p>使用signal系统调用，给信号值绑定一个信号处理函数，绑定之后进程收到此信号，系统自动调用绑定的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">函数地址 signal(信号值，函数地址);</span><br></pre></td></tr></table></figure><p>信号处理函数，参数必须是int类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_fun</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>信号处理函数的调用时机：收到信号以后，调用信号处理函数</p><p>例：绑定ctrl+c信号与signal_fun函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_fun</span><span class="params">(<span class="keyword">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"signal_fun start\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGINT,signal_fun);<span class="comment">//绑定ctrl+c信号与signal_fun函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pricess is running\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201026202408725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如果进程接收到一个信号，会将当前正在执行的主逻辑暂停，等待信号处理函数执行完毕，主逻辑再接着执行</p><p>信号处理函数执行过程中，进程再最多接收一次该信号（信号屏蔽，因为记录信号的发生是通过位来记录的，信号处理函数执行过程中，再来信号，该位由0变1，不管来多少信号，该位只能记录来信号这一事件，而不能具体知道来了多少信号），所以信号处理函数应该尽可能快地执行结束，以防止信号被长时间屏蔽</p><p>扩充：为防止信号处理函数执行过程中，再来的信号被长时间屏蔽，可以使用统一事件源机制，即把复杂耗时长的信号处理函数放在主逻辑中去处理，因为主逻辑的执行不会屏蔽信号</p><h4 id="用信号机制处理僵尸进程">用信号机制处理僵尸进程</h4><p>对于如下代码：父进程未结束，但子进程已经结束，子进程就变为僵尸进程，但用signal绑定了SIGCHILD与sign_fun函数，一旦子进程结束发送给父进程SIGCHILD信号，系统就自动调用signal_fun函数，signal_fun里的wait方法就会处理掉该僵尸进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_fun</span><span class="params">(<span class="keyword">int</span> sign)</span><span class="comment">//信号处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGCHILD,sign_fun);<span class="comment">//绑定信号与信号处理函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> n = fork();</span><br><span class="line">    assert(n!=<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child start\n"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child over"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例：信号的二次绑定">例：信号的二次绑定</h4><p>运行程序，第一次接收到SIGINT信号，进程打印HelloWorld，第二次接收到SIGINT信号，进程结束</p><ol><li>程序启动时：signal(SIGINT, fun1);</li><li>第一次接收到信号，fun</li><li>将信号的响应方式修改为默认SIG_DFL</li><li>第二次接收信号，默认退出程序</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HelloWorld\n"</span>);<span class="comment">//第一次接收到信号</span></span><br><span class="line">    signal(SIGINT,SIG_DFL);<span class="comment">//将信号响应方式恢复为默认，默认退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGINT, fun);<span class="comment">//程序启动时，绑定</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"process running...\n"</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号的发送">信号的发送</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sign)</span></span>;<span class="comment">//sign是要发送的信号</span></span><br></pre></td></tr></table></figure><p>kill方法的pid参数有四种不同的情况</p><ul><li>pid&gt;0，将该信号发送给进程ID为pid的进程</li><li>pid==0，将该信号发送给与发送进程属于同一进程组的所有进程，而且发送进程具有向这些进程发送信号的权限</li><li>pid&lt;0，将该信号发送给其进程组ID等于pid的绝对值的进程，而且发送进程具有向这些进程发送信号的权限</li><li>pid==-1，将该信号发送给发送进程有权限向它们发送信号的系统上的所有进程</li></ul><p>返回值：成功返回0，失败返回-1</p><h4 id="用kill方法实现kill命令">用kill方法实现kill命令</h4><p>kill命令：kill pid 或  kill -9 pid</p><p>用kill方法实现kill的命令代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><span class="comment">//argv[0]:kill  argv[1]: -9/pid</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input pid\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = SIGTERM;<span class="comment">//kill命令的默认信号</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">"-9"</span>, <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sign = SIGKILL;</span><br><span class="line">        i=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;argc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">int</span> pid = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sscanf</span>(argv[i],<span class="string">"%d"</span>,&amp;pid);<span class="comment">//从字符串中取得整数放到pid里 </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == kill(pid,sign))<span class="comment">//获取失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">sprintf</span>(buff, <span class="string">"%d"</span>,pid);<span class="comment">//把%d形式存入buff</span></span><br><span class="line">            perror(buff);<span class="comment">//标准错误输出</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试mykill：</p><p><img src="https://img-blog.csdnimg.cn/20201026202441260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：多进程编程、fork</title>
      <link href="/2020/10/26/Linux%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E3%80%81fork/"/>
      <url>/2020/10/26/Linux%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E3%80%81fork/</url>
      
        <content type="html"><![CDATA[<h2 id="程序、进程、线程">程序、进程、线程</h2><hr><p><strong>程序(program)</strong><br>存储在磁盘上的二进制可执行文件，程序员编写源代码文件，由编译器编译链接生成的文件。Windows上可执行程序是.exe文件，Linux上是a.out文件（ELF格式的文件）</p><p><strong>进程(process)</strong><br>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，即进行中的程序或运行中的程序，也就是程序的一次实例化<br>进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念</p><p><strong>线程(thread)</strong><br>线程是对进程的进一步细化，是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。</p><p><font color='red'><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元</strong></font></p><p><strong>扩展：协程(Coroutines)</strong><br>协程是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程，Golang语言支持协程</p><h2 id="进程控制块-PCB">进程控制块(PCB)</h2><hr><p>运行中的程序，只要把程序从磁盘加载到内存上，操作系统就要分配一个进程控制块来管理加载到内存上的程序，即PCB（ProcessingControlBlock）</p><p>PCB记录进程的属性信息，包括进程标识号(PID Process Identification)、进程状态、程序上下文、程序计数器等</p><p>操作系统对进程的管理就是通过PCB进行管理的，操作系统直接控制的主体就是PCB</p><p>操作系统通过双向循环链表将所有的PCB管理起来，每一个PCB都是一个tast_struct类型<br><img src="https://img-blog.csdnimg.cn/20201016123533945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>系统中的进程有两部分数据：</p><ol><li>PCB进程控制块</li><li>程序加载到内存的数据</li></ol><p>执行一个进程时：系统先分配PCB，然后才加载程序</p><p>一个进程结束时：必须先释放在内存上的程序指令所占的内存，然后释放PCB结构</p><p>如果进程已经执行结束，但是进程对应的PCB结构还没有被系统释放，该进程就变成一个僵尸进程(Zombie)</p><h2 id="并发与并行">并发与并行</h2><hr><p><strong>并发</strong><br>并发是指一个处理器&quot;同时&quot;处理多个任务， 在微观上这几个任务不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行，从宏观上来看，好像是这些进程都在执行，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一会停一会</p><p><strong>并行</strong><br>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务，并行需要硬件的支持(多核)，在任意时刻，两个进程都是同时执行的</p><p>并发与并行示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/20201016110420376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="进程创建fork">进程创建fork</h2><hr><p>我们知道main函数从第一行开始执行，按照顺序执行到main的最后一行，程序结束<br>那么如何在main中创建出另一个进程呢？就要用到fork方法</p><p>fork()是UNIX或类UNIX中的分叉函数，fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事</p><p>原来的进程称为<strong>父进程</strong>，新创建出来的进程称为<strong>子进程</strong></p><p>复制出来的进程会接着原来进程的执行逻辑继续向下执行，即<font color='red'>父子进程都会执行fork函数返回之后的剩余的代码</font></p><p><strong>fork函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;  #<span class="keyword">pid_t</span>是一个宏定义，其本质是<span class="keyword">int</span>，表示函数返回值是进程标识号pid</span><br></pre></td></tr></table></figure><p>调用fork函数需要包含头文件&lt;unistd.h&gt;</p><p>fork函数被调用一次，会产生一个子进程，父进程中fork函数的返回值是子进程的pid，子进程也会拿到一个fork的返回值是0，即fork方法被调用一次，成功则会有两个返回值：（fork调用失败返回-1）</p><ul><li><font color='red'>在父进程返回一次，返回值为新创建的子进程的进程标识号(pid)</font></li><li><font color='red'>在子进程中，fork返回0</font></li></ul><p><strong>获取当前进程pid的系统调用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>父子进程fork返回值例题</strong>：<br><strong>例1</strong>：<br><img src="https://img-blog.csdnimg.cn/2020101613241694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意：fork之后父子进程的执行顺序是不确定的，父子进程是并发执行的，具体顺序由当前操作系统处理器数量以及进程调度算法决定</p><p><strong>例2</strong>：<br><img src="https://img-blog.csdnimg.cn/20201016135254758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201018112649632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>例2分析</strong>：i==0时，调用一次fork，创建出一个子进程，此时父进程打印B，子进程打印A，即图中绿色边框字母，然后父子进程分别i++，此时i为1，父子进程分别都调用fork，则父进程又创建出一个子进程(左下)，子进程化为父进程也创建出一个新的子进程(右下)，作为父进程的打印B，子进程的打印A(蓝色边框)，一共打印三个B三个A</p><p><strong>例3</strong>：<br><img src="https://img-blog.csdnimg.cn/20201016142629583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>例3分析</strong>：父进程执行if语句创建出两个子进程，父进程打印一个A，创建出的两个子进程分别继续执行if语句，因为fork返回给子进程的值为0，所以子进程&amp;&amp;语句只执行前半部分判断为假就结束判断，两个子进程分别打印一个B，所以为1A2B</p><p><strong>例4</strong>：<br><img src="https://img-blog.csdnimg.cn/20201016143834496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>例4分析</strong>：例4就是把例2中打印的换行\n给去掉了，不打印换行，则执行完一句printf函数，先不刷新缓冲区，即打印的对象先不显示出来仍停留在缓冲区，等到程序结束或刷新了缓冲区才显示出来。fork的时候，子进程会复制父进程的堆，因而父进程缓冲的数据会复制给子进程。i==0时，父进程缓冲区还没东西，其子进程得到的缓冲区也没东西，继续向下执行，父进程缓冲区写入B，子进程缓冲区写入A；当i为1时，父进程又fork出一个子进程，原子进程作为父进程也fork出一个子进程，这次fork出的进程就会继承它们父进程缓冲区, 如下图灰色箭头，在复制来的缓冲区基础上，继续执行，因而最后显示出来的结果就会是8个<br><img src="https://img-blog.csdnimg.cn/20201018105509726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>增加显示进程pid，验证例4：<br><img src="https://img-blog.csdnimg.cn/20201018111625585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（后续进程会打印 “main: 20879” 就是因为最开始的父进程缓冲区写入了该语句，后续凡是直接或间接继承了该缓冲区的进程都会打印此句）</p><h3 id="数据共享问题">数据共享问题</h3><p><strong>fork之后，父子进程对于数据的共享问题</strong></p><p>C语言对数据的分类有：</p><ul><li>全局数据(.data  .bss)</li><li>栈区数据(.stack)</li><li>堆区数据(.heap)</li></ul><p>fork之前定义全局数据、栈区数据、堆区数据。调用fork，然后在父进程或子进程中修改三个位置的数据。在对应的另一个进程中，其数据会跟着变化吗？</p><p>答：不会。fork之后，子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如：子进程获得父进程数据空间、堆和栈的副本。注意：这是子进程所拥有的的副本。父子进程并不共享这些存储空间。</p><p><font color='blue'>fork之前的数据的虚拟地址空间都是相等的，但是fork之后，父子进程是两个独立并发运行的进程，两个进程的页表是不同的，因而所映射的物理地址是不同的，数据存储在不同的物理空间上，并不共用</font></p><h3 id="写时拷贝技术">写时拷贝技术</h3><p>由于在fork之后经常跟随者exec(进程替换)，所以现在很多实现并不执行一个父进程数据段、栈和堆的的完全复制。作为替代，使用了写时拷贝技术(CopyOnWrite, COW)。</p><p>写时拷贝技术即写时再拷贝：这些区域(全局数据、栈区数据、堆区数据)由父子进程共享，而且内核将它们的访问权限改为只读的。如果父子进程中的任何一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储器系统的一&quot;页&quot;。</p><p>写时拷贝技术优化了fork()时的开销，避免了一些没必要的复制</p><blockquote><p>扩充malloc与交换分区：</p><ul><li><p>malloc成功返回并不代表已经将物理内存空间分配给了进程。只是将虚拟地址空间分配，并没有将其映射到物理内存上。使用时，才会做映射</p></li><li><p>malloc函数仅仅申请开辟虚拟内存空间，在使用虚拟空间存储数据时，才会给其分配物理内存空间，然后将虚拟空间映射到物理空间上</p></li><li><p>fork()会使用写时拷贝技术</p></li><li><p>如果当前物理内存空间足够使用，系统就不会选择交换分区存储数据。内存不够时，才将部分数据置换到交换分区中</p></li><li><p>物理内存如果有了空间以后，也不会立即将交换分区的数据置换回来。只有当系统需要使用存储在交换分区上的数据时，才会将其重新置换到内存中</p></li></ul></blockquote><h3 id="文件描述符的共享">文件描述符的共享</h3><p>我们知道fork之后，父子进程是两个独立的进程，并不共用数据，那么fork之前用open打开一个文件，fork之后，子进程能不能通过文件描述符访问到该文件呢？如果能会不会对父进程访问文件造成影响呢？即父子进程是否会共享fork之前打开的文件描述符呢?</p><p>答：<font color='blue'>fork之后，父子进程会共享fork之前打开的文件描述符，主要是对文件读写偏移量的共享</font></p><p>原因如下：</p><ul><li><p>进程打开的文件的记录方式是用PCB记录的(内核空间里)：<img src="https://img-blog.csdnimg.cn/20201026133702700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>文件描述符就是PCB中的文件表数组的下标</p></li><li><p>fork时父子进程对文件的操作，从下图可以看到，fork时候子进程直接复制了父进程的PCB里的值(*p = *current)，该句拷贝是浅拷贝，是直接把值拷贝过来，所以子进程PCB里的指针依旧指向的是struct file这个结构，用子进程PCB里的指针访问的依旧是之前的struct file，那么对于struct file里的f_pos(文件偏移量)，自然访问到的也是相同的，而对于struct file，有两个指针指向了它，它只是把f_count做加1的操作。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20201026133749328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>因而，父子进程会共享fork之前打开的文件描述符，主要是对文件偏移量的共享</li></ul><p>系统这样去实现，节省了空间，因为操作的都是同一个文件，没必要为每个fork的进程都用深拷贝做一份struct file</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文件操作的系统调用</title>
      <link href="/2020/10/25/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/2020/10/25/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Linux的I/O操作方法：系统调用</p><p>系统调用由内核实现，在内核中执行，被程序（用户态）调用，区分于库函数的调用和实现，库函数的调用和实现、执行都在用户态</p><p>文件操作系统调用的头文件：<strong>&lt;unistd.h&gt;</strong></p><h2 id="1-打开文件">1.打开文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag, <span class="comment">/*int mode*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>pathname： 文件路径+文件名</p><p>flag：打开的标记</p><ul><li><p>O_RDONLY   只读</p></li><li><p>O_WRONLY  只写</p></li><li><p>O_RDWR      读写</p><p>以上三个变量必须指定一个且只能指定一个。下列常量则是可选的：</p></li><li><p>O_APPEND  追加</p></li><li><p>O_CREAT     打开文件，不存在则创建</p></li><li><p>O_EXCL       如果同时指定了O_CREAT，而文件已经存在，则会出错。用此可以测试一个文件是否存在</p></li><li><p>O_TRUNC    如果此文件存在，而且为只写或读写成功打开，则将其长度截取为0</p></li><li><p>O_NOCTTY  如果pathname指的是终端设备，则不将该设备分配作为此进程的控制终端</p></li><li><p>O_NONBLOCK  若pathname指的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置为非阻塞模式</p></li></ul><p>mode：只有flag为O_CREAT时，才需要该参数，指定创建的文件的访问权限，成功返回一个文件描述符(大于等于0的整数值)，失败返回-1</p><p>返回值：成功返回一个文件描述符（大于等于0的整数值），失败返回-1</p><h2 id="2-读取文件内容">2.读取文件内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>fd：要读取的文件的文件描述符（用open打开的返回值）</p><p>buf：用户缓冲区，用于存储从文件中读取的数据</p><p>size：用户缓冲区的大小，指定一次read最多能够读取的数据长度，单位是字节</p><p>返回值：成功返回真实读到的数据长度，读到文件末尾返回0，读取失败返回-1</p><h2 id="3-向文件中写入内容">3.向文件中写入内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>fd：要写入的文件的文件描述符</p><p>buf：想写入文件中的数据的首地址</p><p>length：写入数据的长度</p><p>返回值：成功返回真实写入数据的长度，返回0没有写入任何内容，返回-1写入失败</p><h2 id="4-操作读写游标-偏移量">4.操作读写游标(偏移量)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> count, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符</p><p>count：移动的大小</p><p>flag：相对位置</p><ul><li>SEEK_SET    将该文件偏移量设置为距离文件开始加count个字节，设置到文件头：lseek(fd, 0, SEEK_SET);</li><li>SEEK_CUR   将该文件偏移量设置为距离当前偏移量加count个字节</li><li>SEEK_END   将该文件偏移量设置为距离文件尾加count个字节</li></ul><p>返回值：成功返回0，失败返回-1</p><h2 id="5-关闭打开的文件">5.关闭打开的文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>fd：要关闭的文件的文件描述符</p><p>返回值：成功返回0，失败返回-1</p><p>关闭一个文件会消除当前游标，下次打开游标在文件头</p><p>当一个进程终止时，内核自动关闭它所有打开的文件，很多程序都利用了这一功能而不显示地用close关闭打开的文件</p><h2 id="6-例：用上述系统调用实现文件拷贝">6.例：用上述系统调用实现文件拷贝</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyfile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">const</span> <span class="keyword">char</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fdr = <span class="built_in">open</span>(source,O_RDONLY);</span><br><span class="line">assert(fdr != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> fdw = <span class="built_in">open</span>(dest, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);<span class="comment">//0664数字法设定文件权限</span></span><br><span class="line">assert(fdw != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">read</span>(fdr, buff, <span class="number">127</span>);</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">write</span>(fdw, buff, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(fdr);</span><br><span class="line"><span class="built_in">close</span>(fdw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：类、对象、this指针、内联函数</title>
      <link href="/2020/10/24/C-%EF%BC%9A%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81this%E6%8C%87%E9%92%88%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2020/10/24/C-%EF%BC%9A%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81this%E6%8C%87%E9%92%88%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="类">类</h2><hr><p>现实世界中的实体可以抽象出类别的概念。对应于计算机世界就有一个<strong>类</strong>(class)的概念，因为类是一个抽象的概念的对应体，所以计算机不给它分配内存，只有当类实例化为对象时，给对象分配内存<br><img src="https://img-blog.csdnimg.cn/20201024153831700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><font color='blue'>类是设计的产物，对象是对类的实例化</font>，设计类型时并没有给其开辟空间，实例化为对象后开空间，我们操作的是对象，而不是类</p><h2 id="C-类的设计">C++类的设计</h2><p>C++中，类是一种数据类型，客观事物是复杂的，要描述它必须从多方面进行，也就是用不同的数据类型来描述不同的方面。<strong>类把数据(事物的属性)和函数(事物的行为、操作)封装为一个整体</strong>，如商场中的商品可以这样描述：</p><ul><li>商品名称(用字符串描述)，该商品数量(用整数描述), 该商品单价(用浮点数描述)，该商品总价(用浮点数描述)。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGoods</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> Name[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> Amount;</span><br><span class="line"><span class="keyword">float</span> Price;</span><br><span class="line"><span class="keyword">float</span> Total_value;</span><br><span class="line">&#125;;<span class="comment">//最后的分号不可少</span></span><br></pre></td></tr></table></figure></li><li>关键字class是数据类型说明符，指出下面说明的是类。标识符CGoods是商品这个类的类型名。花括号中是构成类体的一系列成员，关键字public是一种访问限定符</li></ul><p>访问限定符有三种：private，protected、public，如果在类起始点无访问说明符号，<strong>系统默认为private</strong></p><p>设计一个类的一般格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">成员表<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">成员表<span class="number">2</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">成员表<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员函数的定义">成员函数的定义</h3><p>函数定义通常在类的说明之后进行，其格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  类名::函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:: 称为作用域解析运算符，它指出该函数是属于那一个类的成员函数</p><h2 id="对象-instance">对象(instance)</h2><hr><p>对象是类的实例。声明一种数据类型只是告诉编译系统该数据类型的构造，并没有预定内存。设计出来的类只是一个样板，以此样板可以在内存中开辟出同样结构的实例——对象。</p><p>创建类的对象可以有两种方法：</p><ol><li>直接定义类的实例对象，创建在栈区：CGoods Car; int I;</li><li>动态创建类的对象，创建在堆区：CGoods *p = new CGoods();</li></ol><p><strong>有两种方法存储对象</strong>：</p><p>第一种方法是为每一个对象都分配全套的内存来存属性和方法，包括安放成员数据的数据区和安放成员函数的代码区<br><img src="https://img-blog.csdnimg.cn/20201024170137724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>但是区别同一个类的各个不同对象的属性是由数据成员决定的，不同对象的数据成员的内容是不一样的；而行为(操作)是用函数来描述的，这些<strong>操作的代码对所有的对象都是一样的</strong>，因而为每个对象都存储一份函数代码会造成空间上的浪费</p><p>第二种方法仅为每个对象分配一个数据区，代码区(放成员函数的区域)为各对象所共用<br><img src="https://img-blog.csdnimg.cn/20201024170349849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>C++采用第二种方法存储对象。不同的对象有各自的属性，但是方法都是同一个方法，那么方法是怎么区别它操纵的到底是哪个对象的数据呢？这就是this指针的来源与用处所在</p><h2 id="this指针">this指针</h2><hr><p>C++编译器对C++编译的时候，有三个步骤：</p><ol><li>识别类里面的属性成员</li><li>识别方法，只识别方法的声明</li><li>改写类的方法(函数)成员</li></ol><p><strong>改写的具体有如下</strong>：<br>对于如下方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CGoods::RegisterGoods</span><span class="params">(<span class="keyword">char</span> name[], <span class="keyword">int</span> amount, <span class="keyword">float</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(Name, name);</span><br><span class="line">Amount = amount;</span><br><span class="line">Price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会改写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CGoods::RegisterGoods</span><span class="params">(CGoods *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">char</span> name[],<span class="keyword">int</span> amount,<span class="keyword">float</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;Name, name);</span><br><span class="line"><span class="keyword">this</span>-&gt;Amount = amount;</span><br><span class="line"><span class="keyword">this</span>-&gt;Price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类里面识别到的属性和类成员函数属性同名时，就会加上this指针，这是编译器编译时自动加的，我们也可以手动加，编译时系统就不给你加了</p><p>在主函数中调用类的成员函数时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CGoods x;</span><br><span class="line">CGoods y;</span><br><span class="line">x.RegisterGoods(<span class="string">"C++"</span>,<span class="number">16</span>,<span class="number">94</span>);</span><br><span class="line">y.RegisterGoods(<span class="string">"Java"</span>,<span class="number">10</span>,<span class="number">88</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的那两句就等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RegisterGoods(&amp;x,<span class="string">"C++"</span>,<span class="number">16</span>,<span class="number">94</span>);</span><br><span class="line">RegisterGoods(&amp;y,<span class="string">"Java"</span>,<span class="number">10</span>,<span class="number">88</span>);</span><br></pre></td></tr></table></figure><p>这样，通过this指针就解决了上述的问题：“ 不同的对象有各自的属性，但是方法都是同一个方法，那么方法是怎么区别它操纵的到底是哪个对象的数据呢 ”</p><p><strong>下面给出this指针的基本定义</strong>：</p><p>this指针是类的一个自动生成、自动隐藏的私有成员，它存在于类的非静态成员函数中，指向被调用函数所在的对象。全局仅有一个this指针，当一个对象被创建时，this指针就存放指向对象数据的首地址。</p><p><font color='blue'>每一个对象都隐式包含一个指针，指向对象自身。当对象调用成员函数时，会默认将对象自身传递给该函数，在函数体内不直接使用该对象名，而是使用this指针，即this指针指向该对象自身，即指向调用者</font></p><h2 id="内联函数">内联函数</h2><hr><p>直接在类内定义的函数或用inline关键字修饰的定义在类外的函数称为内联函数，内联函数在调用时直接拷贝一份过去，提高了效率，以空间换时间</p><p>如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方，因而对内联函数进行任何修改，都需要重新编译函数的所有客户端</p><p>inline关键字只是给编译器内联的建议，至于会不会真的内联，编译器会根据函数具体规模权衡时间空间效率之后选择是否内联</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-：C、C-区别</title>
      <link href="/2020/10/24/C-%EF%BC%9AC%E3%80%81C-%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/10/24/C-%EF%BC%9AC%E3%80%81C-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-输入、输出">1. 输入、输出</h2><p><strong>C语言</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件：<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">输入：<span class="built_in">scanf</span></span><br><span class="line">输出：<span class="built_in">printf</span></span><br></pre></td></tr></table></figure><p><strong>C++</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">头文件：<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  <span class="comment">//打开std命名空间</span></span><br><span class="line">输入：<span class="built_in">cin</span>  <span class="comment">//预定义好的输入流对象名，与提取运算符 &gt;&gt; 配合使用，从键盘上提取</span></span><br><span class="line">输出：<span class="built_in">cout</span> <span class="comment">//预定义好的输出流对象名，与流插入运算符 &lt;&lt; 配合使用, 换行使用endl</span></span><br></pre></td></tr></table></figure><p><strong>cin与scanf的区别</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>是格式化输入函数，<span class="built_in">cin</span>是标准化输入流对象，<span class="built_in">scanf</span>对类型有要求，<span class="built_in">cin</span>不区分类型</span><br><span class="line">例:<span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %c"</span>,&amp;a,&amp;ch); </span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;ch;</span><br><span class="line">注意：<span class="built_in">cin</span>不允许<span class="built_in">cin</span>&gt;&gt;a,ch，必须每一个变量前都要有提取符&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="2-常量的区别">2. 常量的区别</h2><p><strong>C语言</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14  <span class="comment">//宏常量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">enum</span> &#123;LEN = <span class="number">10</span>&#125;; <span class="comment">//枚举常量</span></span><br></pre></td></tr></table></figure><p><strong>C++</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">10</span>; <span class="comment">//常变量</span></span><br></pre></td></tr></table></figure><p><strong>define与const区别</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define 定义的是宏常量</span><br><span class="line"><span class="number">1.</span> 宏常量在预编译的时候进行替换</span><br><span class="line"><span class="number">2.</span> 宏常量不分配空间</span><br><span class="line"><span class="number">3.</span> 宏常量并没有类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> 修饰的是常变量</span><br><span class="line"><span class="number">1.</span> 常变量在编译时进行替换</span><br><span class="line"><span class="number">2.</span> 常变量分配空间</span><br><span class="line"><span class="number">3.</span> 常变量会有类型的检查</span><br></pre></td></tr></table></figure><p><strong>const在编译时进行替换例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line">b = a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" b = "</span> &lt;&lt; b &lt;&lt; <span class="string">" *p = "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201024135731210.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102413595070.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>常变量与宏有一拼，常变量在编译阶段进行替换，宏在预编译时替换</p><h2 id="3-引用">3. 引用</h2><blockquote><p>&amp;的使用：</p><ol><li>数字之间：位运算与 : 1 &amp; 0 --&gt; 0</li><li>变量名前取地址：&amp;a</li><li>类型与标识符中间：引用:  int &amp;c = a;</li></ol></blockquote><p><strong>引用&amp;</strong>：就是别名/外号, 一旦引用初始化为某个变量，就可以使用引用名称直接使用该变量，就是给该变量起了个别名</p><p><strong>引用的特点</strong>：</p><ol><li>没有空引用</li><li>定义引用时必须进行初始化</li><li>没有二级引用</li></ol><p><strong>引用的使用</strong>：</p><p>C语言使用指针交换a，b</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_c</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = *pa;</span><br><span class="line">*pa = *pb;</span><br><span class="line">*pb = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++使用引用交换a，b</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_cpp</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><span class="comment">//在函数中对a，b的交换，就是对实参的交换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C中使用指针间接交换了a，b；而C++使用引用直接操纵实参进行了交换</p><h2 id="4-函数重载">4. 函数重载</h2><p>C语言通过函数名来区分函数，重载函数在c中编译是通不过的</p><p>C++支持函数的重载，可以用来作为重载函数的依据有：</p><ol><li>参数类型不同</li><li>参数个数不同</li></ol><p>注意：<strong>函数的返回值不能区分重载函数</strong>，因为编译器不能通过函数返回值来识别调用哪一个函数，现有的编译器无法达到对返回类型的识别</p><h2 id="5-默认形参">5. 默认形参</h2><p>C++函数的形参可以带默认值，参数列表的默认值<strong>从右向左依次给</strong>，不能跳着给</p><p>调用函数时，实参是从左向右依次给，不能跳着给</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fun(<span class="number">12</span>,<span class="number">23</span>);<span class="comment">//给实际参数的时候是从左向右依次给，不能跳着给</span></span><br><span class="line"><span class="comment">//fun(12, ,33);错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-堆区开辟空间">6. 堆区开辟空间</h2><p><strong>C语言</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p><strong>C++</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *s = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//开辟一个整型空间</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);<span class="comment">//开辟并初始化</span></span><br><span class="line"><span class="keyword">delete</span> s;</span><br></pre></td></tr></table></figure><p>开辟数组空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);<span class="comment">//C语言</span></span><br><span class="line"><span class="keyword">int</span> *s = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//C++</span></span><br><span class="line"><span class="keyword">int</span> *t = <span class="keyword">new</span> <span class="keyword">int</span>[n](<span class="number">100</span>);<span class="comment">//开辟并初始化，C99标准</span></span><br><span class="line"><span class="built_in">free</span>(p); p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> []s;</span><br><span class="line"><span class="keyword">delete</span> []t;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：大数据问题的处理——散列、堆排</title>
      <link href="/2020/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%A3%E5%88%97%E3%80%81%E5%A0%86%E6%8E%92/"/>
      <url>/2020/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E6%95%A3%E5%88%97%E3%80%81%E5%A0%86%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1>题目引出</h1><hr><blockquote><p>在文件中产生10 0000个随机数字，数字的取值范围0~32767，按如下要求实现，在实现过程中能够使用的数组最长为10000，个别变量的内存忽略</p><ol><li>找到重复次数最多的那个数字(如果有多个，选择任意一个)</li><li>找到重复次数最多的前100个</li></ol></blockquote><h1>算法思路</h1><hr><p><strong>第一问</strong>：找到重复次数最多的那个数字(如果有多个，选择任意一个)</p><ol><li>首先用文件产生十万个随机数字</li><li>遍历这十万个数据，开辟一个数组充当计数器，因为题目要求能够使用的数组最长为一万，且数据取值范围到32767，因而要把十万个数据分组统计，每一组的个数不超过10000个，<font color='red'>由于分组的结果不能影响最后统计数字次数的结果，因而不能直接一刀切分组，要进行散列分组(即哈希，可对4取余利用余数分组)</font>，分别存入四个文件(哈希文件)，第一个哈希文件是对4取余余数为0的数，第二个哈希文件是对4取余余数为1的数…</li><li>分别找到每个哈希文件中次数最多的数字，进而求得四个文件中数字次数的冠军</li></ol><p><strong>第二问</strong>：找到重复次数最多的前100个</p><ol><li>对每个哈希文件进行堆排序，得到每个文件中重复次数最多的前100个</li><li>再综合这四百个数字，得到次数排名前100</li></ol><h1>具体实现</h1><hr><h2 id="宏定义">宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 100000  <span class="comment">//十万个随机数字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_NUM 10000<span class="comment">//计数器大小为1万</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> //定义数对</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//数字</span></span><br><span class="line"><span class="keyword">int</span> times; <span class="comment">//次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一问：找到重复次数最多的那个数字">第一问：找到重复次数最多的那个数字</h2><h3 id="1-首先用文件产生十万个随机数字">1.首先用文件产生十万个随机数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBigFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span><span class="comment">//产生MAX_NUM个随机数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fw = fopen(path, <span class="string">"wb"</span>);</span><br><span class="line">assert(fw != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = rand();</span><br><span class="line">fwrite(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fw);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辅助函数：显示path路径文件里边的数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span><span class="comment">//显示path文件含有的数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line">assert(fr != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d  "</span>, tmp);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-统计一个hash文件中出现次数最多的数字">2.统计一个hash文件中出现次数最多的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pair <span class="title">HashFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(ITEM_NUM, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line">assert(arr != <span class="literal">NULL</span> &amp;&amp; fr != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//统计hash文件中每个数字出现的次数</span></span><br><span class="line"><span class="comment">//文件0：0,4,8-&gt;0,1,2  文件1：1,5,9-&gt;0,1,2  文件2：2,6,10-&gt;0,1,2  文件3：3,7,11-&gt;0,1,2  哈希函数y=x/4</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)<span class="comment">//(0,1,2,3)-&gt;0，即四个文件中最小的数字对应的计数器下标都是0</span></span><br><span class="line">&#123;</span><br><span class="line">arr[tmp / <span class="number">4</span>]++;<span class="comment">//hash函数 y = x/4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到次数最多的数字及次数 </span></span><br><span class="line">Pair pa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITEM_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pa.times &lt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line">pa.num = i * <span class="number">4</span> + tmp % <span class="number">4</span>; <span class="comment">//反推：0-&gt;(0,1,2,3)，i*4加该文件数字对4的余数</span></span><br><span class="line">pa.times = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fr);</span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line"><span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-统计文件中出现次数最多的数字">3.统计文件中出现次数最多的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pair <span class="title">MaxTimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//生成四个不同的文件名</span></span><br><span class="line"><span class="keyword">char</span> pathArr[<span class="number">4</span>][<span class="number">20</span>];<span class="comment">//四个文件名，0.txt  1.txt  2.txt  3.txt</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//批量生成文件名</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(pathArr[i], <span class="string">"%d.txt"</span>, i);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//定义四个hash文件并打开</span></span><br><span class="line">FILE *fw[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fw[i] = fopen(pathArr[i], <span class="string">"wb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将原来的数据散列到四个hash文件中</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fwrite(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fw[tmp % <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fclose(fw[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计每个hash文件中出现次数最多的数字</span></span><br><span class="line">Pair paArr[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">paArr[i] = HashFile(pathArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到四个里面次数最大的</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//保存次数最多的数据下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (paArr[index].times &lt; paArr[i].times)</span><br><span class="line">&#123;</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> paArr[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-主函数测试">4.主函数测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*path = <span class="string">"big.txt"</span>;</span><br><span class="line">CreateBigFile(path);</span><br><span class="line"></span><br><span class="line">Pair pa = MaxTimes(path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"十万个数据中重复次数最多的是：\n\n 数字=%d，次数=%d\n\n"</span>, pa.num, pa.times);</span><br><span class="line"><span class="comment">//Show(path);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201017205232765.png#pic_left" alt="在这里插入图片描述"></p><h3 id="5-散列生成的文件">5.散列生成的文件</h3><p><img src="https://img-blog.csdnimg.cn/20201017210751749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_left" alt="在这里插入图片描述"></p><h2 id="第二问：找到重复次数最多的前100个">第二问：找到重复次数最多的前100个</h2><h3 id="1-找每一个哈希文件中次数最多的前100名">1.找每一个哈希文件中次数最多的前100名</h3><p>注意：由于哈希，数字存放的位置和数字本身有映射关系，而排序的交换会破坏这种关系，所以数字本身和它的次数都得保存起来，因而计数器数组元素类型要改成结构体Pair类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计hash文件中出现次数最多的前100个数字，计数器限制为ITEM_NUM</span></span><br><span class="line"><span class="function">Pair *<span class="title">HashFile2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//arr 为ITEM_NUM长的int型数组，计数器  注意：数字存放的位置和数字本身有关系</span></span><br><span class="line"><span class="comment">//将arr改为元素类型为Pair的数组</span></span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line">Pair *arr = (Pair*)<span class="built_in">calloc</span>(ITEM_NUM ,  <span class="keyword">sizeof</span>(Pair));</span><br><span class="line">assert(fr != <span class="literal">NULL</span> &amp;&amp; arr!=<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//统计hash文件中每个数字出现的次数</span></span><br><span class="line"><span class="comment">//文件0：0,4,8-&gt;0,1,2  文件1：1,5,9-&gt;0,1,2  文件2：2,6,10-&gt;0,1,2  文件3：3,7,11-&gt;0,1,2  哈希函数y=x/4</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)<span class="comment">//(0,1,2,3)-&gt;0，即四个文件中最小的数字对应的计数器下标都是0</span></span><br><span class="line">&#123;</span><br><span class="line">arr[tmp / <span class="number">4</span>].num = tmp;</span><br><span class="line">arr[tmp / <span class="number">4</span>].times++;<span class="comment">//hash函数 y = x/4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对arr数组按times递减排序, 排序选用堆排序，只需要得到前100个</span></span><br><span class="line">HeapSort(arr, ITEM_NUM);</span><br><span class="line">fclose(fr);</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在筛出的400个数据里找次数排名前100">2.在筛出的400个数据里找次数排名前100</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在筛出的400个数据里找次数前100的</span></span><br><span class="line"><span class="function">Pair * <span class="title">MaxTimes2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fr = fopen(path, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//生成四个不同的文件名</span></span><br><span class="line"><span class="keyword">char</span> pathArr[<span class="number">4</span>][<span class="number">20</span>];<span class="comment">//四个文件名，0.txt  1.txt  2.txt  3.txt</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//批量生成文件名</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(pathArr[i], <span class="string">"%d.txt"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义四个hash文件并打开</span></span><br><span class="line">FILE *fw[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fw[i] = fopen(pathArr[i], <span class="string">"wb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将原来的数据散列到四个hash文件中</span></span><br><span class="line"><span class="keyword">while</span> (fread(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fr) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fwrite(&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fw[tmp % <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fclose(fw[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计每个hash文件中出现次数的前100-----------</span></span><br><span class="line">Pair *arr[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = HashFile2(pathArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//400个里面找前100, 先把400个数对汇总到一起</span></span><br><span class="line">Pair *fourHundred = (Pair*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Pair) * <span class="number">400</span>);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">fourHundred[index++] = arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//汇总的400个数据进行递减式堆排</span></span><br><span class="line">HeapSort(fourHundred, <span class="number">400</span>);</span><br><span class="line"><span class="keyword">return</span> fourHundred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-附：递减式堆排代码-针对Pair类型">3.附：递减式堆排代码(针对Pair类型)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////// 递减式堆排序 //////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//一次堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(Pair *arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span><span class="comment">//start起始下标，end结尾下标，O(logn)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pair tmp = arr[start];</span><br><span class="line"><span class="keyword">int</span> parent = start;<span class="comment">//标记父节点下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= <span class="built_in">end</span>; i = <span class="number">2</span> * i + <span class="number">1</span>)<span class="comment">//i下一次要到它的左孩子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找左右孩子的较大值</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; arr[i].times &gt; arr[i + <span class="number">1</span>].times)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//i变为左右孩子较大值的下标</span></span><br><span class="line"><span class="keyword">if</span> (arr[i].times &lt; tmp.times)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//arr[(i - 1) / 2] = arr[i];//放到i的父节点</span></span><br><span class="line">arr[parent] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent = i;<span class="comment">//更新下一次i的父节点</span></span><br><span class="line">&#125;</span><br><span class="line">arr[parent] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(Pair *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(nlogn)，O(1)，不稳定(父子相互交换数据，父子下标是跳跃式的)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//建立大根堆，O(nlogn)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//len-1最后一个的下标，再减一除以二是它的父节点下标，从后往前多次调整</span></span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(arr, i, len - <span class="number">1</span>);<span class="comment">//每一个i都遍历到len-1作为end，因为即使有的没有len-1这个子节点，也不影响，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次将根和待排序最后的值交换，然后再调整,O(nlogn)</span></span><br><span class="line">Pair tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[len - <span class="number">1</span> - i];</span><br><span class="line">arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line"></span><br><span class="line">HeapAdjust(arr, <span class="number">0</span>, len - <span class="number">2</span> - i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-主函数测试：">4.主函数测试：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*path = <span class="string">"big.txt"</span>;</span><br><span class="line">CreateBigFile(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一问</span></span><br><span class="line">Pair pa = MaxTimes(path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"十万个数据中重复次数最多的是：\n\n 数字=%d，次数=%d\n\n"</span>, pa.num, pa.times);</span><br><span class="line"><span class="comment">//Show(path);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二问</span></span><br><span class="line">Pair *pa2 = MaxTimes2(path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"重复数字最多的前100个：\n\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d %d)  "</span>, pa2[i].num, pa2[i].times);</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201017232146157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><h2 id="总结">总结</h2><hr><p>对于上述问题，其实主要就干了三件事</p><ol><li><font color='red'>对大文件散列(哈希)，得到多个哈希文件</font></li><li><font color='red'>再得到每个哈希文件中次数最多的数字</font></li><li><font color='red'>得到所有文件中重复次数最多的数字</font></li></ol><p>对于处理类似数据多而可用内存少的大数据问题，核心思想就是<font color='red'><strong>先哈希, 再堆排</strong></font></p><hr><h1>海量数据问题</h1><hr><p>海量数据处理，就是基于海量数据上的存储、处理、操作。海量数据问题，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。</p><h2 id="处理海量问题的基本思路">处理海量问题的基本思路</h2><ol><li>分而治之/hash映射 + hash统计 +堆/快速/归并排序；</li><li>双层桶划分</li><li>Bloom filter/Bitmap；</li><li>Trie树/数据库/倒排索引；</li><li>外排序；</li><li>分布式处理之Hadoop/Mapreduce。</li></ol><h2 id="例1：海量日志数据，提取出某日访问百度次数最多的那个IP">例1：海量日志数据，提取出某日访问百度次数最多的那个IP</h2><p><strong>算法思想：分而治之+Hash</strong></p><ol><li>IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理</li><li>可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址</li><li>对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址</li><li>可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP</li></ol><h2 id="例2：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节">例2：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节</h2><p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p><strong>基本思想：哈希+堆排</strong></p><ul><li>先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计</li><li>借助堆这个数据结构，找出Top K，时间复杂度为N‘logK</li></ul><p>即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）</p><h2 id="例3：有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词">例3：有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</h2><p><strong>基本思想：哈希+堆排+归并</strong></p><ul><li>顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右</li><li>如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M</li><li>对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件</li><li>把这5000个文件进行归并，得到所有中频数最高的前100个单词</li></ul><h2 id="总结-2">总结</h2><hr><p>大数据问题的处理：<font color='red'><strong>哈希+堆排</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：排序算法汇总</title>
      <link href="/2020/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2020/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="冒泡排序-Bubble-Sort">冒泡排序(Bubble Sort)</h2><hr><p><strong>算法思路</strong>：依次比较两个相邻的元素，大的往后，小的往前，每一趟比较都把最大的元素放到末尾，越小的元素会经由交换慢慢“浮”到数列的顶端，因而称之为冒泡排序</p><p><strong>时间复杂度</strong>：O(n^2）</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：冒泡排序的比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定</strong>排序算法</p><p><strong>冒泡排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20200921173942278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200921171828440.gif#pic_center" alt="冒泡排序"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span>  <span class="comment">//冒泡排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//两两比较，小的往前，大的往后，每一趟把最大的放到最后</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">1</span>&lt; len - i ; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序-Selection-Sort">选择排序(Selection Sort)</h2><hr><p><strong>算法思路</strong>：第一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小元素，然后放到已排序的序列的末尾，即<strong>每次从待排序数据中选个&quot;最小值&quot;和&quot;第一个交换&quot;</strong></p><p><strong>时间复杂度</strong>：O(n^2)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定，有跳跃式地交换数据，例：序列5 8 5 2 9，第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法</p><p><strong>选择排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20200921180226635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200921180311930.gif#pic_center" alt="在这里插入图片描述"><br><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span>  <span class="comment">//选择排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//每一趟选出最小的放到最前面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minindex;  <span class="comment">//保存最小值的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">minindex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i +<span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[minindex])</span><br><span class="line">&#123;</span><br><span class="line">minindex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//选出来的最小值与“第一个”进行交换</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">tmp = arr[i];</span><br><span class="line">arr[i] = arr[minindex];</span><br><span class="line">arr[minindex] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="直接-插入排序-Insertion-Sort">(直接)插入排序(Insertion Sort)</h2><hr><p><strong>算法思路</strong>：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。即将待排序数据看成两个部分，左边部分为已经排序好的数据，右部分为待排序数据，从右边的数据中取一个数，插入到左边的合适位置使左边部分始终保持有序</p><p><strong>时间复杂度</strong>：最坏O(n^2)，最好O(n)，平均O(n^2)<br><font color='red'>插入排序待排序数列越有序越快，完全有序时间复杂度为O(n) </font></p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：稳定</p><p><strong>插入排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20200921183352227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200921183444857.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="comment">//每次从右部分取出一个插入到左边的合适位置</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)<span class="comment">//遍历右部分</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)<span class="comment">//j是左部分数列游标</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= arr[j])<span class="comment">//右边取出的大于左边的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//右边取出的小于左边的</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];<span class="comment">//左部分数列后移</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>] = tmp;<span class="comment">//把右边取出的那个数插入到左边的合适位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="希尔排序-Shell-Sort">希尔排序(Shell Sort)</h2><hr><p><strong>希尔排序</strong>：是插入排序的一种，又称缩小增量排序，是直接插入排序的一种更高效的改进版本。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li><p>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</p></li><li><p>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p></li></ul><p>希尔排序与插入排序的不同之处在于，<strong>它会通过设定带间隔的分组</strong>，优先比较距离较远的元素（同时破坏了稳定性）</p><p><strong>算法思路</strong>：定义一个间隔序列来表示排序过程中进行比较的元素之间有多远的间隔，每次将具有相同间隔的数分为一组，进行插入排序，最后一个分组组数必须是1，当最后一组执行完插入排序，排序结束</p><p><strong>时间复杂度</strong>：O(n^1.3)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定</p><p><strong>希尔排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/2020092423523516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200924235318162.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shell</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len,<span class="keyword">int</span> gap)</span><span class="comment">//每一个分组的排序 ,gap是分组的间隔</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (i = gap; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span>; j-=gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j + gap] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[j + gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span>  <span class="comment">//希尔排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d[] = &#123; <span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span> &#125;;<span class="comment">//设定分组的序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(d) / <span class="keyword">sizeof</span>(d[<span class="number">0</span>]); i++)<span class="comment">//按设定的分组间隔依次分组排序</span></span><br><span class="line">&#123;</span><br><span class="line">Shell(arr, len, d[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充</strong>：关于希尔排序的增量与复杂度的关系</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20200924235954641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></blockquote><hr><h2 id="快速排序-Quick-Sort">快速排序(Quick Sort)</h2><hr><p><strong>算法思路</strong>：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的</p><ul><li>在待排序数据中选取一个数据作为基准(可选择第一个数据)</li><li>使用基准数据将剩余的数据分成两部分，左部分（不一定有序）都比基准小，右部分（不一定有序）都比基准大</li><li>分别再对左部分和右部分（至少有两个数据）进行快速排序（递归）</li></ul><p><strong>时间复杂度</strong>：O(nlogn)，如果数列本来就有序，则快排退化为选择排序，时间复杂度退为O(n^2)，快排越有序越慢，因为选好基准数据后，它是从后往前依次找比基准数据小的数据</p><p><strong>空间复杂度</strong>：O(logn)，递归涉及到函数栈的开辟</p><p><strong>稳定性</strong>：不稳定</p><p><strong>快速排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201004111352387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201004125403870.gif#pic_center" alt="在这里插入图片描述"><br>（该动图每次把基准与数字进行交换，代码中是用tmp来保存基准，没有交换）</p><p><strong>C代码</strong>：三个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//快排的一次过程，把一个基准扣下来，从后往前找比它小的，从前往后找比它大的</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//QuickSort的中间层马甲</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排的一次划分，笔试的重点，low起始下标，high结尾下标</span></span><br><span class="line"><span class="comment">//把一个基准扣下来，从后往前找比它小的，从前往后找比它大的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//一次划分：O(n)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[low];<span class="comment">//基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从后往前找比基准小的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[high]&lt;tmp)<span class="comment">//找到比基准小的数字</span></span><br><span class="line">&#123;</span><br><span class="line">arr[low] =arr[high];<span class="comment">//将数字放到前面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前往后找比基准大的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high&amp;&amp;arr[low] &lt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">arr[high] = arr[low];<span class="comment">//将数字放到后面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[low] = tmp;<span class="comment">//基准应该放的位置</span></span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//返回基准放好的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//QuickSort的中间层马甲</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//递归次数为O(logn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = Partition(arr, low, high);</span><br><span class="line"><span class="keyword">if</span> (mid - low &gt; <span class="number">1</span>)<span class="comment">//左边的数据超过一个就要继续排序</span></span><br><span class="line">&#123;</span><br><span class="line">Quick(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (high - mid &gt; <span class="number">1</span>)<span class="comment">//右边的数据超过一个就要继续排序</span></span><br><span class="line">&#123;</span><br><span class="line">Quick(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装快排接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(n*logn)，O(logn)，不稳定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Quick(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的非递归实现</strong>：只用修改Quick函数即可，用栈将一次快排划分的左右下标保存起来，非递归的时间复杂度与空间复杂度同递归实现的数量级是一样的，但是在同样的数据量下，非递归实现对空间消耗的绝对值较小，非递归栈只保存两个下标，而递归实现涉及的是函数栈</p><p><strong>快排非递归C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><span class="comment">//一次划分：O(n)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[low];<span class="comment">//基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从后往前找比基准小的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[high]&lt;tmp)<span class="comment">//找到比基准小的数字</span></span><br><span class="line">&#123;</span><br><span class="line">arr[low] =arr[high];<span class="comment">//将数字放到前面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前往后找比基准大的数字</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high&amp;&amp;arr[low] &lt;= tmp)</span><br><span class="line">&#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">arr[high] = arr[low];<span class="comment">//将数字放到后面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[low] = tmp;<span class="comment">//基准应该放的位置</span></span><br><span class="line"><span class="keyword">return</span> low;<span class="comment">//返回基准放好的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排的非递归实现--------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack st;  <span class="comment">//栈用来保存每次快排的左下标与右下标</span></span><br><span class="line">InitStack(&amp;st);</span><br><span class="line">Push(&amp;st, low);</span><br><span class="line">Push(&amp;st, high);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;st))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> right;</span><br><span class="line">Pop(&amp;st, &amp;right);<span class="comment">//把high给right</span></span><br><span class="line"><span class="keyword">int</span> left;</span><br><span class="line">Pop(&amp;st, &amp;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = Partition(arr, left, right);<span class="comment">//mid就是一次快排返回的基准位置  left......mid......right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mid - left &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;st, left);</span><br><span class="line">Push(&amp;st, mid - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right - mid &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;st, mid + <span class="number">1</span>);</span><br><span class="line">Push(&amp;st, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Destory(&amp;st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装快排接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(n*logn)，O(logn)，不稳定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Quick2(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的优化</strong></p><blockquote><p>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p><ul><li>选择基准的方式：</li></ul><ol><li>固定位置，取序列的第一个或最后一个元素作为基准</li><li>随机选取基准</li><li>三位数取中，选取第一个、中间一个、最后一个数据排序取三者的中位数作为基准</li></ol></blockquote><blockquote><p>快排对于越有序的数列，其时间复杂度和空间复杂度都会增大，基于此可以进行优化。</p><ul><li>优化一： 当待排序序列的长度分割到一定大小后，使用插入排序。对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</li><li>优化二：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</li><li>优化三：优化递归操作</li><li>优化四：使用并行或多线程处理子序列</li><li>效率比较好的组合是：三数取中+插排+聚集相等元素</li></ul></blockquote><hr><h2 id="堆排序-Heap-Sort">堆排序(Heap Sort)</h2><hr><p><strong>预备知识</strong>：</p><blockquote><ul><li>完全二叉树：若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边，这就是完全二叉树</li><li>堆：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong>（父结点大于子结点）；或者每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong>（父结点小于子结点）</li><li><img src="https://img-blog.csdnimg.cn/20201005140431534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>大顶堆是一种逻辑结构，按层序遍历可映射为数组：<br><img src="https://img-blog.csdnimg.cn/20201005141300869.png#pic_center" alt="在这里插入图片描述"></li><li>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：<br>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]<br>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</li><li>对于完全二叉树，<strong>已知父结点下标i，则子结点下标2<em>i+1,2</em>i+2；已知子结点下标i，则父结点下标(i-1)/2</strong></li></ul></blockquote><p><strong>算法思路</strong>：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><ul><li>建立大顶堆（升序排序）</li><li>将堆顶元素与末尾元素交换，将最大元素放置在尾端</li><li>将去掉尾端元素剩下的继续调整为大顶堆，然后再将堆顶元素交换至末尾，再调整</li></ul><p>注意：建立大顶堆需要从后往前多次堆调整，而一次堆调整是从上往下比较的</p><p><strong>时间复杂度</strong>：O(nlogn)</p><p><strong>空间复杂度</strong>：O(1)</p><p><strong>稳定性</strong>：不稳定，跳跃式的交换数据</p><p><strong>堆排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201005143220893.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span><span class="comment">//start起始下标，end结尾下标，O(logn)，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[start];</span><br><span class="line"><span class="keyword">int</span> parent = start;<span class="comment">//标记父节点下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= <span class="built_in">end</span>; i = <span class="number">2</span> * i + <span class="number">1</span>)<span class="comment">//i下一次要到它的左孩子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找左右孩子的较大值</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="comment">//i变为左右孩子较大值的下标</span></span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//arr[(i - 1) / 2] = arr[i];//放到i的父节点</span></span><br><span class="line">arr[parent] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">parent = i;<span class="comment">//更新下一次i的父节点</span></span><br><span class="line">&#125;</span><br><span class="line">arr[parent] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(nlogn)，O(1)，不稳定(父子相互交换数据，父子下标是跳跃式的)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//建立大根堆，O(nlogn)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//len-1最后一个的下标，再减一除以二是它的父节点下标，从后往前多次调整</span></span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(arr, i, len - <span class="number">1</span>);<span class="comment">//每一个i都遍历到len-1作为end，因为即使有的没有len-1这个子节点，也不影响，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次将根和待排序最后的值交换，然后再调整,O(nlogn)</span></span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[len - <span class="number">1</span> - i];</span><br><span class="line">arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line"></span><br><span class="line">HeapAdjust(arr, <span class="number">0</span>, len - <span class="number">2</span> - i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="归并排序-Merge-Sort">归并排序(Merge Sort)</h2><hr><p><strong>算法思路</strong>：归并排序就是利用分治归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列，再两两归并，…，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为二路归并排序</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置，重复该步骤直到某一指针超出序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><p><strong>时间复杂度</strong>：O(nlogn)</p><p><strong>空间复杂度</strong>：O(n)</p><p><strong>稳定性</strong>：稳定，没有交换数据，归并排序是一种比较占用内存，但却效率高且稳定的排序算法</p><p><strong>归并排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201005192958335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201005192600741.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> gap)</span><span class="comment">//gap归并段的长度，O(n)，O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low1 = <span class="number">0</span>;<span class="comment">//第一个归并段的起始下标</span></span><br><span class="line"><span class="keyword">int</span> high1 = gap - <span class="number">1</span>;<span class="comment">//第一个归并段的结束下标</span></span><br><span class="line"><span class="keyword">int</span> low2 = high1+<span class="number">1</span>;<span class="comment">//第二个归并段的起始下标</span></span><br><span class="line"><span class="keyword">int</span> high2 = low2 + gap &lt; len ? low2 + gap - <span class="number">1</span> : len - <span class="number">1</span>;<span class="comment">//第二个归并段的结束下标</span></span><br><span class="line"><span class="keyword">int</span> *brr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//brr的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low2 &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两个归并段都有数据就要进行归并</span></span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[low1] &lt;= arr[low2])</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个归并段的数据已经完成，另一个还有数据</span></span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1)</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (low2 &lt;= high2)</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入到下一块的归并</span></span><br><span class="line">low1 = high2 + <span class="number">1</span>;</span><br><span class="line">high1 = low1 + gap - <span class="number">1</span>;</span><br><span class="line">low2 = high1 + <span class="number">1</span>;</span><br><span class="line">high2 = low2 + gap &lt; len ? low2 + gap - <span class="number">1</span> : len - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打单的段</span></span><br><span class="line"><span class="keyword">while</span> (low1 &lt; len)</span><br><span class="line">&#123;</span><br><span class="line">brr[i++] = arr[low1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = brr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(brr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span><span class="comment">//O(nlogn)，O(n)，稳定(没有交换数据)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>)<span class="comment">//O(logn)</span></span><br><span class="line">&#123;</span><br><span class="line">Merge(arr, len, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="基数排序-Radix-Sort">基数排序(Radix Sort)</h2><hr><p><strong>算法思路</strong>：基数排序是一种非比较型排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较，基数排序属于“分配式排序”，又称“桶子法”（bucket sort）或bin sort，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用（低位优先，多关键字排序）</p><ul><li>首先取得待排序数列中的最大值，其位数就是进出的趟数</li><li>根据每个数的低位关键字将数字分配至不同的桶中</li><li>各个桶依次出尽数据组成新的队列，再根据下一个低位关键字入队列、出队列，如此反复直至所有位均已完毕，数列便有序</li></ul><p><strong>时间复杂度</strong>：O(d*n)，d是待排序数列最大值的位数</p><p><strong>空间复杂度</strong>：O(n)</p><p><strong>稳定性</strong>：稳定</p><p><strong>基数排序示意图</strong>：<br><img src="https://img-blog.csdnimg.cn/20201006161123509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201006153507672.gif#pic_center" alt="在这里插入图片描述"></p><p><strong>C代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////  基数排序需要用到的链式队列  //////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Node *front;<span class="comment">//队头</span></span><br><span class="line">Node *rear;<span class="comment">//队尾</span></span><br><span class="line">&#125;HNode,*Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(q != <span class="literal">NULL</span>);</span><br><span class="line">q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Queue q, <span class="keyword">int</span> val)</span><span class="comment">//入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p-&gt;data = val;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsEmpty(q))</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;front = p;</span><br><span class="line">q-&gt;rear = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;rear-&gt;next = p;</span><br><span class="line">q-&gt;rear = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(Queue q, <span class="keyword">int</span> *rtval)</span><span class="comment">//出队列获取队头的值，且删除队头</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (IsEmpty(q))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rtval != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*rtval = q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">Node *p = q-&gt;front;</span><br><span class="line">q-&gt;front = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)<span class="comment">//刚才删除的是最后一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////  基数排序  //////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取十进制数字的位数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125; <span class="keyword">while</span> (n != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到十进制num右数第n位的数字(从0开始)，例：(123,0)-&gt;3, (123,1)-&gt;2, (123,2)-&gt;1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Key</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span><span class="comment">//得到当前数的关键字（此时该入的对列）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//不停的丢个位数字</span></span><br><span class="line">&#123;</span><br><span class="line">num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一趟的具体进出，利用链式队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Radix</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> n)</span><span class="comment">//n是十进制右数第几位，0个位，1十位，2百位...</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HNode qrr[<span class="number">10</span>];<span class="comment">//10个队列的队头结点</span></span><br><span class="line"><span class="keyword">int</span> k;<span class="comment">//需要进的队列的编号/关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">//初始化队列</span></span><br><span class="line">&#123;</span><br><span class="line">InitQueue(&amp;qrr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">k = Key(arr[i], n);<span class="comment">//获取该入的队列编号</span></span><br><span class="line">Push(&amp;qrr[k], arr[i]);<span class="comment">//arr[i]放入k号对列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，10个队列依次全出</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//arr下标，出的数据要放入arr中去</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;qrr[j]))<span class="comment">//只要当前队列不为空，就要一直出数据</span></span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;qrr[j], &amp;arr[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> <span class="comment">//O(d*n)，d是最大值的位数，O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//首先找到最大值</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; arr[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到进队和出队的趟数，即最大值的位数</span></span><br><span class="line"><span class="keyword">int</span> n= GetDigit(<span class="built_in">max</span>);</span><br><span class="line"><span class="comment">//进出n趟</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">Radix(arr, len, i);<span class="comment">//i是每一趟进出的关键字</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////  基数排序以上  ////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结">总结</h2><hr><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.3)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(d*n)</td><td>O(d*n)</td><td>O(n)</td><td>稳定</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：栈的应用—中缀表达式转后缀表达式、后缀表达式的运算</title>
      <link href="/2020/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="后缀（逆波兰）表达式">后缀（逆波兰）表达式</h2><p><strong>中缀表达式</strong>：就是我们平时用的标准四则运算表达式，运算符在操作数中间，例如：9+（3-1）*3+10/2</p><p><strong>后缀表达式</strong>：也称为逆波兰表达式，是将运算符写在操作数之后的表达式，例如上式的后缀表达式为：9 3 1 - 3 * + 10 2 / +</p><p><strong>作用</strong>：对计算机而言，中缀表达式是比较复杂的结构，而逆波兰式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构，它执行先进后出的顺序</p><hr><h2 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h2><p><strong>例</strong>：中缀表达式 <font color='red'>9+（3-1）*3+10/2 </font>转换为后缀表达式 <font color='red'>9 3 1 - 3 * + 10 2 / +</font></p><p><strong>人眼观察方法</strong>：因为a + b 转为后缀表达式是 a b +，先在表达式中找最先运算的子式转成后缀表达式，如下图要先算3-1，转后缀为31-，再把31-看为一个整体A，则接下来运算A * 3,转为后缀即为A 3 *,即3 1 - 3 *，依次类推就可推出最终转成的后缀表达式为9 3 1 - 3 * + 10 2 / +<br><img src="https://img-blog.csdnimg.cn/20200928172718270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>程序算法思路</strong>：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止，总结如下：<br><img src="https://img-blog.csdnimg.cn/20200903125326214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>详细过程如下</strong>： <font color='red'>9+（3-1）*3+10/2 </font>转换为后缀表达式 <font color='red'>9 3 1 - 3 * + 10 2 / +</font></p><ol><li><p>初始化一空栈，用来对符号进出栈使用，如下图左侧</p></li><li><p>第一个是数字9，直接输出，后面是符号+，进栈，如下图右侧<img src="https://img-blog.csdnimg.cn/2020090311211026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>第三个字符是（，左括号还未配对，入栈，如下图左侧</p></li><li><p>第四个字符是数字3，直接输出，总表达式为9 3，接着是-，进栈，如下图右侧<img src="https://img-blog.csdnimg.cn/2020090311234826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>接下来是数字1，输出，总表达式为9 3 1，后面是），此时，要去匹配之前的左括号，所以栈顶依次输出，直到（出栈。总的表达式现在为9 3 1 -，栈中剩下+，如下图左侧</p></li><li><p>紧接着是*，因为此时栈顶为+号，优先级低于乘号，因此不输出，乘号进栈，接着是数字3，输出，总表达式为9 3 1 - 3，如下图右侧<img src="https://img-blog.csdnimg.cn/20200903112719488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>之后是+，此时栈顶为乘号，栈顶优先级高，因此栈中元素出栈并输出（没有比+更低的优先级，所以全部出栈），总输出表达式9 3 1 - 3 * +。然后将当前这个符号+进栈，如下图左侧</p></li><li><p>紧接着是数字10，直接输出，总表达式变为9 3 1 - 3 * + 10。然后是/ ,栈顶+优先级低于除号，/进栈，如下图右侧<img src="https://img-blog.csdnimg.cn/20200903113358503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>接下来是最后一个数字2，输出，表达式为9 3 1 - 3 * +10 2，如下图左侧</p></li><li><p>中缀表达式遍历结束，将栈中符号依次全部出栈并输出，最后输出的后缀表达式为：9 3 1 - 3 * +10 2 / + <img src="https://img-blog.csdnimg.cn/20200903113623733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ol><p><strong>C代码如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中缀表达式转后缀表达式</span></span><br><span class="line"><span class="comment">//中缀表达式存储在字符串中，为便于表示，代码使用9+(3-1)*3+8/2为例子</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack s;</span><br><span class="line">InitStack(&amp;s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> mid[] = <span class="string">"9+(3-1)*3+8/2"</span>;  <span class="comment">//中缀表达式</span></span><br><span class="line"><span class="keyword">char</span> back[<span class="number">14</span>];  <span class="comment">//后缀表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> useless;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid[i] &lt;= <span class="string">'9'</span>&amp;&amp;mid[i] &gt;= <span class="string">'0'</span>)  <span class="comment">//是数字，直接输出</span></span><br><span class="line">&#123;</span><br><span class="line">back[j] = mid[i];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">'('</span>)  <span class="comment">//是左括号，直接入栈</span></span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;s, mid[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">')'</span>)  <span class="comment">//是右括号，栈中出栈直到第一个左括号出栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (GetTop(&amp;s) != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">Pop(&amp;s, &amp;useless);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">'*'</span> || mid[i] == <span class="string">'/'</span>)  <span class="comment">//是*/，出栈，直到栈空或者栈中遇到左括号或+-，当前符号入栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;s) &amp;&amp; (GetTop(&amp;s) != <span class="string">'+'</span> &amp;&amp; GetTop(&amp;s) != <span class="string">'-'</span>))</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">Push(&amp;s, mid[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid[i] == <span class="string">'+'</span> || mid[i] == <span class="string">'-'</span>)  <span class="comment">//是+-，出栈，直到栈空或者左括号当前符号入栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;s)&amp;&amp;GetTop(&amp;s) != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">Push(&amp;s, mid[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中缀表达式遍历结束，要将栈中剩余符号依次弹出</span></span><br><span class="line"><span class="keyword">while</span> (!IsEmpty(&amp;s))</span><br><span class="line">&#123;</span><br><span class="line">Pop(&amp;s, &amp;back[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">back[j] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"中缀表达式： %s\n\n"</span>, mid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"后缀表达式： %s\n\n"</span>, back);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：<br><img src="https://img-blog.csdnimg.cn/20200903145703175.png#pic_center" alt="在这里插入图片描述"></p><hr><h2 id="计算机如何用后缀表达式求值">计算机如何用后缀表达式求值</h2><p><strong>例如</strong>：中缀表达式 <font color='red'>9+（3-1）*3+10/2 </font>的后缀表达式 <font color='red'>9 3 1 - 3 * + 10 2 / +</font>，计算机如何用该后缀表达式进行运算呢</p><p><strong>规则</strong>：从左到右遍历<strong>后缀</strong>表达式的每个数字和符号，遇到数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果</p><p><strong>详细过程如下</strong>：<font color='red'><strong>9 3 1 - 3 * + 10 2 / +</strong></font></p><ol><li>初始化一个空栈，该栈用来对要运算的数字进出使用</li><li>后缀表达式中前三个都是数字，所以9 3 1依次进栈，如下图<br><img src="https://img-blog.csdnimg.cn/20200903104948554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>接下来是 - 运算符，所以将栈顶的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈，如下图左侧</li><li>接着是数字3进栈，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903105318923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>接下来是* ，也就意味着栈中3与2出栈，相乘得到6，再将6入栈，如下图左侧</li><li>再下来是+ ，将6与9出栈，相加得到15，再将15入栈，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903105625715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>接着是10与2两数字进栈，如下图左侧</li><li>接下来是/ ，因此栈顶的2与10出栈，10与2相除得到5，5入栈，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903105805650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>最后是运算符+ ，所以5与15出栈相加得到20，再将20进栈，如下图左侧</li><li>后缀表达式遍历结束，最后栈中结果是20出栈，栈变为空，计算结束，如下图右侧<br><img src="https://img-blog.csdnimg.cn/20200903110059180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ol><p>以上可以看出后缀表达式可以很顺利地解决计算问题，因此后缀表达式是很重要的</p><hr><p><strong>综上，要想让计算机拥有处理我们通常的标准（中缀）表达式的能力，最重要的是两大步</strong>：</p><ul><li><strong>将中缀表达式转换为后缀表达式（栈用来进出运算的符号）</strong></li><li><strong>将后缀表达式进行运算得到结果（栈用来进出运算的数字）</strong></li></ul><p><strong>上述过程充分利用了栈的后进先出特性，是栈这种数据结构比较重要的应用</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：BF算法-KMP算法</title>
      <link href="/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ABF%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ABF%E7%AE%97%E6%B3%95-KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="BF算法">BF算法</h2><hr><p>BF(Brute Force)算法，即暴力算法，是普通的串的模式匹配算法，BF算法是一种蛮力算法</p><p>BF算法的思想就是将目标串S(主串)的第一个字符与模式串T(子串)的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；<strong>若不相等，则比较S的第二个字符和T的第一个字符</strong>，依次比较下去，直到得出最后的匹配结果</p><p>BF算法效率并不高，因为每次没找到，主串都要回退到上一次开始的下一个位置</p><p><strong>BF算法时间复杂度O(m*n)      空间复杂度O(1)</strong></p><p>BF算法图解如下：<br><img src="https://img-blog.csdnimg.cn/20200921220553377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>C代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//返回 子串T 在 主串S 中第pos个字符之后的位置</span><br><span class="line">//时间复杂度：O(m*n) 空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">int BF(const char* S, const char *T,int pos)  //S主串，T子串</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S == NULL || T == NULL || pos &lt; 0 || pos &gt;= strlen(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i = pos;</span><br><span class="line">int j = 0;</span><br><span class="line">int len1 = strlen(S);//主串长度</span><br><span class="line">int len2 = strlen(T);//子串长度</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">/*回退到本次开始的下一个位置（i-j+1)，j回退到0*/</span><br><span class="line">i = i - j + 1;</span><br><span class="line">j = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &gt;= len2)  //子串走完即为查找成功</span><br><span class="line"><span class="built_in">return</span> i - j ;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BF算法的效率不高，时间复杂度<strong>O(m*n)</strong>，每次匹配失败主串游标 i 都要回退到本次开始的下一个位置，子串游标 j 要回退到0。而KMP算法改进了i，j的回退，避免了不必要的回溯，提高了效率，时间复杂度降到了<strong>O(m+n)</strong></p><h2 id="KMP算法">KMP算法</h2><hr><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，取他们姓首字母，即为KMP算法。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的</p><p><strong>KMP算法时间复杂度O(m+n) 空间复杂度O(n)</strong></p><p>在BF算法中，每次失配，主串游标 i 都要回退到 i-j+1，子串游标 j 要回退到0</p><p>但是其实在出现失配时，可以让 i 不回退，j 回退到该退的位置即可，如下图BF算法示意图中，第一次失配后，i 回溯到 i-j+1，j 回溯到0，但是我们可以发现之后的比较中，i 又回到了之前的位置，j 位置改变了而已（下图红框）</p><p><img src="https://img-blog.csdnimg.cn/20200921220852377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><font color='red'>KMP算法就是在出现失配时，让主串游标 i 不回退，利用之前失败的信息，让子串游标 j 退回到合适的位置</font></p><p>所以关键就是求出失配后子串游标 j 应该回溯的位置，我们用一个<strong>next数组</strong>来存储子串每个位置对应的 j 应该回溯的位置</p><p>把上面BF算法代码直接拷贝过来，修改 i,j 的回退即可完成KMP算法的大框架</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S, <span class="keyword">const</span> <span class="keyword">char</span> *T,<span class="keyword">int</span> pos)</span>  <span class="comment">//S主串，T子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span> || T == <span class="literal">NULL</span> || pos &lt; <span class="number">0</span> || pos &gt;= <span class="built_in">strlen</span>(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S);<span class="comment">//主串长度</span></span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(T);<span class="comment">//子串长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//修改i，j的回退</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//i不回退</span></span><br><span class="line"><span class="comment">//j要退到k</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j &gt;= len2)  <span class="comment">//子串走完即为查找成功</span></span><br><span class="line"><span class="keyword">return</span> i - j ;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的任务就是要把 j 回退的位置 k 给求出来，即求出next数组</p><hr><h2 id="求next数组">求next数组</h2><p><font color='green'>预备知识：字符串的前缀、后缀</font></p><blockquote><p>前缀：首字符开始的子串<br>真前缀：首字符开始的子串，但不包含原串本身<br>后缀：以尾字符结尾的子串<br>真后缀：以尾字符结尾的子串，但不包含原串本身<br>例：ababc<br>前缀：a、ab、aba、abab、ababc<br>真前缀：a、ab、aba、abab<br>后缀：c、bc、abc、babc、ababc<br>真后缀：c、bc、abc、babc</p></blockquote><p><strong>如下例中</strong><br><img src="https://img-blog.csdnimg.cn/20200922230942153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在 i 是4,j 是4时发生失配，但是我们发现<strong>失配前的S串真后缀与T串真前缀出现相等</strong>，<strong>相等的部分就不用比较了</strong>，因此直接从相等的后面开始继续比较就好（如下图），即<strong>j回溯到相等串的后面，即j下标变为相等串的长度</strong>，所以关键就是求每次失配这个相等串的长度 k</p><p>又因为第一次比较中，失配前的四个字符S串与T串都是一一对应相等的，因此S串的真后缀也是T串的真后缀，因此<font color='red'><strong>k就是T串失配前的串的真前缀与真后缀相等时的长度值</strong></font><br><img src="https://img-blog.csdnimg.cn/20200922233902750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因而求k值的方法就是：在子串失配前找到相等的真前缀与真后缀，其长度就是k或者可以这样描述：</p><blockquote><p>在子串失配前找到最长两个相等的真子串，这两个真子串满足如下特点：<br>1.一个串以首字符开头<br>2.另一个串以失配前的最后一个字符作为结尾<br>k就是该真子串的长度</p></blockquote><p>上例T串每个字符对应的k值如下：<br>规定：next[0]=-1,next[0]=0</p><table><thead><tr><th>模式串T串</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p><strong>注意</strong>：还有一种常用的next数组表示，next[0]放的是0，next[1]是1，后续每一个k值都比上表里的大1，但是算法思路都是一样的，二者皆可，为便于编码，这里采用next[0] = -1这种方法</p><p><strong>手动已经可以求出next数组的值了，接下来就是用程序具体求出next数组：</strong></p><ol><li>对于任意串都可以确定其next[0] = -1,next[1] = 0;</li><li>设next[j] = k，即下标 j 之前的串的真前缀与真后缀相等的长度为k，即P0…Pk-1 == Pj-k…Pj-1，求next[j+1]</li><li>情况一：若Pk == Pj，则P0…Pk-1Pk = Pj-k…Pj-1Pj，即j+1对应的真前缀与真后缀相等时的值是k+1，即next[j+1] = k+1</li><li>情况二：若Pk != Pj，如下图，把P0…Pk放到Pk…Pj下面来看，则<font color='red'><strong>又要用到之前的思想，主串游标j不动，子串游标k往回退到合适位置</strong></font>，而子串游标k回退的位置在之前已经求出来了，是next[k]，所以k回退到next[k]，即<font color='red'><strong>k=next[k]</font></strong>，之后Pk再与Pj比较，如此往复直到Pk==Pj或k回溯到-1，k回溯到-1说明没有相等的真前缀与真后缀，那么next[j+1]赋值为0即可，或者next[j+1]=k+1，这也是next数组的第一个k值放-1的好处<br><img src="https://img-blog.csdnimg.cn/20200927162838750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>next数组的C代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* T,<span class="keyword">int</span> * next)</span>  <span class="comment">//根据子串T获取它的next数组(用来存放所有的k值)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lenT = <span class="built_in">strlen</span>(T);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T[k] == T[j] || k == <span class="number">-1</span>  )<span class="comment">//Pk==Pj，k为-1就没必要回退了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next[j + 1] = k + 1;</span></span><br><span class="line"><span class="comment">j++;</span></span><br><span class="line"><span class="comment">k++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">next[++j] = next[++k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//Pk != Pj</span></span><br><span class="line">&#123;</span><br><span class="line">k = next[k];<span class="comment">//主串游标j不动，子串游标k往回退</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>至此，next数组已经求出，即主串游标不动、子串游标j回退的位置已经求出，最后把j = next[j]放入失配条件下，KMP算法就完成了，KMP算法全部的C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* T, <span class="keyword">int</span> * next)</span></span>;  <span class="comment">//声明获取next数组的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* S, <span class="keyword">const</span> <span class="keyword">char</span> *T, <span class="keyword">int</span> pos)</span>  <span class="comment">//S主串，T子串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span> || T == <span class="literal">NULL</span> || pos &lt; <span class="number">0</span> || pos &gt;= <span class="built_in">strlen</span>(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(S);<span class="comment">//主串长度</span></span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(T);<span class="comment">//子串长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len2 * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">GetNext(T, next);<span class="comment">//求next数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; len1&amp;&amp;j &lt; len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j] || j==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//i不回退</span></span><br><span class="line">j = next[j];<span class="comment">//j回退到k</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(next);</span><br><span class="line"><span class="keyword">if</span> (j &gt;= len2)  <span class="comment">//子串走完即为查找成功</span></span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* T, <span class="keyword">int</span> * next)</span>  <span class="comment">//根据子串T获取它的next数组(用来存放所有的k值)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lenT = <span class="built_in">strlen</span>(T);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; lenT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T[k] == T[j] || k == <span class="number">-1</span>)<span class="comment">//Pk==Pj，k为-1就没必要回退了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">next[j + 1] = k + 1;</span></span><br><span class="line"><span class="comment">j++;</span></span><br><span class="line"><span class="comment">k++;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">next[++j] = next[++k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//Pk != Pj</span></span><br><span class="line">&#123;</span><br><span class="line">k = next[k];<span class="comment">//主串游标j不动，子串游标k往回退</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：makefile</title>
      <link href="/2020/09/12/Linux%EF%BC%9Amakefile/"/>
      <url>/2020/09/12/Linux%EF%BC%9Amakefile/</url>
      
        <content type="html"><![CDATA[<h2 id="makefile是什么">makefile是什么</h2><p><strong>makefile</strong>： makefile是linux下对源文件的自动编译工具，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中， makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令</p><p><strong>make</strong>：make 是一个命令工具，是一个解释 makefile中指令的命令工具，makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率</p><h2 id="makefile文件">makefile文件</h2><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序，该文件名称必须为&quot;Makefile&quot;或&quot;makefile&quot;或&quot;GNUmakefile&quot;，如果使用了其他名称，则需要使用make命令-f或–file参数去指定，如&quot;make  -f  MakeLinux&quot;</p><p><strong>大多数make都支持&quot;makefile&quot;和&quot;Makefile&quot;这两者默认文件名，因而最好使用其作为文件名</strong></p><p><strong>makefile文件书写规则</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target:prerequisites</span><br><span class="line"><span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>==<strong>target</strong>是要生成的目标文件(Object File)，也可以是执行文件或一个标签==</p><p>==<strong>prerequisites</strong>就是要生成target所必须的先决文件==</p><p>==<strong>commnd</strong>就是由prerequisites生成target所需要的命令（Shell命令）==</p><p>注意：commnd前要用Tab缩进<br><img src="https://img-blog.csdnimg.cn/20200912100634310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中</p><p>makefile文件中，规则的书写顺序是很重要的，makefile中应该有一个最终目标，其他的目标都是被这个目标所连带出来的，要让make知道你的最终目标。makefile中<strong>第一条规则中的目标将被确立为最终的目标</strong>。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标</p><p>例如下图：(main是最终目标)<br><img src="https://img-blog.csdnimg.cn/20200912104615847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="使用变量">使用变量</h2><p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。就是以一组文字或符号等，来替换一些设置或一串保留的数据</p><p><img src="https://img-blog.csdnimg.cn/20200912104938917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>变量使用方式：</p><ul><li>==定义：用=进行定义==</li><li>==使用：$(变量名)==</li></ul><p>例如：上例中有5个.o文件，可以如下定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file=my_add.o my_sub.o my_mux.o\</span><br><span class="line"> my_div.o main.o</span><br></pre></td></tr></table></figure><p>反斜杠\是换行符的意思，以后用到这5个.o文件，使用$(file)即可</p><p>变量与环境变量的其他介绍请参考我的上一篇博客：<a href="https://blog.csdn.net/huifaguangdemao/article/details/108393856" target="_blank" rel="noopener">Linux：Shell、BASH以及Shell Script简介</a></p><h2 id="文件搜寻">文件搜寻</h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make自动去找</p><p>makefile中的特殊变量<strong>VPATH</strong>就是实现该功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了</p><p><strong>VPATH使用规则</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH=path1:path2</span><br></pre></td></tr></table></figure><p>上面指定了两个路径，路径之间用冒号：分隔</p><p>还可以使用make的关键字vpath设置文件搜索路径，vapth是全小写，不同于VPATH，vapth是关键字，VPATH是变量</p><p><strong>vpath使用规则</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vpath &lt;pattern&gt; &lt;directories&gt;  <span class="comment">#为符合模式&lt;pattern&gt;的文件指定搜索路径&lt;directories&gt;</span></span><br><span class="line"></span><br><span class="line">vpath&lt;pattern&gt;  <span class="comment">#清除符合模式&lt;pattern&gt;的文件的搜索目录</span></span><br><span class="line"></span><br><span class="line">vpath  <span class="comment">#清除所有已被设置好了的文件搜索目录</span></span><br></pre></td></tr></table></figure><p>例：vpath  %.c  path1表示指定.c文件的搜寻目录为path1，%表示匹配零或若干字符</p><h2 id="隐晦规则">隐晦规则</h2><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个.o文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令</p><p>只要make看到一个.o文件，它就会自动的把 .c文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c就会是whatever.o的依赖文件。并且 gcc -c whatever.c 也会被推导出来，这就是make的隐晦规则</p><p>根据隐晦规则与变量，刚开始的例子可以进行简化，如下图：<br><img src="https://img-blog.csdnimg.cn/20200912121303163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="引用其他的makefile">引用其他的makefile</h2><p>在maikefile文件中使用include关键字可以把别的makefile包含进来，被包含的文件会原模原样的放在当前文件的包含位置</p><p>include语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include file1 file2 file3</span><br></pre></td></tr></table></figure><p>file可以是当前操作系统Shell的文件格式，可以包含路径和通配符，也可是使用变量</p><h2 id="伪目标">伪目标</h2><p>makefile书写规则中的target也可以是一个伪目标，例如清除命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure><p>执行完rm *.o命令并不会生成一个clean文件，clean只是一个标签，形象地称其为伪目标</p><p>可以使用.PHONY来显示地指明一个目标是伪目标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：每个makefile中都应该写一个清空目标文件(.o和执行文件)的命令，以便于重编译和保持文件的清洁，不成文的规矩是——“clean从来都是放在文件的最后”，<strong>make会把makefile里出现的第一个target当作缺省target。其他的除非是生成缺省target需要,否则不会执行</strong>，因此该clean在make时并不会执行，要执行该clean命令，手动使用make clean命令来清除掉*.o文件</p><h2 id="make工作执行流程">make工作执行流程</h2><p>GNU的make工作时执行步骤如下：</p><ol><li>读入所有的makefile文件</li><li>读入被include的其他的makefile</li><li>初始化文件中的变量</li><li>推导隐晦规则，并分析所有规则</li><li>为所有的目标文件创建关系依赖链</li><li>根据依赖关系，决定哪些目标要重新生成</li><li>执行生成命令</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：gdb调试</title>
      <link href="/2020/09/06/Linux%EF%BC%9Agdb%E8%B0%83%E8%AF%95/"/>
      <url>/2020/09/06/Linux%EF%BC%9Agdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="gdb">gdb</h2><p>gdb（GNU debugger ）是GNU开源组织发布的一个强大的Linux下的程序调试工具，它可以：</p><ol><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时你的程序中所发生的事</li><li>可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG</li></ol><h2 id="Debug与Release">Debug与Release</h2><p>gdb调试的是可执行文件的Debug版本，这里简单提一下Debug版本与Release版本</p><p>生成的可执行文件可以有Debug版本和Release版本，gcc默认生成的是Release版本</p><p><strong>Debug版本</strong>：可调试的版本，它包含调试信息，并且不作任何优化，便于开发人员调试程序</p><p><strong>Release版本</strong>：发行版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用，它不可单步执行之类的</p><p>gcc默认生成的是Release版本，<strong>在编译时加上-g选项可以生成Debug版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g  源文件.c  -o  指定的文件名</span><br></pre></td></tr></table></figure><p>-g选项与-o选项缺一不可，如果是分步完成编译链接，-g选项必须加到编译阶段</p><p><img src="https://img-blog.csdnimg.cn/20200906110553866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="gdb的使用">gdb的使用</h2><h3 id="1、使用gdb打开文件">1、使用gdb打开文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb  debug版本的可执行文件  <span class="comment">#gdb后面跟的必须是debug版本的可执行文件，否则会报错</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906111045841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2、查看源码">2、查看源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list                <span class="comment">#list可以简写为l，用list默认查看main函数所在的代码</span></span><br><span class="line">list 源代码文件      <span class="comment">#查看指定文件的代码</span></span><br><span class="line">list 源代码文件:行数 <span class="comment">#查看指定文件指定行数周围10行的代码</span></span><br><span class="line">list 文件名:函数名   <span class="comment">#查看指定文件指定函数周围10行的代码</span></span><br><span class="line"><span class="comment">#命令一次只能显示十行，若想查看后面的源码可一直按回车键，直到所有源码显示完</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906112850896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="断点管理">断点管理</h2><h3 id="1、添加断点">1、添加断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b 行号  <span class="comment">#将断点添加到最近一次显示的文件的指定行</span></span><br><span class="line">b filename:行号  <span class="comment">#将断点添加到filename的指定行</span></span><br><span class="line">b functionname  <span class="comment">#将断点添加到指定函数的第一行</span></span><br><span class="line"><span class="comment">#b全称breakpoint</span></span><br></pre></td></tr></table></figure><h3 id="2、查看已有的断点的信息">2、查看已有的断点的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info <span class="built_in">break</span>  <span class="comment">#break可以简写为b</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906113348987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="3、删除断点">3、删除断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d 断点号  <span class="comment">#删除指定的断点</span></span><br></pre></td></tr></table></figure><h3 id="4、添加条件断点">4、添加条件断点</h3><p>这种断点是当满足一定条件时才会触发，比较适合进行异常排查</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> line-or-function <span class="keyword">if</span> (condition)</span><br><span class="line">b src/main.cpp:127 <span class="keyword">if</span> cnt==10</span><br></pre></td></tr></table></figure><h3 id="5、将断点设置为无效">5、将断点设置为无效</h3><p>将断点设置为无效并不会删除该断点，当需要时可以继续启用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> [breakpoints] [range...]  <span class="comment">#disable可以简写为dis</span></span><br></pre></td></tr></table></figure><p>breakpoints为断点号。 如果什么都不指定， 表示disable所有的停止点。 简写命令是dis</p><h3 id="6、恢复断点">6、恢复断点</h3><p>与disable对应的就是启用设置为无效的断点，即恢复断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enable</span> [breakpoints] [range...]</span><br><span class="line"><span class="built_in">enable</span> once [breakpoints]  <span class="comment">#仅仅恢复断点一次，当程序停止后， 该断点马上被GDB自动删除</span></span><br></pre></td></tr></table></figure><h2 id="执行流程控制">执行流程控制</h2><h3 id="1、启动调试，开始执行">1、启动调试，开始执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run  <span class="comment">#可以简写为r</span></span><br></pre></td></tr></table></figure><h3 id="2、单步执行">2、单步执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next  <span class="comment">#逐过程，简写为n    调用函数的语句中：n直接执行完函数继续执行</span></span><br><span class="line">step  <span class="comment">#逐语句，简写为s    s进入函数一句一句执行</span></span><br><span class="line">finish  <span class="comment">#直接将当前函数执行完成，退出到调用函数的下一条指令的位置</span></span><br></pre></td></tr></table></figure><h3 id="3、继续执行，直到下一个断点">3、继续执行，直到下一个断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure><h3 id="4、退出循环体">4、退出循环体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">until   <span class="comment">#简写为u</span></span><br></pre></td></tr></table></figure><h3 id="5、退出调试">5、退出调试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h2 id="程序变量">程序变量</h2><h3 id="查看变量的值">查看变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p valname</span><br><span class="line">p &amp;valname</span><br><span class="line">p 数组名  <span class="comment">#显示数组中所有元素的值</span></span><br><span class="line">p 数组指针  <span class="comment">#显示的是指针的值</span></span><br></pre></td></tr></table></figure><p>执行一次p显示一次，如果不执行p，则不会显示</p><h3 id="查看变量的类型">查看变量的类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptype valname</span><br></pre></td></tr></table></figure><h3 id="自动显示变量的值">自动显示变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display valname  <span class="comment">#每执行一次next或step，就显示一次</span></span><br></pre></td></tr></table></figure><h3 id="根据内存地址查看内存的存储值">根据内存地址查看内存的存储值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &lt;addr&gt;  <span class="comment">#&lt;addr&gt;表示一个内存地址</span></span><br></pre></td></tr></table></figure><h3 id="显示函数调用堆栈">显示函数调用堆栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt  <span class="comment">#打印当前的函数调用栈的所有信息</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200906133317813.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：Shell、BASH以及Shell-Script简介</title>
      <link href="/2020/09/04/Linux%EF%BC%9AShell%E3%80%81BASH%E4%BB%A5%E5%8F%8AShell-Script%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/09/04/Linux%EF%BC%9AShell%E3%80%81BASH%E4%BB%A5%E5%8F%8AShell-Script%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1>Shell</h1><h2 id="什么是Shell">什么是Shell</h2><p>Shell（壳程序）是系统的用户界面，提供了用户与内核进行相互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。</p><p><img src="https://img-blog.csdnimg.cn/20200904093431812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果</p><p>只要能够操作应用程序的软件都能够称为壳程序，<strong>狭义的壳程序指的是命令行方面的软件</strong>，如本文接下来介绍的BASH；广义的壳程序则包括图形用户界面模式的软件，因为图形用户界面其实也能够操作各种应用程序来调用内核工作</p><h1>BASH</h1><h2 id="什么是BASH">什么是BASH</h2><p>Shell根据发展有多种不同的版本，BASH就是其中一个版本，BASH(Bourne Again Shell)是Linux默认使用的版本</p><h2 id="Shell的变量功能">Shell的变量功能</h2><h3 id="变量">变量</h3><p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。就是以一组文字或符号等，来替换一些设置或一串保留的数据。<br><img src="https://img-blog.csdnimg.cn/20200904101958701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="环境变量">环境变量</h3><p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录（HOME）、邮件存放位置（MAIL）等。为了区别于自定义变量，环境变量通常以大写字符来表示</p><p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。如下图：<br><img src="https://img-blog.csdnimg.cn/20200904102900764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="变量的使用与设置：echo、-、unset">变量的使用与设置：echo、=、unset</h3><p><strong>echo</strong>：可以利用echo命令来使用变量，变量在被使用时，前面要加上美元符号$，例如：查看PATH变量的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904104430430.png#pic_center" alt="在这里插入图片描述"><br><strong>=</strong>：用=可以设置或是修改某个变量的内容，例如要把myname变量内容设置为WangGarrison，则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myname=WangGarrison</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904105347859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>变量在设置时，要符合某些规定，否则会设置失败，规则如下：</p><ol><li>变量与变量内容以一个=来连接</li><li>等号两边不能直接接空格</li><li>变量名称只能是英文字母与数字，且开头不能是数字</li><li>变量内容有空格可使用单引号或双引号将变量引起来</li></ol><p><strong>unset</strong>：unset可以取消变量，例如取消myname的设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> myname</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904110038428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="环境变量的功能">环境变量的功能</h3><p>环境变量可以帮我们实现很多功能，包括根目录（主文件夹）的变换、提示字符的显示、执行文件查找的路径等</p><p>可以用env与export命令来查看当前shell环境默认的环境变量，env是environment(环境)的简写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904122100733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Linux重要的10个环境变量如下表：</p><table><thead><tr><th>环境变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录</td></tr><tr><td>SHELL</td><td>用户使用的Shell解释器名称</td></tr><tr><td>PATH</td><td>执行文件查找的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本解释器</td></tr><tr><td>RANDOM</td><td>随机数的变量</td></tr><tr><td>LANG</td><td>语系数据</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>MAIL</td><td>邮件保存的路径</td></tr></tbody></table><p>使用set命令可以查看所有变量（含环境变量与自定义变量）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><h3 id="自定义变量转成环境变量">自定义变量转成环境变量</h3><p>自定义变量与环境变量的主要差别在于环境变量会被子进程所继续引用，而自定义变量不会，父进程与子进程相关性如下图：<br><img src="https://img-blog.csdnimg.cn/20200904124449575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>子进程仅仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量。所以原本bash的自定义变量在进入了子进程之后不能在子进程使用，直到子进程exit后才能继续使用</p><p>所以要想让父进程的自定义变量可以在子进程使用，则需要把自定义变量转换成环境变量，使用export命令进行转换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> 变量名称</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-export.html" target="_blank" rel="noopener">export命令的具体介绍</a></p><h3 id="变量键盘读取、数组与声明">变量键盘读取、数组与声明</h3><p><strong>read</strong>：用来读取来自键盘输入的变量，可用来与用户交互</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [-pt] variable  <span class="comment">#-p后面可以接提示字符   -t后面可以接等待的秒数</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200904155058786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>declare,typeset</strong>：declare或typeset是一样的功能，就是声明变量的类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> [-aixr] variable</span><br><span class="line">-a：将后面名为variable的变量定义成为数组（array）类型</span><br><span class="line">-i：将后面名为variable的变量定义成为整数（<span class="built_in">integer</span>）类型</span><br><span class="line">-x：用法与<span class="built_in">export</span>一样，就是将后面的variable变成环境变量</span><br><span class="line">-r：将变量设置成为<span class="built_in">readonly</span>类型，该变量不可被更改内容，也不能<span class="built_in">unset</span></span><br></pre></td></tr></table></figure><p>在默认情况下，变量类型默认为字符串，如下图中变量a默认是字符串2+3+4<br><img src="https://img-blog.csdnimg.cn/20200904164806662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>数组（array）变量类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var[index]=content  <span class="comment">#数组名为var,下标是index，内容是content，</span></span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://img-blog.csdnimg.cn/20200904170449162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="命令别名与历史命令">命令别名与历史命令</h2><p><strong>命令别名设置</strong>：alias、unalias</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> lm=<span class="string">'ls -al | more'</span>  <span class="comment">#把ls -al |more命令简化为lm</span></span><br></pre></td></tr></table></figure><p>直接敲alias可以查看当前有哪些命令别名。如下图：<br><img src="https://img-blog.csdnimg.cn/20200904182537483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>删除命令别名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unalias</span> lm</span><br></pre></td></tr></table></figure><p><strong>历史命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> [n]  </span><br><span class="line"><span class="built_in">history</span> [-c]  </span><br><span class="line"><span class="built_in">history</span> [-raw]</span><br><span class="line">选项与参数：</span><br><span class="line">n：列出最近的n条命令行表</span><br><span class="line">-c：将目前的shell中的所有<span class="built_in">history</span>内容全部清除</span><br><span class="line">-a：将目前新增的<span class="built_in">history</span>命令新增入histfiles中，若没有histfiles，则默认写入~/.bash_history</span><br><span class="line">-r：将histfiles的内容读到目前这个shell的<span class="built_in">history</span>中</span><br><span class="line">-w：将目前的<span class="built_in">history</span>记录内容写到histfiles中</span><br></pre></td></tr></table></figure><p>当我们以bash登录Linux主机之后，系统会主动地由家目录~/.bash_history读取以前曾经执行过的命令，该目录会记录的数据数目，就与bash的HISTFILESIZE这个环境变量有关</p><h1>Shell Script</h1><h2 id="什么是ShellScript">什么是ShellScript</h2><p>Shell Script即Shell脚本，是针对shell所写的脚本。我们将一些shell规定的语法与命令，再搭配正则表达式、管道命令与数据流重定向等功能，写成一个纯文本文件以达到我们想要的处理目的，再配以“.sh”的扩展名，这便是“Shell script”</p><p>简言之，我们只有通过Shell 这个工具来解释我们的命令等请求，才能成功实现与计算机的交流，同时再搭配Shell script这个可以批量处理命令的“程序”，我们就可以与计算机更好的交流</p><h2 id="参考书籍">参考书籍</h2><p>《鸟哥的Linux私房菜》第四版 第10章认识与学习BASH</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：顺序栈与链栈</title>
      <link href="/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%A0%88%E4%B8%8E%E9%93%BE%E6%A0%88/"/>
      <url>/2020/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%A0%88%E4%B8%8E%E9%93%BE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="栈-Stack">栈(Stack)</h2><p>栈是先进后出(Last In Fast Out)的线性表，限定仅在表尾进行插入和删除操作的线性表，把允许插入删除的一端称为栈顶</p><h2 id="栈示意图">栈示意图</h2><p><img src="https://img-blog.csdnimg.cn/20200902105233991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="进栈出栈变化形式">进栈出栈变化形式</h2><p>最先进栈的元素不一定最后出栈，因为栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就行</p><p>例如整型数字元素1，2，3依次进栈，出栈顺序可为：</p><ul><li>第一种，1，2，3进，再3，2，1出，出栈次序321</li><li>第二种，1进，1出，2进，2出，3进，3出，出栈次序123</li><li>第三种，1进，2进，2出，1出，3进，3出，出栈次序213</li><li>第四种，1进，1出，2进，3进，3出，2出，出栈次序132</li><li>第五种，1进，2进，2出，3进，3出，1出，出栈次序231</li></ul><p>3个元素会有5种出栈次序</p><h2 id="栈的顺序存储结构">栈的顺序存储结构</h2><p>栈是线性表的特例，栈的顺序存储结构其实是线性表顺序存储的简化，称为顺序栈，顺序栈结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;   <span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elemtype *elem;</span><br><span class="line"><span class="keyword">int</span> top;   <span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line"><span class="keyword">int</span> stacksize;  <span class="comment">/* 栈的空间大小 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的初始化">顺序栈的初始化</h2><ol><li>开辟初始空间</li><li>初始化top</li><li>初始化stacksize</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);  <span class="comment">//确保st不为空指针</span></span><br><span class="line"></span><br><span class="line">st-&gt;elem = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*STACK_INIT_SIZE);</span><br><span class="line">st-&gt;stacksize = STACK_INIT_SIZE;</span><br><span class="line">st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的扩容">顺序栈的扩容</h2><ol><li>开辟空间</li><li>更新stacksize</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AppendStack</span><span class="params">(PStack st)</span><span class="comment">//扩容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">st-&gt;elem = (ElemType*)<span class="built_in">realloc</span>(st-&gt;elem, st-&gt;stacksize + <span class="keyword">sizeof</span>(ElemType)*STACKINCREMENT);</span><br><span class="line">st-&gt;stacksize += STACKINCREMENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的进栈-Push">顺序栈的进栈(Push)</h2><p><img src="https://img-blog.csdnimg.cn/20200902111503507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>对于进栈操作push，其实做了三件事情</p><ol><li>判断栈满</li><li>栈顶指针加一</li><li>将新插入元素赋值给栈顶空间</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(PStack st, ElemType val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st-&gt;top == st-&gt;stacksize)  <span class="comment">//判断栈满</span></span><br><span class="line">&#123;</span><br><span class="line">AppendStack(st);</span><br><span class="line">&#125;</span><br><span class="line">st-&gt;top++;  <span class="comment">//栈顶指针加一</span></span><br><span class="line">st-&gt;elem[st-&gt;top] = val;  <span class="comment">//将新插入元素赋值给栈顶空间</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的出栈-Pop">顺序栈的出栈(Pop)</h2><p>若栈不为空，则弹出栈顶元素给e，栈顶指针减一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(PStack st, ElemType *e)</span>  <span class="comment">// 若栈不为空，则弹出栈顶元素给e，栈顶指针减一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st-&gt;top &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*e = st-&gt;elem[st-&gt;top];</span><br><span class="line">st-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的销毁">顺序栈的销毁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destory</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(st-&gt;elem);</span><br><span class="line">st-&gt;elem = <span class="literal">NULL</span>;</span><br><span class="line">st-&gt;stacksize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈的清空">顺序栈的清空</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">st-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈判空">顺序栈判空</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> st-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取顺序栈栈顶元素">获取顺序栈栈顶元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetTop</span><span class="params">(PStack st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(st != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> st-&gt;elem[st-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的链式存储结构">栈的链式存储结构</h2><p>栈的链式存储结构是用链表方式来实现栈，简称链栈，<br>链栈把栈顶放在单链表的头部，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200902131310411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>链栈结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>  // 栈结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>  // 链栈</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LinkStackPtr top;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><p>链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些</p><h2 id="链栈的进栈-Push">链栈的进栈(Push)</h2><p>假设要进栈的是元素值为e的新节点s，top为栈顶指针，则进栈示意图如下：<br><img src="https://img-blog.csdnimg.cn/20200902131516181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>将当前的栈顶元素赋值给新节点的直接后继</li><li>更新栈顶指针，使其指向新元素</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *LS, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StacNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line"></span><br><span class="line">s-&gt;next = LS-&gt;top; <span class="comment">//将当前的栈顶元素赋值给新节点的直接后继</span></span><br><span class="line">LS-&gt;top = s;  <span class="comment">//更新栈顶指针，使其指向新元素</span></span><br><span class="line"></span><br><span class="line">LS-&gt;count++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的出栈-Pop">链栈的出栈(Pop)</h2><p>假设变量p用来存储要删除的栈顶结点</p><ol><li>将栈顶结点赋值给p，如下图步骤1</li><li>栈顶指针下移一位，如下图步骤2</li><li>释放结点p</li></ol><p><img src="https://img-blog.csdnimg.cn/20200902133553634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若栈不为空，则删除栈顶元素，用e返回其值，并返回OK；否则返回ERROR</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr p;</span><br><span class="line"><span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">*e = S-&gt;top-&gt;next;</span><br><span class="line"></span><br><span class="line">p = S-&gt;top; <span class="comment">//将栈顶结点赋值给p，如上图步骤1</span></span><br><span class="line">S-&gt;top = S-&gt;top-&gt;next;  <span class="comment">//栈顶指针下移一位，如上图步骤2</span></span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//释放结点p</span></span><br><span class="line">S-&gt;count--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈与链栈对比">顺序栈与链栈对比</h2><p>顺序栈与链栈的进栈出栈时间复杂度均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度可以灵活开辟。所以他们的区别如同顺序表与链表的区别。<br><strong>如果栈的使用过程中元素的变化不可预料，有时很小，有时很大，那么最好用链栈；反之，如果它的变化在可控范围内，则可使用顺序栈</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：objdump和readelf的简单使用</title>
      <link href="/2020/09/01/Linux%EF%BC%9Aobjdump%E5%92%8Creadelf%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/01/Linux%EF%BC%9Aobjdump%E5%92%8Creadelf%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="objdump命令">objdump命令</h2><p><strong>objdump</strong>：objdump是用来查看目标文件或者可执行的目标文件的构成的GCC工具，objdump命令用一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息</p><p><strong>objdump命令的使用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objdump -t obj  <span class="comment">#输出目标文件的符号表</span></span><br><span class="line">objdump -h obj  <span class="comment">#输出目标文件的所有段</span></span><br><span class="line">objdump -S obj  <span class="comment">#C语言与汇编语言同时显示</span></span><br><span class="line">objdump -f obj  <span class="comment">#显示目标文件头信息</span></span><br><span class="line">objdump -x obj  <span class="comment">#显示目标文件的所有Header信息</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200901113634467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="readelf命令">readelf命令</h2><p><strong>readelf</strong>：readelf命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息</p><p><strong>ELF文件</strong>：目标文件在不同的系统或平台上具有不同的命名格式，在Unix和X86-64 Linux上称为ELF(Executable and Linkable Format, ELF)，ELF文件参与程序的连接（建立一个程序）和程序的执行（运行一个程序），所以可以从不同的角度来看待elf格式的文件，如下图：<br><img src="https://img-blog.csdnimg.cn/20200901114348278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>readelf命令的使用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">readelf -a [file]  <span class="comment">#--all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I.</span></span><br><span class="line"></span><br><span class="line">readelf -h [file]  <span class="comment">#--file-header 显示elf文件开始的文件头信息. </span></span><br><span class="line"></span><br><span class="line">readelf -l [file]  <span class="comment">#--program-headers --segments 显示程序头（段头）信息(如果有的话)。 </span></span><br><span class="line"></span><br><span class="line">readelf -S [file]  <span class="comment">#--section-headers --sections 显示节头信息(如果有的话) </span></span><br><span class="line"></span><br><span class="line">readelf -g [file]  <span class="comment">#--section-groups 显示节组信息(如果有的话)。 </span></span><br><span class="line"></span><br><span class="line">readelf -t [file]  <span class="comment">#--section-details 显示节的详细信息(-S的)。 </span></span><br><span class="line"></span><br><span class="line">readelf -s [file]  <span class="comment">#--syms --symbols 显示符号表段中的项（如果有的话）。 </span></span><br><span class="line"></span><br><span class="line">readelf -e [file]  <span class="comment">#--headers 显示全部头信息，等价于: -h -l -S -n --notes 显示note段（内核注释）的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -r [file]  <span class="comment">#--relocs 显示可重定位段的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -u [file]  <span class="comment">#--unwind 显示unwind段信息。当前只支持IA64 ELF的unwind段信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -d [file]  <span class="comment">#--dynamic 显示动态段的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -V [file]  <span class="comment">#--version-info 显示版本段的信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -A [file]  <span class="comment">#--arch-specific 显示CPU构架信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -D [file]  <span class="comment">#--use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 </span></span><br><span class="line"></span><br><span class="line">readelf -x [file]  <span class="comment">#--hex-dump= 以16进制方式显示指定段内内容。number指定段表中段的索引,或字符串指定文件中的段名。 </span></span><br><span class="line"></span><br><span class="line">readelf -I [file]  <span class="comment">#--histogram 显示符号的时候，显示bucket list长度的柱状图。 </span></span><br><span class="line"></span><br><span class="line">readelf -v [file]  <span class="comment">#--version 显示readelf的版本信息。 </span></span><br><span class="line"></span><br><span class="line">readelf -H [file]  <span class="comment">#--help 显示readelf所支持的命令行选项。 </span></span><br><span class="line"></span><br><span class="line">readelf -W [file]  <span class="comment">#--wide 宽行输出</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200901115504269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：编译链接原理</title>
      <link href="/2020/08/28/Linux%EF%BC%9A%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/28/Linux%EF%BC%9A%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在Linux下，当我们使用GCC来编译Hello World程序时，只须使用最简单的命令（源代码为hello.c）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><p>事实上，上述过程可以分解为4个步骤，分别是预处理，编译，汇编和链接，如下图：<br><img src="https://img-blog.csdnimg.cn/20200828092410563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="预编译">预编译</h2><p>预编译阶段把.cpp和.h等文件编译成一个 .i文件，第一步预编译的过程相当于如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i  <span class="comment">#-E表示只进行预编译，-o指定生成文件名</span></span><br></pre></td></tr></table></figure><p>预编译阶段主要处理那些源代码文件中以“#”开始的预编译指令。比如“#include”、“#define”等，主要处理规则如下：</p><ul><li>将所有的#define删除，并且展开所有的宏定义</li><li>处理所有的预编译指令，比如 #if、#ifdef、#elif、#else、#endif</li><li>处理#include预编译指令，将包含的文件插入到该预编译指令的位置。（这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件）</li><li>删除所有的注释“//”和“/* */”</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告能够显示行号</li><li>保留所有的#pragram编译器指令，因为编译器要使用它们</li></ul><p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也以经插入到.i文件中，所有可以通过查看.i文件来判断宏定义是否正确或头文件是否包含正确</p><p><strong>预编译阶段处理其实可以总结为以下三点</strong>：</p><ul><li><font color='red'><strong>处理预编译指令</strong></font></li><li><font color='red'><strong>删除注释</strong></font></li><li><font color='red'><strong>宏替换</strong></font></li></ul><p>hello.c文件与预编译生成的hello.i文件内容对比如下<br><img src="https://img-blog.csdnimg.cn/20200828110851580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="编译">编译</h2><p>编译过程就是把预处理完的文件进行一系列<font color='red'><strong>词法分析、语法分析、语义分析及优化后</strong></font>生成的汇编代码文件，这个过程是程序构建的核心部分，命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p>hello.c文件与编译生成的hello.s文件内容对比如下<br><img src="https://img-blog.csdnimg.cn/20200828111556372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="汇编">汇编</h2><p>汇编过程把汇编代码转成机器可执行的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>该过程的处理有：<font color='red'><strong>翻译成二进制，生成各个段、生成符号表</strong></font><br>汇编生成的hello.o文件是二进制文件，用vim查看会是乱码，要使用objdump命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h hello.o</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200828113848202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200828113917340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="链接">链接</h2><p>链接阶段的处理有：<font color='red'><strong>合并各个段，符号解析、符号重定位</strong></font><br><img src="https://img-blog.csdnimg.cn/20200828114023176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200828114036348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200828114050299.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020082811410427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：gcc和g-的使用与区别</title>
      <link href="/2020/08/18/Linux%EF%BC%9Agcc%E5%92%8Cg-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/08/18/Linux%EF%BC%9Agcc%E5%92%8Cg-%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc与g-是什么">gcc与g++是什么</h2><p>gcc：是GCC中的GNU C Compiler（C 编译器）注意：GCC与gcc是两个东西</p><p>g++：是GCC中的GNU C++ Compiler（C++编译器）</p><p>GCC: GNU Compiler Collection(GNU 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p><h2 id="gcc与g-区别">gcc与g++区别</h2><p><font color='red'>gcc和g++都可以编译c语言和c++</font></p><p>如果是 .c文件，gcc按照c语言的方式去编译，g++会按照c++的方式编译；如果是 .cpp文件，gcc和g++都会按照c++的方式去编译</p><p>gcc只会默认连接c库，不会连接c++库，而g++都会连接，gcc编译cpp文件时，必须手动连接c++的库（命令：gcc -o main main.cpp  -lstdc++）</p><h2 id="gcc-g-的使用">gcc/g++的使用</h2><p>gcc与g++使用方法相同，这里只以gcc为例</p><p>1、预编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E **.c  <span class="comment">#执行命令后生成**.i文件</span></span><br></pre></td></tr></table></figure><p>预编译阶段：处理预编译指令，删除注释，宏替换</p><p>2、编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S **.i  <span class="comment">#执行命令后默认生成一个**.s文件</span></span><br></pre></td></tr></table></figure><p>编译阶段：语法、词法分析，代码优化，汇总符号</p><p>3、汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c **.s  <span class="comment">#执行命令后生成**.o文件，是可重定位的二进制文件</span></span><br></pre></td></tr></table></figure><p>汇编阶段：翻译成二进制，生成各个段，生成符号表</p><p>4、链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc **.o  <span class="comment">#默认生成一个a.out文件，a.out是可执行文件</span></span><br></pre></td></tr></table></figure><p>链接阶段：合并各个段，符号解析，符号重定位</p><p>上述命令可以加-o指定生成的文件名，o是output的缩写，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc **.o -o 自定义的文件名  <span class="comment">#指定生成的可执行文件名称</span></span><br></pre></td></tr></table></figure><p><strong>上述过程总结如下图</strong><br><img src="https://img-blog.csdnimg.cn/20200818203115154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200818204208939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：进程相关的操作</title>
      <link href="/2020/08/15/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/08/15/Linux%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是进程">什么是进程</h2><p>在Linux中触发任何一个事件，系统都会将它定义为一个进程，并且给予这个进程一个ID，称为<strong>PID</strong>（Process ID），同时根据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置，操作系统中对进程的定义如下：</p><p><strong>进程(process)</strong>：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，即进行中的程序或运行中的程序，也就是程序的一次实例化</p><p><strong>程序(program)</strong>：存储在磁盘上的二进制可执行文件，程序员编写源代码文件，由编译器编译链接生成的文件。Windows上可执行程序是.exe文件，Linux上是a.out文件（ELF格式的文件）</p><h2 id="执行一个程序，生成进程">执行一个程序，生成进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路径 可执行文件名      <span class="comment">#./程序有文件名称，表示前台执行，必须等待进程执行结束</span></span><br><span class="line">路径 可执行文件名 &amp;    <span class="comment">#./程序文件名 &amp;，表示后台执行</span></span><br></pre></td></tr></table></figure><h2 id="查看进程">查看进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps       <span class="comment">#查看 Linux 中当前运行的进程</span></span><br><span class="line"><span class="built_in">jobs</span>     <span class="comment">#查看当前终端的后台任务  任务号 任务状态 任务名称</span></span><br><span class="line">ps aux   <span class="comment">#查看系统所有的进程</span></span><br><span class="line">ps -A    <span class="comment">#所有的进程均显示出来，与-e具有同样的效果</span></span><br><span class="line">ps -e    <span class="comment">#所有的进程均显示出来</span></span><br><span class="line">ps -a    <span class="comment">#不显示与终端有关的进程</span></span><br><span class="line">ps -l    <span class="comment">#较长、较详细的将该PID的信息列出</span></span><br><span class="line">ps -f    <span class="comment">#做一个更完整的输出</span></span><br></pre></td></tr></table></figure><p>ps -l会列出与你的操作环境（bash）有关的进程，显示的如下：<br><img src="https://img-blog.csdnimg.cn/20200815114402522.png#pic_center" alt="在这里插入图片描述"><br>上图中ps -l命令下面一行的含义如下：<br><img src="https://img-blog.csdnimg.cn/20200815115123804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="结束一个进程">结束一个进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> pid      <span class="comment">#结束进程标识符为pid的进程</span></span><br><span class="line">pkill cmd     <span class="comment">#结束一组相同cmd的进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 pid   <span class="comment">#强制结束一个进程</span></span><br></pre></td></tr></table></figure><h2 id="挂起一个进程">挂起一个进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -stop pid</span><br></pre></td></tr></table></figure><h2 id="唤醒">唤醒</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> 任务号  <span class="comment">#将任务唤醒到后台执行</span></span><br><span class="line"><span class="built_in">fg</span> 任务号  <span class="comment">#将任务唤醒到前台执行</span></span><br></pre></td></tr></table></figure><h2 id="top：动态查看进程的变化">top：动态查看进程的变化</h2><p>ps命令是选取一个时间点的进程状态，top则可以持续监测进程运行的状态，使用方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top -d 数字   <span class="comment">#数字表示秒数，整个进程界面更新的秒数，默认是5秒</span></span><br><span class="line">top -b       <span class="comment">#以批量的方式执行top</span></span><br><span class="line">top -n       <span class="comment">#与-b搭配，意义是需要执行几次top的输出结果</span></span><br><span class="line">top -p       <span class="comment">#指定某些歌PID来执行查看监测</span></span><br></pre></td></tr></table></figure><p>在top执行过程当中可以使用的按键命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">?  <span class="comment">#显示在top当中可以输入的按键命令</span></span><br><span class="line">P  <span class="comment">#以CPU的使用排序显示</span></span><br><span class="line">M  <span class="comment">#以Memory的使用排序显示</span></span><br><span class="line">N  <span class="comment">#以PID来排序</span></span><br><span class="line">T  <span class="comment">#由该进程使用的CPU使用时间累积（TIME+）排序</span></span><br><span class="line">k  <span class="comment">#给予某个PID一个信号（signal）</span></span><br><span class="line">r  <span class="comment">#给予某个PID重新制定一个nice值</span></span><br><span class="line">q  <span class="comment">#退出top的按键</span></span><br></pre></td></tr></table></figure><p>执行top命令默认显示如下图（数据是动态变化的）：<br><img src="https://img-blog.csdnimg.cn/20200815120843152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>top的功能非常多，可以使用man top命令来查看它的说明文档</p><h2 id="参考书籍">参考书籍</h2><p>《鸟哥的Linux私房菜》第16章 进程管理与SELinux初探</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文件的压缩与解压</title>
      <link href="/2020/08/15/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"/>
      <url>/2020/08/15/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下常见的压缩包">Linux下常见的压缩包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">***.zip      zip程序压缩的文件</span><br><span class="line">***.gz       gzip程序压缩的文件</span><br><span class="line">***.tar      tar程序打包的文件，并没有压缩过</span><br><span class="line">***.tar.gz   tar程序打包的文件，并且经过gzip的压缩</span><br><span class="line">***.tgz      与***.tar.gz可以认为是一样的</span><br><span class="line">***.tar.xz   tar程序打包的文件，并且经过xz的压缩</span><br></pre></td></tr></table></figure><p>虽然Linux文件的属性与文件后缀名没有绝对关系，但是为了帮助人们更好识别，适当的扩展名是可以有的。</p><h2 id="打包文件">打包文件</h2><p>压缩/解压命令通常仅能对一个文件压缩/解压，如此一来，要对一大堆文件进行压缩，打包命令 tar 就尤为重要了，打包即将很多文件结合为一个文件，方便进行压缩<br>打包命令：例如要对当前目录下的main.c 和test.c打包成一个文件名为coding.tar，执行的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar cf coding.tar  main.c test.c</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200815093358690.png#pic_center" alt="在这里插入图片描述"><br>tar的选项可有如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c  创建，创建包的时候使用</span><br><span class="line">f  目标为文件而不是设备</span><br><span class="line">x  释放文档内容，在解包的时候使用</span><br><span class="line">t  只查看包中的内容而不释放</span><br><span class="line">v  显示详细过程</span><br><span class="line">z  在GNU版本新加的选项，使得tar命令有压缩与解压缩功能</span><br></pre></td></tr></table></figure><p>以上选项可以组合，例如上例中的cf选项</p><h2 id="压缩">压缩</h2><p>文件打包以后，就可以进行压缩了，例如上例中生成的coding.tar包，对其压缩的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  coding.tar</span><br></pre></td></tr></table></figure><p>执行该命令后，会生成coding.tar.gz压缩包<br><img src="https://img-blog.csdnimg.cn/20200815094210919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="解压">解压</h2><p>解压就是对文件压缩的逆过程，<font color='red'>先进行解压缩，再进行解包</font></p><p>第一步：解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d coding.tar.gz   <span class="comment">#执行该命令会生成coding.tar包</span></span><br></pre></td></tr></table></figure><p>第二步：解包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf coding.tar   <span class="comment">#执行该命令会把main.c和test.c解出来</span></span><br></pre></td></tr></table></figure><p>tar在新版本中加的选项 z 可以使得tar命令具有压缩与解压缩的功能，因此压缩与解压可以直接这样执行：<br><img src="https://img-blog.csdnimg.cn/20200815095058585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>注意：</strong><br>coding.tgz文件可以通过gzip命令解压，可以通过tar命令不使用z选项进行解包<br>coding.tar.gz文件同样可以通过tar命令加上z选项（tar zxf）进行解压并解包</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文件操作相关的命令</title>
      <link href="/2020/08/13/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/08/13/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux：文件操作相关的命令">Linux：文件操作相关的命令</h2><h2 id="1-创建文件">1.创建文件</h2><p>创建普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch filename  <span class="comment">#创建一个普通文件，eg: touch main.c</span></span><br></pre></td></tr></table></figure><p>创建目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir direname  <span class="comment">#创建一个目录，eg: mkdir MyCode</span></span><br></pre></td></tr></table></figure><h2 id="2-删除文件">2.删除文件</h2><p>删除普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm filename  <span class="comment">#删除一个普通文件</span></span><br></pre></td></tr></table></figure><p>删除目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir direname  <span class="comment">#删除一个空目录，只能删除空目录</span></span><br><span class="line">rmdir -r direname  <span class="comment">#删除非空目录，-r选项让它递归地去删除</span></span><br></pre></td></tr></table></figure><h2 id="3-拷贝文件">3.拷贝文件</h2><p>拷贝普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp 路径1/filename 路径2  <span class="comment">#将路径1下的filename文件拷贝一份到路径2下</span></span><br></pre></td></tr></table></figure><p>拷贝目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r 路径1/direname 路径2  <span class="comment">#将路径1下的direname目录拷贝到路径2下</span></span><br></pre></td></tr></table></figure><h2 id="4-剪切-移动文件">4.剪切/移动文件</h2><p>剪切/移动普通文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 路径1/filename 路径2  <span class="comment">#将路径1下的filename文件剪切/移动到路径2下</span></span><br></pre></td></tr></table></figure><p>剪切/移动目录文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 路径1/diername 路径2  <span class="comment">#将路径1下的direname目录剪切/移动到路径2下</span></span><br></pre></td></tr></table></figure><h2 id="5-文件重命名">5.文件重命名</h2><p>普通文件和目录文件重命名命令相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 路径1/filename 路径1/newname  <span class="comment">#其实就是把该文件剪切到相同目录再换个名称</span></span><br></pre></td></tr></table></figure><h2 id="6-修改文件的属性">6.修改文件的属性</h2><p>修改文件的所有者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown newuser filename  <span class="comment">#只有root用户才能执行</span></span><br></pre></td></tr></table></figure><p>修改文件的组用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp newgroup filename  <span class="comment">#只有root用户才能执行</span></span><br></pre></td></tr></table></figure><p>修改文件的权限<br>1）文字设定法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a/u/g/o+/-/=rwx的子集 filename  <span class="comment">#例如：chmod g-x main.c 将组用户对于main.c文件的执行权限删去</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200813105924877.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200813110501110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2）数字设定法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 filename  <span class="comment">#三个数字分别代表一类用户的权限，数字取值范围是0~7</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200813110029110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="7-文件搜索命令">7.文件搜索命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 查找的起始位置 查找的标准</span><br></pre></td></tr></table></figure><p>查找的标准有如下选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-name  <span class="comment">#文件名：支持通配符</span></span><br><span class="line">-<span class="built_in">type</span>  <span class="comment">#文件类型：-f普通文件 -d目录 -p管道 -l链接 -c字符设备 -b块设备 -s套接字 </span></span><br><span class="line">-user  <span class="comment">#username</span></span><br><span class="line">-group  <span class="comment">#groupname</span></span><br><span class="line">-mtime +num/-num  <span class="comment">#+num:num天之前修改  -num：num天以内修改的</span></span><br><span class="line">-amin  +num/-num  <span class="comment">#+num：num分之前修改 -num：num分以内修改的</span></span><br><span class="line">-perm  <span class="comment">#根据文件权限搜索</span></span><br></pre></td></tr></table></figure><h2 id="8-管道命令和过滤命令">8.管道命令和过滤命令</h2><p>管道命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /etc | less  <span class="comment">#管道命令将前一个命令的输出传递给后面的命令</span></span><br></pre></td></tr></table></figure><p>管道命令将前一个命令的输出传递给后面的命令<br><img src="https://img-blog.csdnimg.cn/2020081311405454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>过滤命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 过滤的条件</span><br></pre></td></tr></table></figure><h2 id="9-在终端查看文件内容">9.在终端查看文件内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat filename  <span class="comment">#直接将文件全部内容显示到终端界面上</span></span><br><span class="line">less filename  <span class="comment">#类似于文本查看器</span></span><br><span class="line">more filename  <span class="comment">#和cat命令类似，但不会一次直接将所有的内容显示</span></span><br><span class="line">head -n filename  <span class="comment">#显示文件前n行内容</span></span><br><span class="line">tail -n filename  <span class="comment">#显示文件末尾n行内容</span></span><br><span class="line">tail -f filename  <span class="comment">#循环读取文件尾部的内容，不断刷新的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文本编辑器vi-vim的使用</title>
      <link href="/2020/08/13/Linux%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8vi-vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/13/Linux%EF%BC%9A%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8vi-vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux：vi-vim">Linux：vi/vim</h2><p><strong>vi</strong>：在所有的Linux发行版上面都内置的一个文本编辑器，很多软件默认也使用vi作为它们的编辑工具</p><p><strong>vim</strong>：可以认为是vi的高级版本，它具有程序编辑能力，可以用字体颜色来辨别语法的正确性，vim里面还加入了很多额外的功能，例如多文件编辑、区块复制等</p><h2 id="vi-vim的使用">vi/vim的使用</h2><p>vim有三种基本操作模式，分别是（一般）命令模式，插入（编辑）模式，（命令行）末行模式</p><p><strong>一般命令模式</strong><br>使用vim打开一个文件就进入一般命令模式了，例如用vim 打开main.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim main.c</span><br></pre></td></tr></table></figure><p>如果当前目录下没有main.c文件，执行该命令就会新建一个main.c，进入后显示如下图<br><img src="https://img-blog.csdnimg.cn/20200813203946291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在该模式下可以使用上下左右按键来移动光标，也可以使用删除、复制、粘贴等功能。命令如下：<br><img src="https://img-blog.csdnimg.cn/20200813212924537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>插入（编辑）模式</strong><br>在一般命令模式中可以进行删除、复制、粘贴等操作，但是却无法编辑文件的内容，要编辑文件内容，就要在一般命令模式按下i、l、o、O、a、A、r、R中任何一个字母，就会进入编辑模式，在界面左下角会显示INSERT模式<br><img src="https://img-blog.csdnimg.cn/20200813205019547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>输入的字母代表的意思如下：<br><img src="https://img-blog.csdnimg.cn/20200813205751447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时就可以进行编辑了，如果要回到一般命令模式，按下Esc键即可</p><p><strong>（命令行）末行模式</strong><br>末行模式可以对vim做一个配置，对文本进行保存、退出编辑、全文搜索、替换等操作<br>在一般命令模式下输入：/ ？三个中的任何一个就可进入末行模式，输入后显示如下图<br><img src="https://img-blog.csdnimg.cn/20200813210254314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>光标到了最末尾一行，这就是末行模式，可以输入一些命令对文件进行操作，命令如下：<br><img src="https://img-blog.csdnimg.cn/20200813213151242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>注意：一般命令模式可与编辑模式及末行模式切换，但编辑模式不可直接切换为末行模式，<strong>通常编辑完文本后，先按Esc转到一般命令模式，再按：转到末行模式，最后输入wq保存并退出</strong></p><p>这三种模式之间的关系如下图<br><img src="https://img-blog.csdnimg.cn/20200813214504358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="vim的简单配置">vim的简单配置</h2><p>默认vim编辑器配置比较单调，我们可以自己修改，例如加入行号，自动缩进，设置tab缩进格数，设置鼠标等<br>配置文件有两个位置，第一个是在/etc/vimrc，该文件需root用户修改，修改后的配置对全系统有效，第二个在~/.vimrc，修改该配置只针对此用户有效。选择这两个位置中的一个进行编辑即可。具体配置参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nu  <span class="comment">#设置行号  set nonu  #取消行号</span></span><br><span class="line"><span class="built_in">set</span> hlsearch  <span class="comment">#设置高亮查找，默认就是高亮查找  set nohlsearch  #取消高亮查找</span></span><br><span class="line"><span class="built_in">set</span> autoindent  <span class="comment">#设置自动缩进</span></span><br><span class="line"><span class="built_in">set</span> noautoindent  <span class="comment">#取消自动缩进</span></span><br><span class="line"><span class="built_in">set</span> cindent  <span class="comment">#设置c自动缩进</span></span><br><span class="line"><span class="built_in">set</span> tabstop=4  <span class="comment">#设置tab键为四个空格</span></span><br><span class="line"><span class="built_in">set</span> shiftwidth=4  <span class="comment">#将换行自动缩进设置为四个空格</span></span><br><span class="line"><span class="built_in">set</span> smartindent  <span class="comment">#设置智能对齐</span></span><br><span class="line"><span class="built_in">set</span> showcmd  <span class="comment">#命令行显示输入的命令</span></span><br><span class="line"><span class="built_in">set</span> mouse=a  <span class="comment">#打开鼠标</span></span><br><span class="line">syntax on  <span class="comment">#设置根据程序语法显示不同颜色</span></span><br></pre></td></tr></table></figure><h2 id="vim多窗口功能">vim多窗口功能</h2><p>vim支持多窗口视图，当打开一个文件，在末行模式下输入He表示在下边分屏浏览目录，He！表示在上分屏浏览目录，Ve在左边分屏浏览目录，Ve！在右边分屏浏览目录，示例如下图：<br><img src="https://img-blog.csdnimg.cn/20200813221501311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>输入Ve！后回车，在右侧分屏浏览目录如下图<br><img src="https://img-blog.csdnimg.cn/20200813221523693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="参考书籍">参考书籍</h2><p>《鸟哥的Linux私房菜》第四版 第九章 vim程序编辑器</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：文件系统、文件类型与文件权限</title>
      <link href="/2020/08/11/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
      <url>/2020/08/11/Linux%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux的文件系统">Linux的文件系统</h2><p>现在Linux大多采用ext4文件系统（Fourth extended filesystem），ext4是索引式的文件系统，以ext4文件系统格式化磁盘时，将磁盘划分成三个区：</p><p><strong>1.superblock（超级区块）</strong>：记录此文件系统的整体信息，包括inode区块的总量、使用量、剩余量，以及文件系统的格式与相关信息等；<br><strong>2.inode</strong>：很多inode节点，给每一个inode都分配一个编码，一个文件会有一个inode节点，在此inode中存储文件的属性信息以及存储文件内容的那些block号<br><strong>3.block（数据区块）</strong>：很多block，给每个block都分配了一个编号，每一个block用于存储文件真实内容，若文件太大时，会占用多个数据区块，一个block一般4K大小</p><h2 id="文件类型与文件权限">文件类型与文件权限</h2><p>在终端输入 ls  -l 查看文件的属性，显示如下图：<br><img src="https://img-blog.csdnimg.cn/20200811210956640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'><strong>第1栏文件类型：</strong></font>Linux下一切皆文件，Linux系统一共有五种文件类型，注意：Linux并不以文件的扩展名区分文件类型，Linux的五种文件类型如下：</p><p>普通文件：用符号 - 表示，例如.c、.cpp、.h、.txt等文件<br>目录文件：d<br>链接文件：l，类似于Windows上的快捷方式<br>管道文件：p，应用在进程间通信<br>设备文件：字符设备文件 c，块设备文件 b，套接字 s</p><p><font color='red'><strong>第2栏文件权限：</strong></font>第二列每三个字母代表一种用户类型的权限，一个文件将访问其的用户划分成三类，分别是所有者、组用户和其他用户，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200811212521303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'><strong>第3栏文件的链接数：</strong></font>普通文件：硬链接文件个数<br>目录文件：目录中一级子目录的个数<br><font color='red'><strong>第4栏文件的所有者</strong></font><br><img src="https://img-blog.csdnimg.cn/20200811212913500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'><strong>第5栏文件所属的组</strong></font><br><font color='red'><strong>第6栏文件的大小，单位字节</strong></font><br><font color='red'><strong>第7栏文件最后修改时间</strong></font><br><font color='red'><strong>第8栏文件名</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux：目录组织结构、绝对路径与相对路径、目录相关命令</title>
      <link href="/2020/08/11/Linux%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%81%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E3%80%81%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/08/11/Linux%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E3%80%81%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E3%80%81%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux目录组织结构">Linux目录组织结构</h2><p>在Linux下面，所有的文件与目录都是由根目录开始的，根目录是所有文件与目录的源头，然后再一个一个的分支下来，像树枝状，如下图<br><img src="https://img-blog.csdnimg.cn/20200811104213517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="目录树directory tree"><br>Linux的FHS（Filesystem Hierarchy Standard）给出了每个特定的目录下应该存放什么样的文件，FHS目的是希望让用户可以了解到已安装软件通常放置于哪个目录下</p><p><font color='red'><strong>/bin</strong></font>：存放常用命令（即二进制可执行程序），主要有：cat、ls、mkdir、tar、mount、mv、cp、bash等常用命令<br><font color='red'><strong>/etc</strong></font>：存放系统配置文件<br><font color='red'><strong>/home</strong></font>：所有普通用户的家目录，“~”代表目前这个用户的家目录<br><font color='red'><strong>/root</strong></font>：系统管理用户的家目录<br><font color='red'><strong>/usr</strong></font>：存放系统应用程序及文档，（usr全称UNIX Software Resource）<br><font color='red'><strong>/proc</strong></font>：虚拟文件系统目录，以进程为单位存储内存的映射，（proc全称process information pseudo-file system进程信息虚拟文件系统）<br><font color='red'><strong>/dev</strong></font>：存放设备文件<br><font color='red'><strong>/mnt</strong></font>：临时挂载点<br><font color='red'><strong>/lib</strong></font>：存放库文件<br><font color='red'><strong>/boot</strong></font>：系统内核及启动有关的文件<br><font color='red'><strong>/tmp</strong></font>：存放各种临时文件，是所有用户均可访问的地点<br><font color='red'><strong>/var</strong></font>：存放系统运行中常改变的文件，如系统日志</p><h2 id="绝对路径与相对路径">绝对路径与相对路径</h2><p>根据文件名写法的不同，将所谓的路径定义为绝对路径与相对路径<br><font color='red'><strong>绝对路径</strong></font>：由根目录(/)开始写起的文件名或目录名称，例如：/usr/local/src<br><font color='red'><strong>相对路径</strong></font>：相对于当前位置的路径，即从当前位置开始到指定位置的路径，<strong>‘.’代表当前位置，‘..’代表当前位置的上一层目录</strong>，例如：./main.c表示当前位置下的main.c文件</p><p>区分绝对路径和相对路径只需要看首字符，如果首字符是‘/’，则是绝对路径，其他的都是相对路径<br><strong>注意</strong>：在写程序（shell脚本）来管理系统的条件下，务必使用绝对路径，因为绝对路径的写法虽然比较麻烦，但是可以肯定的是这个写法是唯一的且正确的，若使用相对路径，则可能由于执行的工作环境不同导致一些问题的发生</p><h2 id="目录相关命令">目录相关命令</h2><p><font color='red'><strong>.</strong></font>：代表当前目录，例如./main.c当前目录下的main.c文件</p><p><font color='red'><strong>..</strong></font>：代表上一层目录，例如../test.c上一层目录下的test.c文件</p><p><font color='red'><strong>~</strong></font>：代表目前使用者身份的家目录，例如cd ~dmtsai等价于cd /home/dmtsai</p><p><font color='red'><strong>cd</strong></font>：change directory 切换目录，例如cd /usr/share</p><p><font color='red'><strong>pwd</strong></font>：print working directory 显示当前工作位置的绝对路径</p><p><font color='red'><strong>mkdir</strong></font>：make directory 建立一个新目录</p><p><font color='red'><strong>rmdir</strong></font>：remove directory 删除一个空目录，目录需要一层一层的删除才行，而且被删除的目录里面必定不能存在其他的目录或文件，即必须是空目录，如果要删除非空目录，要使用命令<strong>rmdir  -r  dirname</strong>，-r参数让它递归地去删除</p><p><font color='red'><strong>ls</strong></font>：查看文件或目录的信息，<br>用法：ls  路径，显示指定路径下的文件，如果不给路径，默认显示的是当前目录的文件<br>ls命令的选项与参数：<br>-a显示所有的文件，连同隐藏的文件（开头为 <strong>.</strong> 的文件）<br>-i         显示文件对应的inode节点号<br>-l         显示文件的详细信息，包含文件的属性与权限等数据（常用ls  -l也可简化为ll）</p><p><strong>参考书籍</strong><br>《鸟哥的Linux私房菜》第四版 第五章Linux的文件权限与目录配置</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：删除单链表中p节点，时间复杂度O-1</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%ADp%E8%8A%82%E7%82%B9%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%ADp%E8%8A%82%E7%82%B9%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1/</url>
      
        <content type="html"><![CDATA[<h2 id="题目背景">题目背景</h2><p>在plist中删除p节点，时间复杂度要求O(1)</p><h2 id="算法">算法</h2><p>因为时间复杂度为O(1)，所以常规思路遍历链表是不行的。删除节点，其实是把该节点数据域清除，已知了p节点，那么可以知道它的next节点，所以可以把p节点的下一个节点的数据域赋值给p节点数据域，再让p节点的next指向p-&gt;next-&gt;next，就实现了p节点数据域的清除，也就间接删除了p节点。<br>如果p是最后一个节点，则只好遍历链表，复杂度O(n)<br><strong>只有p是最后一个节点时间复杂度才是O(n),平均时间复杂度(O(1)*(n-1) + O(n))/n = O(1)，所以该算法时间复杂度仍为O(1)</strong></p><h2 id="C代码">C代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteP</span><span class="params">(Linklist plist, Linklist p)</span><span class="comment">//在plist中删除p节点，O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(plist != <span class="literal">NULL</span>);</span><br><span class="line">assert(p != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span> || p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)<span class="comment">//p不是最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把p-&gt;next-&gt;data的值赋值给p-&gt;data,再让p-&gt;next指向下下个节点</span></span><br><span class="line">p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p-&gt;next);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//p是最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList tmp;</span><br><span class="line"><span class="keyword">for</span> (; tmp-&gt;next-&gt;next != <span class="literal">NULL</span>;)</span><br><span class="line">&#123;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(tmp-&gt;next-&gt;next);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：求单链表倒数第k个节点，只能遍历一次链表</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%B1%82%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%8F%AA%E8%83%BD%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%B1%82%E5%8D%95%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E5%8F%AA%E8%83%BD%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求">题目要求</h2><p>求单链表倒数第k个节点，要求只能遍历一次单链表</p><h2 id="算法">算法</h2><p>用两个指针p、q来实现，p、q都指向链表开始位置，先让p指针向后走k个位置，然后两个指针同步走，当p指针为空的时候，q指针就是倒数第k个节点</p><h2 id="C代码">C代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">FindNodeOfK</span><span class="params">(LinkList plist, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span> || plist-&gt;next == <span class="literal">NULL</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList p = plist, q = plist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k&amp;&amp;p != <span class="literal">NULL</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="comment">//k的值大于链表的长度</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：判断两个单链表是否相交</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目要求">题目要求</h2><p>判断两个单链表是否相交，如果相交则返回第一个相交的节点，如果没有相交则返回NULL</p><h2 id="算法">算法</h2><p>1、先求两个链表长度的差值，让长的链表指针先走这个差值，如下图让plist1先走到p位置<br><img src="https://img-blog.csdnimg.cn/20200727213627962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、完成步骤1后，让两个链表的指针同步向后走，每走一步判断两个节点是否相等，如果相等则直接返回这个节点，如果走到NULL，则两个链表不相交</p><h2 id="C代码">C代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">IsIntersect</span><span class="params">(LinkList plist1, Linklist plist2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (plist1 == <span class="literal">NULL</span> || plist2 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ListEmpty(plist1) || ListEmpty(plist2))<span class="comment">//空链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = GetLength(plist1);</span><br><span class="line"><span class="keyword">int</span> len2 = GetLength(plist2);</span><br><span class="line">LinkList p = plist1, q = plist2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len1 &gt; len2)<span class="comment">// 长链表走差值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 - len1; i++)</span><br><span class="line">&#123;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)<span class="comment">//两个指针同步走</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构：判断链表是否有环，若有环找到环入口</title>
      <link href="/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%8C%E8%8B%A5%E6%9C%89%E7%8E%AF%E6%89%BE%E5%88%B0%E7%8E%AF%E5%85%A5%E5%8F%A3/"/>
      <url>/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%EF%BC%8C%E8%8B%A5%E6%9C%89%E7%8E%AF%E6%89%BE%E5%88%B0%E7%8E%AF%E5%85%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤一：判断链表是否有环，如果有，则返回相遇的节点，如果没有则返回NULL">步骤一：判断链表是否有环，如果有，则返回相遇的节点，如果没有则返回NULL</h2><p><strong>算法</strong>：通过设置快慢指针来判断相遇，快指针一次走两个节点，慢指针一次走一个，若两个指针能相遇则说明有环，返回相遇的节点，若快指针走到NULL都没发生相遇，则说明没环，返回NULL<br><img src="https://img-blog.csdnimg.cn/20200727202646350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Loop</span><span class="params">(LinkList plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span> || plist-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkList p = plist; <span class="comment">// 快指针</span></span><br><span class="line">LinkList q = plist; <span class="comment">// 慢指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) <span class="comment">// p-&gt;next != NULL 保证快指针一次走两个节点能够成功</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤二：找到有环链表的环的入口">步骤二：找到有环链表的环的入口</h2><p><strong>算法一</strong>：通过数学推导来找入口，具体如下：<br>设置快慢指针，快指针一次走两个节点，慢指针一次走一个节点，如下图，plist为链表起点，m为环入口，s点为快慢指针相遇点。<br><img src="https://img-blog.csdnimg.cn/20200727205446662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>当快慢指针相遇在s点，慢指针走过的路程为 x + y ,快指针走过的路程为x + y + (k +y) * n，n是快指针绕环的圈数。</strong><br>因为快指针速度是慢指针二倍，快慢指针移动的时间相同，所以快指针的路程等于慢指针路程的二倍，即2(x + y) = x + y + (k + y)n<br>化解：x + y = (k + y)n<br>x + y =  (k + y)(n - 1) + k+y<br><strong>x = (k + y)(n-1) + k</strong><br><strong>该式里，右边(k + y)(n -1)是绕环的路程，即从plist起点开始到环入口的路程等于从相遇点s开始到m的路程加上绕环的路程<br>因而可以让两个速度相同的指针，一个从plist开始走，一个从s点开始走，二者第一次相遇的点就是环入口m点</strong></p><p>C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">IsLoop</span><span class="params">(LinkList plist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList s = Loop(plist);<span class="comment">//通过上一步骤的Loop函数找到快慢指针相遇点</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList p = plist;</span><br><span class="line">LinkList q = s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">//p就是入环的第一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法二</strong>：遍历节点时把节点存储在一个表里，每次移动指针都在表里查看有无当前节点，若有出现重复则返回该节点，若无则继续遍历。该算法思路较为简单，但效率不高，O(n^2)<br>C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLESIZE 10  </span></span><br><span class="line"><span class="function">Linklist <span class="title">FindCircleStart</span><span class="params">(Linklist plist)</span><span class="comment">//如果有环，找到入幻的第一个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(plist != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (plist == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">Linklist p = plist;</span><br><span class="line"><span class="keyword">if</span> (IsCircle(p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//遍历p，把节点存起来，第一个出现重复的节点就是环的入口</span></span><br><span class="line">Linklist table[TABLESIZE];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">table[i] = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i &gt; TABLESIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">realloc</span>(table, <span class="keyword">sizeof</span>(table) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)<span class="comment">//看已存的表里有没有重复的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j +<span class="number">1</span>; k &lt; i; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (table[k] == table[j])</span><br><span class="line"><span class="keyword">return</span> table[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串算法：等宽替换-以少换多-以多换少</title>
      <link href="/2020/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AD%89%E5%AE%BD%E6%9B%BF%E6%8D%A2-%E4%BB%A5%E5%B0%91%E6%8D%A2%E5%A4%9A-%E4%BB%A5%E5%A4%9A%E6%8D%A2%E5%B0%91/"/>
      <url>/2020/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%EF%BC%9A%E7%AD%89%E5%AE%BD%E6%9B%BF%E6%8D%A2-%E4%BB%A5%E5%B0%91%E6%8D%A2%E5%A4%9A-%E4%BB%A5%E5%A4%9A%E6%8D%A2%E5%B0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目一：写一个函数将字符串中的字符-移到字符串的前部分，前面的非-字符后移，但不能改变非-字符的先后顺序，例如auto-toc-处理后为-autoc">题目一：写一个函数将字符串中的字符*移到字符串的前部分，前面的非*字符后移，但不能改变非*字符的先后顺序，例如auto**toc**处理后为****autoc</h2><p><strong>算法一：</strong><br><img src="https://img-blog.csdnimg.cn/20200623153956201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="算法一"><br>C代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1:从后往前复制非*的字符,然后前面的补*</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Move1</span><span class="params">(<span class="keyword">char</span> *str)</span><span class="comment">//O(n),O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *arr =  (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">assert(arr != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(str);<span class="comment">//str下标</span></span><br><span class="line"><span class="keyword">int</span> j = i;<span class="comment">//arr下标</span></span><br><span class="line"><span class="keyword">int</span> rtval;<span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从后往前复制非*的字符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] != <span class="string">'*'</span>)<span class="comment">//非*,需要复制到arr中</span></span><br><span class="line">&#123;</span><br><span class="line">arr[j--] = str[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rtval = <span class="built_in">strlen</span>(str)-j<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//前面补*</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">arr[j--] = <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(str,arr);<span class="comment">//将数据复制到str中</span></span><br><span class="line"><span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rtval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法一时间复杂度O(n),空间复杂度0(n)</p><p><strong>算法二：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200623154404291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法2,利用两个下标i,j分别到字符串的末尾,通过i从后往前遍历,如果i的数据为非*则将数据复制到j处,</span></span><br><span class="line"><span class="comment">//j往前,如果没有复制则j不动,最后将前面的部分补充为*</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Move</span><span class="params">(<span class="keyword">char</span> *str)</span><span class="comment">//O(n),O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strlen</span>(str);<span class="comment">//遍历的下标</span></span><br><span class="line"><span class="keyword">int</span> j = i;<span class="comment">//数据移动后的下标</span></span><br><span class="line"><span class="keyword">int</span> rtval;<span class="comment">//返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)<span class="comment">//利用i从后往前遍历字符串</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] != <span class="string">'*'</span>)</span><br><span class="line">&#123;</span><br><span class="line">str[j--] = str[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rtval = <span class="built_in">strlen</span>(str)-j<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">str[j--] = <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rtval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法二未使用辅助空间，时间复杂度O(n),空间复杂度度O(1)</p><h2 id="题目二：将字符串中的空格替换为-20-例如-a-b-c-“a-20b-20-20c”">题目二：将字符串中的空格替换为%20,例如&quot;a b  c&quot;-&gt;“a%20b%20%20c”</h2><p><strong>算法一：</strong><br><img src="https://img-blog.csdnimg.cn/20200623154824220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>算法二：</strong><br><img src="https://img-blog.csdnimg.cn/202006231548409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>算法二C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span> *str1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//先统计空格数量，利用i定位到字符串末尾，j=i+空格数*2；</span></span><br><span class="line"><span class="comment">//再从后往前替换，遇到非空格的直接放，遇到空格替换为0 2 %, j往前移动3个</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> blank = <span class="number">0</span>;<span class="comment">//空格数量</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; str1[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == <span class="string">' '</span>)</span><br><span class="line">blank++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = i + blank * <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//i是旧串末尾，j是新串的末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] != <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">str1[j] = str1[i];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//是空格</span></span><br><span class="line">&#123;</span><br><span class="line">str1[j--] = <span class="string">'0'</span>;</span><br><span class="line">str1[j--] = <span class="string">'2'</span>;</span><br><span class="line">str1[j--] = <span class="string">'%'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三：删除字符串中多余的空格-多个空格只保留一个-“a-b-c-d”-“a-b-c-d”">题目三：删除字符串中多余的空格,多个空格只保留一个.“a b c    d”-&gt;“a b c d”</h2><p><img src="https://img-blog.csdnimg.cn/20200623155226357.png" alt="在这里插入图片描述"><br>算法：i不断后移判断，若当前是空格，接下来也是空格，则不赋值，i后移，j不动<br>若当前是空格接下来不是空格或者当前是非空格则把i赋值给j，i后移，j后移</p><p>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//i不断后移判断，若当前是空格，接下来也是空格，则不赋值，i后移，j不动</span></span><br><span class="line"><span class="comment">//若当前是空格接下来不是空格或者当前是非空格则把i赋值给j，i后移，j后移</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; str2[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str2[i] == <span class="string">' '</span>&amp;&amp;str2[i + <span class="number">1</span>] == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">str2[j] = str2[i];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str2[j] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言位运算及其应用</title>
      <link href="/2020/06/23/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2020/06/23/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>位运算符</strong></p><p>位运算符允许对一个字节或更大的数据单位中独立的位做处理：可以清除、设定，或者倒置任何位或多个位。也可以将一个整数的位模式（bit pattern）向右或向左移动，针对的是二进制。<br><img src="https://img-blog.csdnimg.cn/20200623143142494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200623143214315.png" alt="在这里插入图片描述"><br>注意：&lt;&lt;左移运算符最右边补0，&gt;&gt;右移运算符最左边补符号位，（记忆这两个符号方法：箭头朝哪一边就是哪一边移）</p><p><strong>位运算应用</strong><br>下面数据x设为1字节，即8位</p><p>去掉最后一位 ： (10110<strong>1</strong>-&gt;10110)   算法  x &gt;&gt; 1</p><p>在最后加一个0：(101101-&gt;101101<strong>0</strong>)  算法 x &lt;&lt; 1</p><p>在最后加一个1：(101101-&gt;101101<strong>1</strong>) 算法 (x &lt;&lt; 1)|1</p><p>把最后一位变成1： (10110<strong>0</strong>-&gt;10110<strong>1</strong>) 算法 x | 1</p><p>把最后一位变成0：(10110<strong>1</strong>-&gt;10110<strong>0</strong>) 算法 (x | 1)-1</p><p>最后一位取反：(10110<strong>1</strong>-&gt;10110<strong>0</strong>) 算法 x ^ 1</p><p>把右数第k位变成1：(101<strong>0</strong>01-&gt;101<strong>1</strong>01,k=3) 算法 x | (1 &lt;&lt; (k-1))</p><p>把右数第k位变成0： (101<strong>1</strong>01-&gt;101<strong>0</strong>01,k=3) 算法 x &amp; ~(1 &lt;&lt; (k-1))</p><p>右数第k位取反： (101<strong>0</strong>01-&gt;101<strong>1</strong>01,k=3) 算法 x ^ (1 &lt;&lt; (k-1))</p><p>取末三位： (1101<strong>101</strong>-&gt;101) 算法 x &amp; 7<br>注：7的二进制为0000  0111，x&amp;7即可取末三位</p><p>取末k位： (110<strong>1101</strong>-&gt;1101,k=4) 算法 x &amp; ((1 &lt;&lt; k)-1)</p><p>取右数第k位： (110<strong>1</strong>101-&gt;1,k=4) 算法 (x &gt;&gt; (k-1)) &amp; 1</p><p><strong>位运算方法总结</strong></p><p>1.确定符号，变1：|1；变0：&amp;0；取反：^1<br>2.确定数字<br>3.构造数字<br>例如：<img src="https://img-blog.csdnimg.cn/202006231501513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>例题：统计一个字节数据二进制1的个数</strong><br><img src="https://img-blog.csdnimg.cn/20200623151149156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言动态内存分配malloc、calloc、realloc</title>
      <link href="/2020/05/23/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dmalloc%E3%80%81calloc%E3%80%81realloc/"/>
      <url>/2020/05/23/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dmalloc%E3%80%81calloc%E3%80%81realloc/</url>
      
        <content type="html"><![CDATA[<h2 id="动态内存"><strong>动态内存</strong></h2><p>根据需要动态创建需要的内存。例如根据变量创建数组，其内存区域在堆。这里简单提一下堆与栈</p><p><strong>栈</strong>：局部变量所在的内存区域，在Windows默认其大小为1M，系统自行管理其内存（即你不用管回收问题）</p><p><strong>堆</strong>：动态内存所在区域，默认大小为2G左右（不同平台有差别），程序管理内存，特别要注意内存释放</p><p>从以上栈与堆的大小可以知道，堆比栈大的多，所以动态内存还有一个使用场景，即需要创建大容量的数组时</p><h2 id="malloc、calloc、realloc"><strong>malloc、calloc、realloc</strong></h2><p><strong>malloc</strong>(字节数): 创建成功，函数返回一个指向分配起始地址的指针，失败返回NULL，内存数据为没有初始化的随机值</p><p><strong>calloc</strong>(单元个数，每个单元的字节数): 创建成功，函数返回一个指向分配起始地址的指针，失败返回NULL，内存数据初始化为0</p><p><strong>realloc</strong>(旧内存地址，新的内存字节大小): 用于修改动态内存的大小</p><p><strong>注意</strong>：这三个是C语言表中库中的函数，使用时要引用头文件stdlib.h，返回的地址都是void*类型，要强制类型转换成你所要用的类型</p><p><strong>malloc与calloc主要区别</strong>： 1.malloc内存数据未初始化，为随机值，calloc内存数据初始化为0,<br>2.malloc只有一个参数，calloc有两个参数，注意看他们的函数原型声明：void* malloc(unsigned size);    void* calloc(size_t nelem, size_t elsize)</p><h2 id="free"><strong>free</strong></h2><p><strong>free</strong>(地址): 释放动态创建的内存，不释放会发生内存泄漏<br>free在使用的时候在以下情况会崩溃：1.越界（动态分配的内存太小）2.动态内存指针发生移动  3.重复释放</p><p>解释一下第二条动态内存指针发生移动导致free失败的原因<br>free函数只有一个参数，即分配的内存的首地址，它只用这一个信息就知道要释放多大的内存，这是因为动态分配的内存的那个首地址记录了它后边的分配的空间的大小的信息，因此只传给free函数内存首地址即可，若这个地址（指针）发生了移动，free就会崩溃。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不使用第三个变量交换两个整数a-b的值</title>
      <link href="/2020/05/21/%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0a-b%E7%9A%84%E5%80%BC/"/>
      <url>/2020/05/21/%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0a-b%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>通常交换两个整数a,b的值，要使用第三方变量temp，但是在一些笔试或面试中，要求<strong>不使用第三个变量来实现交换</strong>，下面总结三种方法。</p><h2 id="方法一：加法">方法一：加法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a + b;<span class="comment">//a存储两数之和7</span></span><br><span class="line">b = a - b;<span class="comment">//两数之和减去一个就是另一个，相当于b = 7-2，此时b已经变成最初a的值了</span></span><br><span class="line">a = a - b;<span class="comment">//相当于a=7-2，a的值成为最初b的值</span></span><br></pre></td></tr></table></figure><h2 id="方法二：减法">方法二：减法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a - b;<span class="comment">//a存储两数之差  a=2-5=-3</span></span><br><span class="line">b = b + a;<span class="comment">//b加上a与b的差值即为最初a的值</span></span><br><span class="line">a = b - a; <span class="comment">//b此时为最初a的值，减去差值即为最初b的值</span></span><br></pre></td></tr></table></figure><h2 id="方法三：异或">方法三：异或</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = a ^ b;   <span class="comment">//a存储ab"异或结果"</span></span><br><span class="line">b = a ^ b;  <span class="comment">//"异或结果"与b异或得到的是最初a的值</span></span><br><span class="line">a = a ^ b;  <span class="comment">// "异或结果"与此时变成a的b异或得到的是最初b的值</span></span><br></pre></td></tr></table></figure><h2 id="注意！">注意！</h2><p>上述三种方法都没有常规方法( tmp = a ; a = b ; b = tmp; )好，并且以上三种方法不能实现自己和自己的交换，自己和自己交换结果都会是0<br>例如异或方法，当a和b都是a时，就变为(a = a ^ a ; a = a ^ a ; a = a ^ a)，结果是0</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swap函数实现交换两个整数的值，易错总结</title>
      <link href="/2020/05/17/Swap%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/17/Swap%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC%EF%BC%8C%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正确做法">一、正确做法</h2><p><strong>首先正确的交换方式是如下代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用指针直接访问存储两个整数的内存空间，实现交换，下面归纳一下易错的地方</p><h2 id="二、只交换了形参">二、只交换了形参</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_err</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，只是交换了Swap函数里a，b的值（即只交换了形参的值），而主函数里的a，b是没有发生改变的，交换失败</p><h2 id="三、只是交换了形参的指向">三、只是交换了形参的指向</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_err2</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况看似形参传了引用，但函数体交换的是形参的指向，如下图所示<img src="https://img-blog.csdnimg.cn/20200517220942457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt=""><br>p1原本指向a，函数把p1指向了b，p2指向了a，交换了这两个形参的指向，但a，b并没有发生交换。<br>可以形象的理解为交换了两个房间的钥匙，房间里的内容并没有交换。</p><h2 id="四、小心野指针">四、小心野指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_err3</span><span class="params">(<span class="keyword">int</span> *p1,<span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp;<span class="comment">//野指针,悬挂指针,tmp是个局部变量,默认值为随机值</span></span><br><span class="line">*tmp = *p1;<span class="comment">//*tmp崩溃,野指针不能访问</span></span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = *tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况程序会崩溃<br><img src="https://img-blog.csdnimg.cn/20200517221636187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt=""><br>这里tmp指针没有被初始化，即成为所谓的野指针<br>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的），此时去解引用就是去访问了一个不确定的地址，所以结果是不可知的。<br>野指针不同于空指针，空指针是指一个指针的值为null，而野指针的值并不为null，野指针会指向一段实际的内存，只是它指向哪里我们并不知情，所以程序在这里崩溃了。<strong>编程时要小心避免野指针。</strong></p><h2 id="五、总结">五、总结</h2><p>交换成功的必要条件:<strong>1.传指针;2.解引用</strong><br>一个函数的改变要想影响另一个函数,必须满足两个条件:<strong>1.传指针;2.解引用</strong></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github与hexo搭建的个人博客网站更新后显示404</title>
      <link href="/2020/05/17/Github%E4%B8%8Ehexo%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E5%90%8E%E6%98%BE%E7%A4%BA404/"/>
      <url>/2020/05/17/Github%E4%B8%8Ehexo%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E5%90%8E%E6%98%BE%E7%A4%BA404/</url>
      
        <content type="html"><![CDATA[<p>更新博客后<br>hexo s 本地显示正常，但是hexo d提交线上后，用域名打开显示404</p><p><strong>解决办法</strong></p><p>hexo d后，登录Github找到自己博客的仓库，<br>点击settings<br><img src="https://img-blog.csdnimg.cn/20200516195546338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="Github settings"><br>拉到底部将自己的域名填入，（虽然之前填过，但更新后有时要再填一次）<br><img src="https://img-blog.csdnimg.cn/20200516195808997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="custom domain"><br>然后再点击rename，（虽然这没改动，但仍要点击一次）<br><img src="https://img-blog.csdnimg.cn/20200516195939782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="click rename"><br>操作完之后就可以用域名打开网站了</p><p><img src="https://img-blog.csdnimg.cn/20200516200508342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OneNote-for-win10本地存储文件的备份与查看</title>
      <link href="/2020/05/17/OneNote-for-win10%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%9F%A5%E7%9C%8B/"/>
      <url>/2020/05/17/OneNote-for-win10%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%9F%A5%E7%9C%8B/</url>
      
        <content type="html"><![CDATA[<p>今天win10预装的OneNote突然卡在了打开笔记本页面，一番重启之后无解，准备重装又担心之前的数据没有上传到云，于是手动备份。</p><p>OneNote本地存储的文件在C:\Users\wi\AppData\Local\Packages\Microsoft.Office.OneNote_8wekyb3d8bbwe\LocalState\AppData\Local\OneNote\16.0\AccessibilityCheckerIndex<br>该目录下成对出现的文件即为自己的笔记本，这些数据库文件为sqlite格式的db文件。使用SQLLiteSpy可以查看这些文件。<br>下载SQLLite数据库管理工具SQLLiteSpy<a href="http://www.winportal.com/sqlitespy" target="_blank" rel="noopener">下载地址</a>。<br>下载成功后解压缩，找到exe文件直接运行，在可视化窗口使用快捷键ctrl+F11打开数据库文件。使用该工具即可查看自己OneNote笔记本的数据结构。<br><img src="https://img-blog.csdnimg.cn/2020042609235772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="SQLLite界面"><br>重装OneNote之前备份数据库文件，这样就不用担心数据的丢失了。</p>]]></content>
      
      
      <categories>
          
          <category> OneNote </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查找两数之和</title>
      <link href="/2020/05/16/%E6%9F%A5%E6%89%BE%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/05/16/%E6%9F%A5%E6%89%BE%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="查找两数之和">查找两数之和</h2><p><strong><strong>Leetcode刷题笔记</strong></strong><br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p><p>我的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> *p1 = nums;</span><br><span class="line">    <span class="keyword">int</span> *a =(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);<span class="comment">//动态分配内存，给a分配2个int的大小//malloc返回分配的首地址</span></span><br><span class="line">                                          </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*(p1 + i) + *(p1 + j)) == target) </span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>] = i; a[<span class="number">1</span>] = j;</span><br><span class="line">                     </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   *returnSize=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力查找，时间复杂度 O(n^2)，本题逻辑较为简单，但要注意题注“The returned array must be malloced”.<br>算法可优化，具体参考leetcode该题讨论区。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>求整数位数，以及顺序与逆序输出各位数字</title>
      <link href="/2020/05/16/%E6%B1%82%E6%95%B4%E6%95%B0%E4%BD%8D%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E4%B8%8E%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
      <url>/2020/05/16/%E6%B1%82%E6%95%B4%E6%95%B0%E4%BD%8D%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F%E4%B8%8E%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目背景：给一个正整数，-1-求它的位数，2-逆序输出每一位数字，3顺序输出每一位数字">题目背景：给一个正整数， 1.求它的位数，2.逆序输出每一位数字，3顺序输出每一位数字</h2><p><strong>1求位数，</strong><br>算法: 每次丢弃个位数字,计数器++,直到n为0<br>与我们用眼睛去数类似，即不断给该整数除以十，计数，此处要考虑当给的整数位0时的特殊情况，C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp++;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.逆序输出</strong><br>算法：求出低位，输出低位，再丢弃低位，重复执行直到n为0<br>这里关键是求低位的算法，用除十取余来得到低位，C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseOutput</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//提前结束该函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">n = -n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,n%<span class="number">10</span>);</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.顺序输出</strong><br>算法:得到高位,输出高位,丢弃高位,直到n为0，<br>这里关键是得到高位的算法，C代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderOutput</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = Count(n); <span class="comment">//得到n是几位数字</span></span><br><span class="line"><span class="keyword">int</span> power = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10.0</span>, tmp - <span class="number">1</span>);<span class="comment">//获得高位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, n / power);<span class="comment">//输出最高位</span></span><br><span class="line">n %= power;<span class="comment">//丢弃最高位</span></span><br><span class="line">power /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
