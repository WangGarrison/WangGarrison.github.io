<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C-：继承 | WangGarrison</title><meta name="description" content="基本概念  &#x3D;&#x3D;继承&#x3D;&#x3D;（inheritance）机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构。体现了由简单到复杂的认识过程。 &#x3D;&#x3D;多态性&#x3D;&#x3D;（polymorphism）是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。函数的重载，运算符的重载，属于编"><meta name="author" content="WangGarrison"><meta name="copyright" content="WangGarrison"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="C-：继承"><meta name="twitter:description" content="基本概念  &#x3D;&#x3D;继承&#x3D;&#x3D;（inheritance）机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构。体现了由简单到复杂的认识过程。 &#x3D;&#x3D;多态性&#x3D;&#x3D;（polymorphism）是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。函数的重载，运算符的重载，属于编"><meta name="twitter:image" content="http://wanggarrison.top/img/1index-bg.png"><meta property="og:type" content="article"><meta property="og:title" content="C-：继承"><meta property="og:url" content="http://wanggarrison.top/2021/02/03/C-%EF%BC%9A%E7%BB%A7%E6%89%BF/"><meta property="og:site_name" content="WangGarrison"><meta property="og:description" content="基本概念  &#x3D;&#x3D;继承&#x3D;&#x3D;（inheritance）机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构。体现了由简单到复杂的认识过程。 &#x3D;&#x3D;多态性&#x3D;&#x3D;（polymorphism）是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。函数的重载，运算符的重载，属于编"><meta property="og:image" content="http://wanggarrison.top/img/1index-bg.png"><meta property="article:published_time" content="2021-02-03T08:36:29.557Z"><meta property="article:modified_time" content="2021-02-03T09:05:15.036Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wanggarrison.top/2021/02/03/C-%EF%BC%9A%E7%BB%A7%E6%89%BF/"><link rel="prev" title="Linux：线程-2-——线程安全、线程与fork" href="http://wanggarrison.top/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-2-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8Efork/"><link rel="next" title="Linux：线程-1-——线程、线程库、线程同步" href="http://wanggarrison.top/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-1-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%BA%93%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"><link rel="stylesheet" href="/font"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: false,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/shouyetubiao.css"><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-dangan"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei-copy"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwo"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content" style="overflow: hidden;"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问控制和继承"><span class="toc-number">2.</span> <span class="toc-text">访问控制和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#私有继承"><span class="toc-number">3.</span> <span class="toc-text">私有继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保护继承"><span class="toc-number">4.</span> <span class="toc-text">保护继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#公有继承"><span class="toc-number">5.</span> <span class="toc-text">公有继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可访问性"><span class="toc-number">6.</span> <span class="toc-text">可访问性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员属性为protected的优点"><span class="toc-number">7.</span> <span class="toc-text">成员属性为protected的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造、析构顺序"><span class="toc-number">8.</span> <span class="toc-text">构造、析构顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数、析构函数继承问题"><span class="toc-number">9.</span> <span class="toc-text">构造函数、析构函数继承问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二义性和支配规则"><span class="toc-number">10.</span> <span class="toc-text">二义性和支配规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚基类"><span class="toc-number">11.</span> <span class="toc-text">虚基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#赋值兼容与切片现象"><span class="toc-number">12.</span> <span class="toc-text">赋值兼容与切片现象</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/1index-bg.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangGarrison</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-dangan"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei-copy"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwo"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">C-：继承</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2021-02-03 16:36:29"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2021-02-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2021-02-03 17:05:15"><i class="fa fa-history" aria-hidden="true"></i> Updated 2021-02-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>Word count:</span><span class="word-count">4k</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><hr>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h2 id="基本概念">基本概念</h2>
<hr>
<p>==继承==（inheritance）机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构。体现了由简单到复杂的认识过程。</p>
<p>==多态性==（polymorphism）是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。函数的重载，运算符的重载，属于编译时的多态性(早期绑定)。以虚基类为基础的运行时的多态性(晚绑定，只有在运行时才知道和哪个函数有关系)是面向对象程序设计的标志性特征。体现了类推和比喻的思想方法。</p>
<p>层次概念是计算机的重要概念。通过继承的机制可对类分层，提供类型/子类型的关系</p>
<p>C++通过类派生的机制来支持继承。被继承的类称为基类(base class)或超类或父类，新派生的类称为派生类(derived class)或子类</p>
<p>基类和派生类的集合称作类继承层次结构，如果基类和派生类共享相同的接口，则派生类称作基类的子类型</p>
<p>派生反映了事物之间的联系，事物的共性与个性之间的关系。派生与独立设计的若干类，前者工作量少，重复的部分可以从基类继承来，不需要单独编程</p>
<p>==单一继承==：一个派生类只有一个直接基类，如下：(single inheritance)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 访问限定符 基类</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    成员表<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>==多重继承==：一个派生类同时有多个基类，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 访问限定符 基类<span class="number">1</span>, 访问限定符 基类<span class="number">2.</span>..</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    成员表<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：很多时候避免多重继承，多重继承会引入很多麻烦和其好处不成正比</p>
<p>==继承方式==：公有继承public、保护继承protected、私有继承private，继承方式如果省略，表示私有继承，即类的默认继承方式是私有的</p>
<p>==继承机制优点==：代码重用，基类被派生类继承后，派生类中就不需要重复编写基类中的成员</p>
<h2 id="访问控制和继承">访问控制和继承</h2>
<hr>
<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">访问</th>
<th style="text-align:left">public</th>
<th style="text-align:left">protected</th>
<th style="text-align:left">private</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">同一个类(本类的成员函数)</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">派生类中(派生类的成员函数)</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">外部的类(如该类的对象)</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
</tr>
</tbody>
</table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h2 id="私有继承">私有继承</h2>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">private</span> Base</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>私有继承时，基类中的public和protected成员在派生类中均变成了private成员，在派生类中可直接访问；而基类中的private成员虽然被继承下来了，但在派生类中不可直接访问</p>
<h2 id="保护继承">保护继承</h2>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">protected</span> Base</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>保护继承时，基类中的public和protected成员在派生类中均变成了protected成员，在派生类中可直接访问；而基类中的private成员虽然被继承下来了，但在派生类中不可直接访问</p>
<h2 id="公有继承">公有继承</h2>
<hr>
<p>公有继承时，基类中的public和protected成员在派生类中仍为public和protected成员，在派生类中可直接访问；而基类中的private成员虽然被继承下来了，但在派生类中不可直接访问</p>
<p>==公有继承代表是一个的意思：is a==</p>
<p>学生继承自人类(Student  is  a  person) ，人类是基类，学生类是派生类，“人类是个泛泛的概念，学生类是它的特例，学生是人，但是人不一定是学生”</p>
<p>==派生类的内存结构==</p>
<p><img src="https://img-blog.csdnimg.cn/20201123223928691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>对于派生类Derived来说，它一共有四个成员，分别是：隐藏的父类Base、x、y、z</p>
<p>两层继承内存结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123223943234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="可访问性">可访问性</h2>
<hr>
<p>公有继承方式下，对于派生类的成员函数，本类的private,protected,public数据成员都可以访问，“自己可以访问自己的私有公有保护”，但是不可以访问父类的private成员，父类的protected和public成员可以访问</p>
<p>如下图：==本类的成员函数不可以访问父类的私有数据成员，其余的都可以访问==</p>
<p><img src="https://img-blog.csdnimg.cn/20201123223955144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>如果是私有继承方式，仍旧不能访问父类的私有数据成员，其余的可以访问，<strong>私有继承只是把父类的保护和公有成员的属性改为私有的了</strong>，公有继承不改变父类保护和公有成员的属性</p>
<p>如果是保护继承方式，仍旧不能访问父类的私有数据成员，其余的可以访问，保护继承只是把父类的保护和公有成员的属性改为保护的了</p>
<p>总结：继承关系中，在派生类中可以访问继承来的对象的保护和公有，继承来的对象的私有不可访问</p>
<p>多层继承关系中也是一样的</p>
<p>私有继承来的则有一个私有的隐藏父类对象，保护继承来的则有一个保护的隐藏父类对象，公有继承来的则有一个公有的隐藏父类对象，继承方式决定了隐藏的父类的对象的可访问性</p>
<p>在派生类中指的是派生类的成员函数(Derived::set())，在派生类外则如该派生类的对象(Derived der;)，在派生类中可以访问继承来的对象的保护和公有，派生类外只有公有成员可以直接访问</p>
<p>保护成员的优势：无论何种继承方式，父类的私有都不可访问，而对于保护成员，无论何种继承方式在派生类中都是可直接访问的</p>
<p><img src="https://img-blog.csdnimg.cn/20201123224012199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="成员属性为protected的优点">成员属性为protected的优点</h2>
<hr>
<p>对于一个单独的类来说，private成员和protected成员都是在类内可以直接访问的，在类外不可以直接访问，在这方面没什么区别。</p>
<p>在有继承的情况下，无论何种继承方式，private成员都无法在派生类中直接被访问。而对于protected成员，无论何种继承方式，在派生类中都是可以直接访问的，这就是protected成员的优点</p>
<p>那么在什么情况下基类的protected成员的类内直接访问特性能传递到派生类的派生类中呢？这要根据不同的派生方式决定：</p>
<ul>
<li>对于公有派生或保护派生，基类的protected成员在派生类中依然保持protected访问权限。因此，protected成员的类内直接访问特性可以被继承传递到派生类的派生类中</li>
<li>对于私有派生，基类的protected成员在派生类中变成了private成员，此时基类的protected成员在派生类内部可以直接访问，但是无法在派生类的派生类中被直接访问。在继承或派生链中，一旦出现私有继承，基类成员的“类内直接访问特性”就无法在派生类中继续传递下去</li>
</ul>
<p>小结：protected成员的优点：既可以在本类中实现数据的隐藏（类内可直接访问，类外不可被直接访问），又可以将其类内直接访问特性传递到派生类中（在派生类中可以直接访问，类外不可直接访问）。而private成员不具备将类内直接访问特性传递到派生类中</p>
<h2 id="构造、析构顺序">构造、析构顺序</h2>
<hr>
<p>若一个类是由多个基类派生出来的，则在定义派生类构造函数时，需要调用基类的构造函数，初始化基类成员</p>
<p>派生类构造函数的一般格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类外定义时</span></span><br><span class="line">ClassName::ClassName(args) : Base1(arg_1),Base2(arg_2),...</span><br><span class="line">&#123;</span><br><span class="line">    派生类自身的构造函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类构造函数的执行顺序为：首先依次调用基类的构造函数Base1(arg_1), Base2(arg_2), … ,然后执行派生类自身的构造函数体</p>
<p>析构顺序为：首先执行派生类自身的析构函数体，然后按~Basen()…~Base2(), ~Base1()，的顺序调用基类的析构函数，即析构函数的执行顺序与构造函数相反</p>
<p>若在派生类中除了包含基类成员，还包含对象成员，则在派生类的构造函数的初始化成员列表中不仅要列出基类的构造函数，也要列举对象成员的构造函数。构造时，先调用基类的构造函数，再调用对象成员的构造函数，最后进入派生类自身的构造函数，析构顺序与之相反</p>
<h2 id="构造函数、析构函数继承问题">构造函数、析构函数继承问题</h2>
<hr>
<p>C++中派生类继承基类的成员，包括数据成员和成员函数。例如基类的私有数据成员被派生类继承后，即使在派生类中不能直接访问，但它也被继承了。</p>
<p>但是基类的构造函数和析构函数不会被派生类继承，而只能通过派生类的构造函数或析构函数自动调用，完成对基类数据成员的构建或清理工作</p>
<h2 id="二义性和支配规则">二义性和支配规则</h2>
<hr>
<p>==二义性==（访问冲突）：在多重继承中，当在派生类中出现两个以上的同名可直接访问的基类成员函数时，便出现了二义性，即访问冲突，如下图：（A类和B类具有同名成员x和Show()，它们均被继承到C类中）</p>
<p><img src="https://img-blog.csdnimg.cn/20201123224028728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>解决方法：</p>
<ul>
<li>定义基类时，保证一个基类中的成员名与另一个基类中的成员名不相同</li>
<li>在派生类中使用作用域运算符来限定所访问的成员是属于哪一个基类的</li>
</ul>
<p>由于C++是通过作用域运算符来解决访问二义性问题，因此规定任一基类在派生类中只能被直接继承一次，否则访问冲突无法通过作用域运算符解决。</p>
<p>==支配规则==：在C++中，允许派生类中新增加的成员名与其基类的成员名相同，这种同名并不产生访问二义性。在派生类中访问同名成员时，若直接用成员名访问，则访问的是派生类自身的成员（就近）；要访问基类的同名成员，可以使用作用域运算符来限定。即对同名成员的访问，派生类优先，这种优先关系称为支配规则</p>
<h2 id="虚基类">虚基类</h2>
<hr>
<p>对于如下左图的多重继承关系中，在D类中包含了基类A的两个拷贝，所以一个D类对象包含了两份A类对象的数据成员。此时在D类的成员函数中，若欲访问A的成员x，则必须以B::x和C::x区分（注意：::不能嵌套使用）</p>
<p><img src="https://img-blog.csdnimg.cn/20201123224040809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>若欲得到上图右边的继承关系，即要使得公共的基类在派生类中只有一个拷贝，则需要将A类说明成<strong>虚基类</strong>，说明虚基类的方法是在派生类B、C的定义中，在基类A的类名前加上关键字virtual，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> C</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>说明成虚基类的一般格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> <span class="keyword">virtual</span> 继承方式 基类名<span class="comment">//virtual也可以放在继承方式和基类名中间，但一般放在前面</span></span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>有虚基类时构造函数的调用顺序：若派生类中有多个基类，这些基类中有虚基类也有非虚基类，则先调用虚基类的构造函数，再调用非虚基类的构造函数。虚基类的构造函数按虚基类的继承顺序调用，非虚基类的构造函数按非虚基类的继承顺序调用，代码验证如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" A "</span>;&#125;</span><br><span class="line">    ~A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~A "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" B "</span>;&#125;</span><br><span class="line">    ~B() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~B "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" C "</span>;&#125;</span><br><span class="line">    ~C() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~C "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" D "</span>;&#125;</span><br><span class="line">    ~D() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">" ~D "</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A,<span class="keyword">public</span> D,<span class="keyword">virtual</span> <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20201123224057562.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="赋值兼容与切片现象">赋值兼容与切片现象</h2>
<hr>
<p>==赋值兼容规则==：在任何需要基类对象的地方都可以用公有派生类的对象来代替（只适合公有派生），即可以将公有派生类的对象赋值给基类对象，反之不允许</p>
<ol>
<li>派生类的对象可以赋值给基类的对象，这时是把派生类对象中从对应基类中继承来的隐藏对象赋值给基类对象。反过来不行，因为派生类的新成员无值可赋。</li>
<li>可以将一个派生类的对象的地址赋给其基类的指针变量，但只能通过这个指针访问派生类中由基类继承来的隐藏对象，不能访问派生类中的新成员。同样也不能反过来做。</li>
<li>派生类对象可以初始化基类的引用。引用是别名，但这个别名只能包含派生类对象中的由基类继承来的隐藏对象。</li>
</ol>
<p>总结：派生类对象可以给基类对象赋值，<code>base = derived;</code>，<code>person = student;</code></p>
<p>子对象可以赋值给父对象的原因：公有派生代表”是一个“的意思，is a，Student  is  a person. 所以student可以赋值给person</p>
<p>例如下：人可以跳舞，学生是人，学生也就可以跳舞</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> x = <span class="number">0</span>):value(x)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">int</span> x = <span class="number">0</span>):num(x),Person(x+<span class="number">10</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">(Person &amp; per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">se</span><span class="params">(<span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">st</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    Person &amp;ps = st;<span class="comment">//派生类对象可以初始化基类的引用</span></span><br><span class="line">    Person *p = &amp;st;<span class="comment">//派生类的对象的地址赋给其基类的指针变量</span></span><br><span class="line">    se = st;<span class="comment">//派生类的对象可以赋值给基类的对象</span></span><br><span class="line">    </span><br><span class="line">    dance(se);<span class="comment">//人可以跳舞</span></span><br><span class="line">    <span class="comment">//在任何需要基类对象的地方都可以用公有派生类的对象来代替</span></span><br><span class="line">    dance(st);<span class="comment">//学生也可以跳舞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何基类出现的地方，派生类都应当可以出现，但是反过来不行</p>
<p>==C++切片现象==：当子类对象去给父类对象赋值的时候，手起刀落，把子类中隐藏的父对象切出来赋值给父对象</p>
<p><img src="https://img-blog.csdnimg.cn/20201123224110394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gVrUa7TO-1606142299958)(img/C++%EF%BC%9A%E7%BB%A7%E6%89%BF.img/image-20201121180510522.png)]"><br>
派生类的对象的地址(st)赋给其基类的指针变量§时，p只能识别派生类隐藏的父对象那一部分(value)，p不能识别num那一部分，因为p的类型是Person类型，它只能识别Person类型那么多的内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *p = &amp;st;<span class="comment">//派生类的对象的地址赋给其基类的指针变量</span></span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">WangGarrison</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://wanggarrison.top/2021/02/03/C-%EF%BC%9A%E7%BB%A7%E6%89%BF/">http://wanggarrison.top/2021/02/03/C-：继承/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_email"></a><a class="a2a_dd" href="https://www.addtoany.com/share" target="_blank" rel="noopener"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-2-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8Efork/"><img class="prev_cover" src="/img/1index-bg.png" onerror="onerror=null;src='/img/1index-bg.png'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Linux：线程-2-——线程安全、线程与fork</div></div></a></div><div class="next-post pull_right"><a href="/2021/02/03/Linux%EF%BC%9A%E7%BA%BF%E7%A8%8B-1-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%BA%93%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"><img class="next_cover" src="/img/1index-bg.png" onerror="onerror=null;src='/img/1index-bg.png'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Linux：线程-1-——线程、线程库、线程同步</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'wRBaqYsEc12U7sIngUG9fsqw-gzGzoHsz',
  appKey: 'W8z4NsMU9uPUGmvT4k38nLwV',
  notify: false,
  verify: false,
  placeholder: '留言支持MarkDown语法...',
  avatar: 'retro',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(/img/1index-bg.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By WangGarrison</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/"});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>