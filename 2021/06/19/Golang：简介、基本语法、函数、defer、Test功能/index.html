<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Golang：简介、基本语法、函数、defer、Test功能 | WangGarrison</title><meta name="description" content="春招找实习告一段落了，好长时间没更CSDN的博客，期间写的一些笔记用 typora + git 直接推到github里面了，就没在CSDN里再发了，我的github：https:&#x2F;&#x2F;github.com&#x2F;WangGarrison 本篇博客简单记录一下最近学的golang  Go语言简介 Go语言特性  静态强类型、编译型、并发型 具有垃圾回收功能 无类和继承，通过接口实现多态 不支持自定义的泛型"><meta name="author" content="WangGarrison"><meta name="copyright" content="WangGarrison"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Golang：简介、基本语法、函数、defer、Test功能"><meta name="twitter:description" content="春招找实习告一段落了，好长时间没更CSDN的博客，期间写的一些笔记用 typora + git 直接推到github里面了，就没在CSDN里再发了，我的github：https:&#x2F;&#x2F;github.com&#x2F;WangGarrison 本篇博客简单记录一下最近学的golang  Go语言简介 Go语言特性  静态强类型、编译型、并发型 具有垃圾回收功能 无类和继承，通过接口实现多态 不支持自定义的泛型"><meta name="twitter:image" content="http://wanggarrison.top/img/1index-bg.png"><meta property="og:type" content="article"><meta property="og:title" content="Golang：简介、基本语法、函数、defer、Test功能"><meta property="og:url" content="http://wanggarrison.top/2021/06/19/Golang%EF%BC%9A%E7%AE%80%E4%BB%8B%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81defer%E3%80%81Test%E5%8A%9F%E8%83%BD/"><meta property="og:site_name" content="WangGarrison"><meta property="og:description" content="春招找实习告一段落了，好长时间没更CSDN的博客，期间写的一些笔记用 typora + git 直接推到github里面了，就没在CSDN里再发了，我的github：https:&#x2F;&#x2F;github.com&#x2F;WangGarrison 本篇博客简单记录一下最近学的golang  Go语言简介 Go语言特性  静态强类型、编译型、并发型 具有垃圾回收功能 无类和继承，通过接口实现多态 不支持自定义的泛型"><meta property="og:image" content="http://wanggarrison.top/img/1index-bg.png"><meta property="article:published_time" content="2021-06-19T15:32:40.122Z"><meta property="article:modified_time" content="2021-06-19T15:34:43.362Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wanggarrison.top/2021/06/19/Golang%EF%BC%9A%E7%AE%80%E4%BB%8B%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81defer%E3%80%81Test%E5%8A%9F%E8%83%BD/"><link rel="next" title="Linux：I-O复用——poll、epoll" href="http://wanggarrison.top/2021/02/03/Linux%EF%BC%9AI-O%E5%A4%8D%E7%94%A8%E2%80%94%E2%80%94poll%E3%80%81epoll/"><link rel="stylesheet" href="/font"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: false,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/shouyetubiao.css"><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-dangan"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei-copy"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwo"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content" style="overflow: hidden;"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">1.</span> <span class="toc-text">Go语言简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言特性"><span class="toc-number">1.1.</span> <span class="toc-text">Go语言特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译型语言"><span class="toc-number">1.2.</span> <span class="toc-text">编译型语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#目录结构"><span class="toc-number">1.3.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语法特性"><span class="toc-number">1.4.</span> <span class="toc-text">Go语法特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">2.</span> <span class="toc-text">Go语言基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义基本类型"><span class="toc-number">2.1.</span> <span class="toc-text">定义基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量的初始化、多赋值问题"><span class="toc-number">2.2.</span> <span class="toc-text">变量的初始化、多赋值问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名变量"><span class="toc-number">2.3.</span> <span class="toc-text">匿名变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量作用域与生命周期"><span class="toc-number">2.4.</span> <span class="toc-text">变量作用域与生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型转换"><span class="toc-number">2.5.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针"><span class="toc-number">2.6.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量逃逸分析Escape-Analysis"><span class="toc-number">2.7.</span> <span class="toc-text">变量逃逸分析Escape Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-number">2.8.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟枚举"><span class="toc-number">2.9.</span> <span class="toc-text">模拟枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型别名type"><span class="toc-number">2.10.</span> <span class="toc-text">类型别名type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go关键字与标识符"><span class="toc-number">2.11.</span> <span class="toc-text">Go关键字与标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串和数值类型的相互转换"><span class="toc-number">2.12.</span> <span class="toc-text">字符串和数值类型的相互转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">3.</span> <span class="toc-text">Go流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if语句"><span class="toc-number">3.1.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循坏结构"><span class="toc-number">3.2.</span> <span class="toc-text">循坏结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch"><span class="toc-number">3.3.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goto"><span class="toc-number">3.4.</span> <span class="toc-text">goto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#练习：二分查找、冒泡排序"><span class="toc-number">3.5.</span> <span class="toc-text">练习：二分查找、冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">4.</span> <span class="toc-text">Go语言函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#传值、传引用"><span class="toc-number">4.1.</span> <span class="toc-text">传值、传引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回值"><span class="toc-number">4.2.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数变量"><span class="toc-number">4.3.</span> <span class="toc-text">函数变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数"><span class="toc-number">4.4.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">4.5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变参数"><span class="toc-number">4.6.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer延迟执行"><span class="toc-number">4.7.</span> <span class="toc-text">defer延迟执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宕机panic"><span class="toc-number">4.8.</span> <span class="toc-text">宕机panic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宕机恢复recover"><span class="toc-number">4.9.</span> <span class="toc-text">宕机恢复recover</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数运行时间"><span class="toc-number">4.10.</span> <span class="toc-text">函数运行时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go语言函数的底层实现"><span class="toc-number">4.11.</span> <span class="toc-text">Go语言函数的底层实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">5.</span> <span class="toc-text">Test功能测试函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">6.</span> <span class="toc-text">附录：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">7.</span> <span class="toc-text">Go标准库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">8.</span> <span class="toc-text">使用代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">9.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/1index-bg.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">WangGarrison</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-dangan"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei-copy"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwo"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Golang：简介、基本语法、函数、defer、Test功能</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2021-06-19 23:32:40"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2021-06-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2021-06-19 23:34:43"><i class="fa fa-history" aria-hidden="true"></i> Updated 2021-06-19</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Golang/">Golang</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>Word count:</span><span class="word-count">13.6k</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>春招找实习告一段落了，好长时间没更CSDN的博客，期间写的一些笔记用 typora + git 直接推到github里面了，就没在CSDN里再发了，我的github：<a href="https://github.com/WangGarrison" target="_blank" rel="noopener">https://github.com/WangGarrison</a><br>
本篇博客简单记录一下最近学的golang</p>
</blockquote>
<h1>Go语言简介</h1>
<h2 id="Go语言特性">Go语言特性</h2>
<ul>
<li>静态强类型、编译型、并发型</li>
<li>具有垃圾回收功能</li>
<li>无类和继承，通过接口实现多态</li>
<li>不支持自定义的泛型类型</li>
<li>将“++”、“–”从运算符降级为语句</li>
<li>保留指针，但默认阻止指针运算</li>
<li>将切片和字典作为内置类型，从运行时的层面进行优化</li>
<li>Go语言的源码无须头文件，编译的文件都来自于后缀名为<code>.go</code>的源码文件。</li>
<li>语句结尾不写分号，写了一些编译器保存时会自动去掉</li>
<li>注释方式和C/C++相同</li>
</ul>
<h2 id="编译型语言">编译型语言</h2>
<ul>
<li>Go 使用编译器来编译代码。编译器将源代码编译成二进制（或字节码）格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行 Go 程序，程序员必须执行如下步骤：
<ul>
<li>使用文本编辑器创建 Go 程序并保存</li>
<li>编译</li>
<li>运行编译得到的可执行文件</li>
</ul>
</li>
<li>Go 自带了编译器，因此无须单独安装编译器</li>
</ul>
<p>在Go语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go语言在这 3 个条件之间做到了最佳的平衡：==快速编译，高效执行，易于开发==。</p>
<p>Go语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发可以在 Windows 上运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go语言做到了真正的国际化！</p>
<p><strong>编译原理</strong></p>
<ul>
<li>词法与语法分析</li>
<li>类型检查</li>
<li>中间代码生成</li>
<li>机器码生成</li>
</ul>
<h2 id="目录结构">目录结构</h2>
<ul>
<li>一个Go语言项目的目录一般包含以下三个子目录：
<ul>
<li>src 目录：放置项目和库的源文件；</li>
<li>pkg 目录：放置编译后生成的包/库的归档文件；</li>
<li>bin 目录：放置编译后生成的可执行文件。</li>
</ul>
</li>
<li>源文件：
<ul>
<li>命令源文件：如果一个 Go 源文件被声明属于 main 包，并且该文件中包含 main 函数，则它就是命令源码文件。命令源文件属于程序的入口，可以通过Go语言的<code>go run </code>命令运行或者通过<code>go build </code>命令生成可执行文件。</li>
<li>库源文件：库源文件则是指存在于某个包中的普通源文件，并且库源文件中不包含 main 函数。</li>
</ul>
</li>
</ul>
<h2 id="Go语法特性">Go语法特性</h2>
<p><strong>1：for循环的条件不带圆括号</strong></p>
<ul>
<li>
<p>for 两边的括号被去掉，int 声明被简化为<code>:=</code>，直接通过编译器右值推导获得 a 的变量类型并声明。</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    <span class="comment">//循坏代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2：if表达式条件不带原括号</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> 表达式&#123;</span><br><span class="line">	      <span class="comment">//表达式成立执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3：强制的代码风格</strong></p>
<ul>
<li>左括号必须紧接着语句不换行，其他样式的括号将被视为代码编译错误</li>
<li>一些Go语言的开发环境或者编辑器在保存时，都会使用格式化工具对代码进行格式化，让代码提交时已经是统一格式的代码。</li>
</ul>
<p><strong>4：i++</strong></p>
<ul>
<li>
<p>在Go语言中，自增操作符不再是一个操作符，而是一个语句。因此，在Go语言中自增只有一种写法：</p>
</li>
<li>
<pre class=" language-language-go"><code class="language-language-go">i++
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果写成前置自增`++i`，或者赋值后自增`a=i++`都将导致编译错误。</span><br><span class="line"></span><br><span class="line">## Hello World</span><br><span class="line"></span><br><span class="line">创建一个hello.go文件，输入如下代码：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">package main   // 声明main包</span><br><span class="line"></span><br><span class="line">import <span class="string">"fmt"</span>  // 导入 fmt 包，打印字符串是需要用到</span><br><span class="line"></span><br><span class="line">func main() &#123; </span><br><span class="line">    fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p><strong>运行代码：</strong></p>
<ul>
<li>执行代码：<code>go run hello.go   </code></li>
<li>生成二进制文件，再执行二进制文件：<code>go bulid hello.go</code> <code>./hello</code></li>
<li>VSCode点击run，如果提示<code>go. mod file not find</code>，执行<code>go env -w GO111MODULE=auto</code>后再点击run</li>
</ul>
<p><strong>go run与go build：</strong></p>
<ul>
<li>go run：编译并运行程序，但不会产生exe文件，运行速度也相应较慢</li>
<li>go build：编译不运行，生成exe文件</li>
</ul>
<blockquote>
<p><strong>package</strong></p>
</blockquote>
<p>**package：**Go语言以“包”作为管理单位，每个 Go 源文件必须先声明它所属的包，所以我们会看到每个 Go 源文件的开头都是一个 package 声明，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> name</span><br></pre></td></tr></table></figure>
<p>其中 package 是声明包名的关键字，name 为包的名字。</p>
<p>Go语言的包与文件夹是一一对应的，它具有以下几点特性：</p>
<ul>
<li>一个目录下的同级文件属于同一个包。</li>
<li>包名可以与其目录名不同。</li>
<li>main 包是Go语言程序的入口包，一个Go语言程序必须<strong>有且仅有一个</strong> main 包。如果一个程序没有 main 包，那么编译时将会出错，无法生成可执行文件。</li>
</ul>
<blockquote>
<p><strong>import</strong></p>
</blockquote>
<p>在包声明之后，是 import 语句，用于导入程序中所依赖的包，导入的包名使用双引号<code>&quot;&quot;</code>包围，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"name"</span></span><br></pre></td></tr></table></figure>
<p>其中 import 是导入包的关键字，name 为所导入包的名字。</p>
<p>代码第 4 行导入了 fmt 包，这行代码会告诉 Go 编译器，我们需要用到 fmt 包中的函数或者变量等，fmt 包是Go语言标准库为我们提供的，用于格式化输入输出的内容（类似于C语言中的 stdio.h 头文件）</p>
<p>也可以使用一个 import 关键字导入多个包，此时需要用括号<code>( )</code>将包的名字包围起来，并且每个包名占用一行，也就是写成下面的样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"name1"</span></span><br><span class="line">    <span class="string">"name2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>main函数</p>
</blockquote>
<p>main 函数，它是Go语言程序的入口函数，也即程序启动后运行的第一个函数。main 函数只能声明在 main 包中，不能声明在其他包中，并且，一个 main 包中也必须有且仅有一个 main 函数。这点和C/C++是类似的</p>
<p>main 函数是自定义函数的一种，在Go语言中，所有函数都以关键字 func 开头的，定义格式如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>fmt.Println(“Hello World”)</strong></p>
</blockquote>
<p>Println 是 fmt 包中的一个函数，它用来格式化输出数据，比如字符串、整数、小数等，类似于C语言中的 printf 函数</p>
<p>注意，Println 函数打印完成后会自动换行，ln是 line 的缩写。（Print不自动换行）</p>
<p>点号<code>.</code>是Go语言运算符的一种，这里表示调用 fmt 包中的 Println 函数。</p>
<h1>Go语言基本语法</h1>
<h2 id="定义基本类型">定义基本类型</h2>
<p>go基本类型有：</p>
<ul>
<li>bool（布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用 if 语句显式的进行转换，Go语言中不允许将整型强制转换为布尔型）</li>
<li>string // len(str)可以获取一个字符串的长度，支持下标索引访问，支持拼接s := s1 + s2，支持+=，``可以定义多行字符串</li>
<li>int、int8、int16、int32、int64，分别对应平台字节、8、16、32、64 bit大小的有符号整数</li>
<li>uint、uint8、uint16、uint32、uint64、uintptr</li>
<li>byte // uint8 的别名，代表了 ASCII 码的一个字符</li>
<li>rune // int32 的别名 代表一个 Unicode 码，当需要处理中文、日文或者其他复合字符用到</li>
<li>float32、float64</li>
<li>complex64（32位实数和虚数）、complex128（64位实数和虚数）  //复数</li>
</ul>
<blockquote>
<p>哪些情况下使用int，哪些情况使用int8、int16等</p>
<p>int：程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化</p>
<p>int8等：在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 int 和 uint，使用指定bit的int8等</p>
</blockquote>
<p><strong>声明变量</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">int</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器自动推导类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明多个变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">	b <span class="keyword">string</span></span><br><span class="line">	c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    e <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短方式</span></span><br><span class="line">名字 := 表达式</span><br><span class="line">i,j := <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要注意的是，简短模式（short variable declaration）有以下限制：</span></span><br><span class="line"><span class="comment">- 定义变量，同时显式初始化。</span></span><br><span class="line"><span class="comment">- 不能提供数据类型。</span></span><br><span class="line"><span class="comment">- 只能用在函数内部。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Go语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b;</code> 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b *<span class="keyword">int</span>  <span class="comment">//a和b都是整型指针</span></span><br></pre></td></tr></table></figure>
<p>当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。==所有的内存在 Go 中都是经过初始化的==。</p>
<p>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。</p>
<p><strong>浮点数声明</strong></p>
<p>浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">纯文本复制</span><br><span class="line"><span class="keyword">const</span> e = <span class="number">.71828</span> <span class="comment">// 0.71828</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="number">1.</span>     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Avogadro = <span class="number">6.02214129e23</span>  <span class="comment">// 阿伏伽德罗常数</span></span><br><span class="line"><span class="keyword">const</span> Planck   = <span class="number">6.62606957e-34</span> <span class="comment">// 普朗克常数</span></span><br></pre></td></tr></table></figure>
<p>用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)  <span class="comment">//保留两位小数</span></span><br></pre></td></tr></table></figure>
<p><strong>复数声明</strong></p>
<p>声明复数的语法格式如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">complex128</span> = <span class="built_in">complex</span>(x, y)name := <span class="built_in">complex</span>(x, y)</span><br></pre></td></tr></table></figure>
<p>其中 name 为复数的变量名，complex128 为复数的类型，“=”后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。</p>
<p>对于一个复数<code>z := complex(x, y)</code>，可以通过Go语言的内置函数<code>real(z) </code>来获得该复数的实部，也就是 x；通过<code>imag(z) </code>获得该复数的虚部，也就是 y</p>
<p>复数也可以用<code>==</code>和<code>!=</code>进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的</p>
<h2 id="变量的初始化、多赋值问题">变量的初始化、多赋值问题</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="comment">//注意：由于使用了:=，而不是赋值的等，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误</span></span><br><span class="line"></span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">conn2, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">net.Dial 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象（conn），一个是错误对象（err）</span></span><br><span class="line"><span class="comment">注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>多赋值问题</strong></p>
<ul>
<li>
<p>对左侧操作数中的表达式，索引值进行计算和确定，首先确定左侧的操作数的地址，然后对右侧的赋值表达式进行计算，如果发现右侧的表达式计算引用左侧的变量，则创建临时变量进行值拷贝，最后完成计算</p>
</li>
<li>
<p>从左到右的顺序依次计算</p>
</li>
<li>
<p>例如使用go交换两个数字：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法一：</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">t = a</span><br><span class="line">a = b</span><br><span class="line">b = t</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二：</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">b, a = a, b  <span class="comment">//多重赋值时，变量的左值和右值按从左到右的顺序赋值。先算等号右边的值，把a的值存为t1，把b的值存为t2，然后把t1赋值给变量b，t2赋值给变量a</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="匿名变量">匿名变量</h2>
<p>在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。</p>
<p>匿名变量的特点是一个下画线“<em>”，“</em>”本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, _ := GetData()</span><br><span class="line">	fmt.Print(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<h2 id="变量作用域与生命周期">变量作用域与生命周期</h2>
<p><strong>变量作用域概念与C/C++类似</strong></p>
<ul>
<li>
<p>函数内定义的变量称为局部变量</p>
</li>
<li>
<p>函数外定义的变量称为全局变量：全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写</p>
</li>
<li>
<p>函数定义中的变量称为形式参数</p>
</li>
<li>
<p>Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。</p>
</li>
</ul>
<p><strong>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。</strong></p>
<ul>
<li>全局变量：它的生命周期和整个程序的运行周期是一致的</li>
<li>局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止</li>
<li>形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁</li>
</ul>
<h2 id="数据类型转换">数据类型转换</h2>
<p>Go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：</p>
<p>注意：==C中强制类型转换是(int)，go中是int()==</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB = typeB(valueOfTypeA)</span><br><span class="line">a := <span class="number">5.0</span></span><br><span class="line">b := <span class="keyword">int</span>(a)</span><br></pre></td></tr></table></figure>
<p>只有相同底层类型的变量之间可以进行相互转换（如将 int16 类型转换成 int32 类型），不同底层类型的变量相互转换时会引发编译错误（如将 bool 类型转换为 int 类型）</p>
<p>浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。</p>
<h2 id="指针">指针</h2>
<p>Go语言为程序员提供了控制数据结构指针的能力，但是，==并不能进行指针运算==</p>
<p>指针（pointer）在Go语言中可以被拆分为两个核心概念：</p>
<ul>
<li>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</li>
<li>切片，由指向起始元素的原始指针、元素数量和容量组成。</li>
</ul>
<p>受益于这样的约束和拆分，Go语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v 的类型为T，ptr 的类型为*T</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> ptr = &amp;a</span><br><span class="line"><span class="keyword">var</span> ptr2 *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, ptr)  <span class="comment">// *intfmt.Printf("%d\n", *ptr)  // 10</span></span><br><span class="line">*ptr2 = <span class="number">20</span></span><br><span class="line">fmt.Print(a)  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。和C中用法相同</p>
<p><strong>创建指针的另一种方法——new() 函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></table></figure>
<p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p>
<h2 id="变量逃逸分析Escape-Analysis">变量逃逸分析Escape Analysis</h2>
<p>变量逃逸分析（Escape Analysis）——自动决定变量分配方式，提高运行效率</p>
<p>堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 C/C++ 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配等。程序员不得不花费很长的时间在不同的项目中学习、记忆这些概念并加以实践和使用。</p>
<p>Go语言将这个过程整合到了编译器中，命名为“变量逃逸分析”。通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配。</p>
<p>编译器觉得变量应该分配在堆和栈上的原则是：</p>
<ul>
<li>变量是否被取地址；</li>
<li>变量是否发生逃逸。</li>
</ul>
<p>Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</p>
<p>简单来说，编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。</p>
<blockquote>
<p>指针逃逸：当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。</p>
<p>逃逸分析：在编译原理中，分析指针动态范围的方法称之为<code>逃逸分析</code>。更简单来说，<code>逃逸分析</code>决定一个变量是分配在堆上还是分配在栈上。</p>
<p><a href="https://www.cnblogs.com/itbsl/p/10476674.html#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Go变量逃逸分析</a></p>
</blockquote>
<p><strong>逃逸实例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 var 还是 new 关键字声明变量都不会影响编译器的选择。*/</span></span><br><span class="line"><span class="keyword">var</span> global *<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 f 里的变量 x 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的。用Go语言的术语说，这个局部变量 x 从函数 f 中逃逸了</p>
<p>相反，当函数 g 返回时，变量 *y 不再被使用，也就是说可以马上被回收的。因此，*y 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 *y 的存储空间，也可以选择在堆上分配，然后由Go语言的 GC（垃圾回收机制）回收这个变量的内存空间</p>
<p>在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响</p>
<h2 id="常量">常量</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name [<span class="keyword">type</span>] = value</span><br><span class="line"><span class="keyword">const</span> pi <span class="keyword">int</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<p>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</p>
<ul>
<li>正确的做法：const c1 = 2/3</li>
<li>错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() 用做值</li>
</ul>
<p>和变量声明一样，可以批量声明多个常量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	e = <span class="number">2.71</span></span><br><span class="line">	pi = <span class="number">3.14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>因为常量的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LEN = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> arr[LEN] <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) <span class="comment">// 1 1 2 2</span></span><br></pre></td></tr></table></figure>
<p><strong>iota 常量生成器</strong></p>
<ul>
<li>常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"><span class="comment">//周日将对应 0，周一为 1，以此类推。</span></span><br></pre></td></tr></table></figure>
<p><strong>无类型常量</strong></p>
<p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 int 或 float64，或者是类似 time.Duration 这样的基础类型，但是许多常量并没有一个明确的基础类型。</p>
<p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<p>通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<p>例如：math.Pi ==无类型的浮点数常量，可以直接用于任意需要浮点数==或复数的地方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure>
<h2 id="模拟枚举">模拟枚举</h2>
<p>Go语言现阶段没有枚举类型，但是可以使用const常量与 iota 来模拟枚举类型，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"><span class="comment">//周日将对应 0，周一为 1，以此类推。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出所有枚举值</span></span><br><span class="line">fmt.Println(Sunday, Monday, Tuesday,)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举类型并赋初值</span></span><br><span class="line"><span class="keyword">var</span> today Weekday = Sunday</span><br><span class="line">fmt.Println(today)  <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>当然，iota 不仅可以生成每次增加 1 的枚举值。还可以利用 iota 来做一些强大的枚举常量值生成器。下面的代码可以方便的生成标志位常量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (    </span><br><span class="line">    FlagNone = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">//每次将上一次的值左移一位（二进制位），以得出每一位的常量值</span></span><br><span class="line">    FlagRed</span><br><span class="line">    FlagGreen</span><br><span class="line">    FlagBlue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%d %d %d\n"</span>, FlagRed, FlagGreen, FlagBlue)  <span class="comment">//2 4 8 （10进制）</span></span><br><span class="line">fmt.Printf(<span class="string">"%b %b %b\n"</span>, FlagRed, FlagGreen, FlagBlue)  <span class="comment">//10 100 1000（2进制）</span></span><br></pre></td></tr></table></figure>
<p>代码输出如下：</p>
<p>2 4 8<br>
10 100 1000</p>
<h2 id="类型别名type">类型别名type</h2>
<p>类型别名是 Go 1.9 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 C/C++语言中，代码重构升级可以使用宏快速定义一段新的代码，Go语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。</p>
<p>在 Go 1.9 版本之前定义内建类型的代码是这样写的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>
<p>而在 Go 1.9 版本之后变为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>
<p>这个修改就是配合类型别名而进行的修改。</p>
<p><strong>类型定义：</strong><code>type Weekday int</code></p>
<p><strong>类型别名：</strong><code>type newtype = oldtype</code></p>
<p><strong>类型别名与类型定义区别：</strong></p>
<ul>
<li>
<p>表面上看：类型别名多一个等号</p>
</li>
<li>
<p>编译过程：类型的别名只会在代码中存在，编译完成时并不会有别名那个类型。</p>
</li>
<li>
<p>代码示例如下：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a NewInt</span><br><span class="line">	<span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//类型定义：type of a:main.NewInt</span></span><br><span class="line">	fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//类型别名：type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Go关键字与标识符">Go关键字与标识符</h2>
<p>关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。Go语言中的关键字一共有 25 个：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody>
<tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody>
</table>
<p><strong>标识符</strong></p>
<p>标识符是指Go语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线<code>_</code>、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。</p>
<p>下划线<code>_</code>是一个特殊的标识符，称为空白标识符，它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用<code>_</code>作为变量对其它变量进行赋值或运算。</p>
<p>标识符的命名需要遵守以下规则：</p>
<ul>
<li>由 26 个英文字母、0~9、<code>_</code>组成；</li>
<li>不能以数字开头，例如 var 1num int 是错误的；</li>
<li>Go语言中严格区分大小写；</li>
<li>标识符不能包含空格；</li>
<li>不能以系统保留关键字作为标识符，比如 break，if 等等。</li>
</ul>
<p>命名标识符时还需要注意以下几点：</p>
<ul>
<li>标识符的命名要尽量采取简短且有意义；</li>
<li>不能和标准库中的包名重复；</li>
<li>为变量、函数、常量命名时采用驼峰命名法，例如 stuName、getVal；</li>
</ul>
<p>当然Go语言中的变量、函数、常量名称的首字母也可以大写，==如果首字母大写，则表示它可以被其它的包访问；如果首字母小写，则表示它只能在本包中使用==</p>
<p>在Go语言中还存在着一些特殊的标识符，叫做预定义标识符，如下表所示：</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody>
</table>
<p>预定义标识符一共有 36 个，主要包含Go语言中的基础数据类型和内置函数，这些预定义标识符也不可以当做标识符来使用。</p>
<h2 id="字符串和数值类型的相互转换">字符串和数值类型的相互转换</h2>
<p>Go语言中的 strconv 包提供了字符串和基本数据类型之间的转换功能，strconv 包中常用的函数包括 Atoi()、Itia()、parse 系列函数、format 系列函数、append 系列函数等</p>
<p><strong>整型转字符串：Itoa()</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span>  //函数签名</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">100</span></span><br><span class="line">str := strconv.Itoa(num)</span><br></pre></td></tr></table></figure>
<p><strong>字符串转整型：Atoi()</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(i <span class="keyword">int</span>, err error)</span></span>  </span><br><span class="line"><span class="comment">//函数签名可以看出 Atoi() 函数有两个返回值，i 为转换成功的整型，err 在转换成功是为空转换失败时为相应的错误信息</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">"110"</span></span><br><span class="line">num1, err := strconv.Atoi(str1)</span><br></pre></td></tr></table></figure>
<p><strong>Parse系列函数：将字符串转换为指定类型的值，Parse 系列函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</strong></p>
<p><strong>ParseBool()：字符串转换为bool类型的值</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="comment">//它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">"1"</span></span><br><span class="line">boo1, err := strconv.ParseBool(str1)</span><br></pre></td></tr></table></figure>
<p><strong>ParseInt()：字符串转换为整数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"-11"</span></span><br><span class="line">num, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>ParseUint()：</strong> 函数的功能类似于 ParseInt() 函数，但 ParseUint() 函数不接受正负号，用于无符号整型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"11"</span></span><br><span class="line">num, err := strconv.ParseUint(str, <span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>ParseFloat()：</strong> 函数用于将一个表示浮点数的字符串转换为 float 类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"11"</span></span><br><span class="line">num, err := strconv.ParseUint(str, <span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Format 系列函数</strong></p>
<p>Format 系列函数实现了将给定类型数据格式化为字符串类型的功能，其中包括 FormatBool()、FormatInt()、FormatUint()、FormatFloat()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="literal">true</span></span><br><span class="line">str := strconv.FormatBool(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">str := strconv.FormatInt(num, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">uint64</span> = <span class="number">110</span></span><br><span class="line">str := strconv.FormatUint(num, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">3.1415926</span></span><br><span class="line">str := strconv.FormatFloat(num, <span class="string">'E'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Append 系列函数</strong></p>
<p>Append 系列函数用于将指定类型转换成字符串后追加到一个切片中，其中包含 AppendBool()、AppendFloat()、AppendInt()、AppendUint()。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b16 := []<span class="keyword">byte</span>(<span class="string">"int (base 16):"</span>)</span><br><span class="line">b16 = strconv.AppendInt(b16, <span class="number">-42</span>, <span class="number">16</span>)  <span class="comment">//将转换为10进制的string，追加到slice中</span></span><br></pre></td></tr></table></figure>
<h1>Go流程控制</h1>
<h2 id="if语句">if语句</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关键字 if 和 else 之后的左大括号&#123;必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号&#125;必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是非法的</span></span><br><span class="line"><span class="keyword">if</span> x&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 无效的, else要和上一个右大括号对齐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="循坏结构">循坏结构</h2>
<p>go只支持for关键字，不支持while和do while，for循坏结构和C类似，条件语句不用加括号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for死循坏：<code>for;; {}</code>简写成<code>for {}</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    sum++</span><br><span class="line">    <span class="keyword">if</span> sum &gt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言中的 for 循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，==Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量==</p>
<p><strong>break</strong></p>
<p>Go语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例：==break跳出的是JLoop标签标记的外层循坏==，continue语句也支持标签功能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	JLoop:</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> JLoop  <span class="comment">//跳出外层循坏</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">OuterLoop:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> j &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                <span class="keyword">continue</span> OuterLoop  <span class="comment">//结束当前循环，开启下一次的外层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>仿while</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt;= <span class="number">10</span>; &#123;</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化为:(就像while)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for range键值循坏</strong></p>
<p>for range 可以遍历数组、切片、字符串、map 及通道（channel），for range 语法上类似于其它语言中的 foreach 语句，一般形式为：(==val 始终为集合中对应索引的值拷贝==，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> map1 &#123;  </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 for range 遍历的返回值有一定的规律：</p>
<ul>
<li>数组、切片、字符串返回索引和值。</li>
<li>map 返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"key:%d, value:%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">    fmt.Println(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只获取value值</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch">switch</h2>
<p>Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数</p>
<p>Go语言改进了 switch 的语法设计，case 与 case 之间是独立的代码块，==不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行==，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">    fmt.Print(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">    fmt.Print(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>一分支多值</strong></p>
<p>当出现多个 case 要放在一起的时候，可以写成下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"mum"</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"mum"</span>, <span class="string">"daddy"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"family"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r <span class="keyword">int</span> = <span class="number">11</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r &gt; <span class="number">10</span> &amp;&amp; r &lt; <span class="number">20</span>:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>fallthrough—兼容C的case</strong></p>
<p>在Go语言中 case 是一个独立的代码块，执行完毕后不会像C语言那样紧接着执行下一个 case，但是为了兼容一些移植代码，依然加入了 fallthrough 关键字来实现这一功能，代码如下：（fallthrough只是为了兼容C，新编写的代码，不建议使用 fallthrough）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"hello"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s != <span class="string">"world"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<h2 id="goto">goto</h2>
<p>Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 跳转到标签</span></span><br><span class="line">                <span class="keyword">goto</span> breakHere</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动返回, 避免执行进入标签</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用goto可以集中处理错误，比如出现了错误，goto到一个处理错误的地方集中处理，如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">err = secondCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">goto</span> onExit</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">onExit:</span><br><span class="line">fmt.Println(err)</span><br><span class="line">exitProcess()</span><br></pre></td></tr></table></figure>
<h2 id="练习：二分查找、冒泡排序">练习：二分查找、冒泡排序</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用go语言实现二分查找</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Binary</span><span class="params">(arr []<span class="keyword">int</span>, left <span class="keyword">int</span>, right <span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> arr[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[mid] &gt; target &#123;</span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">	fmt.Println(Binary(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>, <span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go语言实现冒泡排序</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	end := <span class="built_in">len</span>(*arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; end<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; end-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> (*arr)[j] &gt; (*arr)[j+<span class="number">1</span>] &#123;</span><br><span class="line">				tmp := (*arr)[j]</span><br><span class="line">				(*arr)[j] = (*arr)[j+<span class="number">1</span>]</span><br><span class="line">				(*arr)[j+<span class="number">1</span>] = tmp</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">3</span>&#125;</span><br><span class="line">	BubbleSort(&amp;arr)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Go语言函数</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形式参数列表)</span><span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）</p>
<p>函数有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（==Don’t Repeat Yourself==），意思是执行特定任务的代码只能在程序里面出现一次）</p>
<p>==return 语句可以带有零个或多个参数==，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）</p>
<p>在函数调用时，==Go语言没有默认参数值==，也没有任何方法可以通过参数名指定形参</p>
<p>Go语言里面拥三种类型的函数：</p>
<ul>
<li>普通的带有名字的函数</li>
<li>匿名函数或者 lambda 函数</li>
<li>方法</li>
</ul>
<p>如果一组形参或返回值有相同的类型，不必为每个形参都写出参数类型，下面 2 个声明是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i, j, k <span class="keyword">int</span>, s, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>, k <span class="keyword">int</span>, s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>空白标识符<code>_</code>可以强调某个参数未被使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="keyword">int</span>, _ <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x &#125;</span><br></pre></td></tr></table></figure>
<h2 id="传值、传引用">传值、传引用</h2>
<p>Go语言中，string、int、bool、数组、stuct都属于非引用数据类型。</p>
<p>Go语言中，==指针、Slice切片、map、chan都是引用数据类型==，引用的时候也是类似指针地址</p>
<p>在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">(map1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	map1[<span class="string">"one"</span>] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(map1[<span class="string">"one"</span>])</span><br><span class="line"></span><br><span class="line">	fun(map1)</span><br><span class="line"></span><br><span class="line">	fmt.Println(map1[<span class="string">"one"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值">返回值</h2>
<p>Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToNetwork()  <span class="comment">// connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息</span></span><br></pre></td></tr></table></figure>
<p>多返回值示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typedTwoValues</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := typedTwoValues()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>带有变量名的返回值</strong></p>
<p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</p>
<p>命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。</p>
<p>下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//对两个整型返回值进行命名a和b</span></span><br><span class="line">    a = <span class="number">1</span>  <span class="comment">//对返回值进行赋值</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="comment">//当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>, <span class="keyword">int</span>)</span>  //<span class="title">error</span>:<span class="title">mixed</span> <span class="title">named</span> <span class="title">and</span> <span class="title">unnamed</span> <span class="title">function</span> <span class="title">parameters</span></span></span><br></pre></td></tr></table></figure>
<h2 id="函数变量">函数变量</h2>
<p>在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"fire"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span>  //定义函数变量</span></span><br><span class="line">    f = fire</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数">匿名函数</h2>
<p>匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;  <span class="comment">//匿名函数的定义就是没有名字的普通函数定义</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在定义时调用匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>, data)</span><br><span class="line">&#125;(<span class="number">100</span>)   <span class="comment">//&#125;后的(100)，表示对匿名函数进行调用，传递参数为 100。</span></span><br></pre></td></tr></table></figure>
<p>将匿名函数赋值给变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将匿名函数体保存到f()中</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用f()调用</span></span><br><span class="line">f(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>匿名函数用作回调函数：（类似C++里面lambda表达式的使用）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(list []<span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;  <span class="comment">//第二个参数是一个函数对象/变量</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">		f(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	visit([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包">闭包</h2>
<blockquote>
<p>闭包（Closure）在某些编程语言中也被称为 Lambda 表达式</p>
</blockquote>
<p>Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：</p>
<p>==函数 + 引用环境 = 闭包==</p>
<p>==闭包的结构很简单，一个是函数指针，另一个是对外部环境的引用==。</p>
<p>同一个函数与不同引用环境组合，可以形成不同的实例，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2021061922493066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，==函数是编译期静态的概念，而闭包是运行期动态的概念==。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello world"</span>  <span class="comment">// 准备一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str = <span class="string">"hello dude"</span>  <span class="comment">// 匿名函数中访问str, 在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行闭包，此时 str 发生修改，变为 hello dude。</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<h2 id="可变参数">可变参数</h2>
<p>如同C中printf，o语言标准库中的 fmt.Println() 等函数的实现也依赖于语言的可变参数功能</p>
<p>可变参数是指函数传入的参数个数是可变的，为了做到这点，首先需要将函数定义为可以接受可变参数的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//函数 myfunc() 接受不定数量的参数，这些参数的类型全部是 int</span></span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myfunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment">//或者myfunc(1,2)参数可变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>形如<code>...type</code>格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖（syntactic sugar）</strong>，即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。</p>
<p>从内部实现机理上来说，类型<code>...type</code>本质上是一个数组切片，也就是<code>[]type</code>，这也是为什么上面的参数 args 可以用 for 循环来获得每个传入的参数。</p>
<p>之前的例子中将可变参数类型约束为 int，如果你希望传任意类型，可以指定类型为 interface{}，下面是Go语言标准库中 fmt.Printf() 的函数原型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用 interface&#123;&#125; 传递任意类型数据是Go语言的惯例用法，使用 interface&#123;&#125; 仍然是类型安全的</span></span><br></pre></td></tr></table></figure>
<p><strong>在多个可变参数中传递参数</strong></p>
<p>可变参数变量是一个包含所有参数的切片，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加<code>...</code>，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际打印的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 遍历可变参数切片</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> rawList &#123;</span><br><span class="line">        <span class="comment">// 打印参数</span></span><br><span class="line">        fmt.Println(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印函数封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将slist可变参数切片完整传递给下一个函数</span></span><br><span class="line">    rawPrint(slist...)  <span class="comment">//----------------------------------------将切片中的元素进行传递</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="defer延迟执行">defer延迟执行</h2>
<p>Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 ==defer 的逆序进行执行==，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。</p>
<p>defer一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。</p>
<ul>
<li>代码的延迟顺序与最终的执行顺序是反向的。</li>
<li>延迟调用是在 defer 所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"defer begin"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启延迟调用栈</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">3</span>) <span class="comment">//最后一个放入, 位于栈顶, 最先调用</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"defer end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">defer</span> begin</span><br><span class="line"><span class="keyword">defer</span> end</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>使用延迟执行语句在函数退出时释放资源</strong></p>
<p>处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p>
<p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。</p>
<ul>
<li>使用defer来延迟解锁</li>
<li>使用defer来延迟释放文件句柄</li>
</ul>
<h2 id="宕机panic">宕机panic</h2>
<p>Go语言的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起宕机。</p>
<p>一般而言，当宕机发生时：</p>
<ul>
<li>程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制）</li>
<li>随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。</li>
</ul>
<p><strong>手动触发宕机</strong></p>
<p>Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以根据宕机时输出到控制台的堆栈和 goroutine 信息及时地发现错误，同时减少可能的损失。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainfunc main() &#123;    <span class="built_in">panic</span>(<span class="string">"crash"</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>painc()可以造成程序崩溃，panic函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span>    //<span class="title">panic</span><span class="params">()</span> 的参数可以是任意类型的。</span></span><br></pre></td></tr></table></figure>
<p>注意：当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用，</p>
<h2 id="宕机恢复recover">宕机恢复recover</h2>
<p>Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入panic，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p>
<p>panic 和 recover 的组合有如下特性：</p>
<ul>
<li>有 panic 没 recover，程序宕机。</li>
<li>有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li>
</ul>
<p>注意：</p>
<p>虽然 panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。</p>
<p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。</p>
<p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>
<h2 id="函数运行时间">函数运行时间</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Since</span><span class="params">(t Time)</span> <span class="title">Duration</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now() <span class="comment">//获取当前时间----------------</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line">		sum++</span><br><span class="line">	&#125;</span><br><span class="line">	elapsed := time.Since(start)  <span class="comment">//---------------------</span></span><br><span class="line">	fmt.Println(<span class="string">"该函数执行完成耗时："</span>, elapsed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since() 函数返回从 t 到现在经过的时间，等价于<code>time.Now().Sub(t)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now() <span class="comment">// --------------------获取当前时间</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line">        sum++</span><br><span class="line">    &#125;</span><br><span class="line">    elapsed := time.Now().Sub(start)  <span class="comment">//-----------------now-start = duration</span></span><br><span class="line">    fmt.Println(<span class="string">"该函数执行完成耗时："</span>, elapsed)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Go语言函数的底层实现">Go语言函数的底层实现</h2>
<p>Go语言函数使用的是 caller-save 的模式，即==由调用者负责保存寄存器==，所以在函数的头尾不会出现<code>push ebp; mov esp ebp</code>这样的代码，相反其是在==主调函数==调用被调函数的前后有一个==保存现场和恢复现场==的动作。</p>
<ul>
<li>函数的调用者负责环境准备，包括为参数和返回值开辟栈空间。</li>
<li>寄存器的保存和恢复也由调用方负责。</li>
<li>函数调用后回收栈空间，恢复 BP 也由主调函数负责。</li>
</ul>
<p>主调函数保存和恢复现场的通用逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开辟栈空间，压栈 BP 保存现场</span></span><br><span class="line">    SUBQ $x, SP    <span class="comment">//为函数开辟裁空间</span></span><br><span class="line">    MOVQ BP, y(SP) <span class="comment">//保存当前函数 BP 到 y(SP）位直， y 为相对 SP 的偏移量</span></span><br><span class="line">    LEAQ y(SP), BP <span class="comment">//重直 BP，使其指向刚刚保存 BP 旧值的位置，这里主要</span></span><br><span class="line">                   <span class="comment">//是方便后续 BP 的恢复</span></span><br><span class="line"><span class="comment">//弹出栈，恢复 BP</span></span><br><span class="line">    MOVQ y(SP), BP <span class="comment">//恢复 BP 的值为调用前的值</span></span><br><span class="line">    ADDQ $x, SP    <span class="comment">//恢复 SP 的值为函数开始时的位</span></span><br></pre></td></tr></table></figure>
<p>函数的多值返回实质上是在栈上开辟多个地址分别存放返回值，这个并没有什么特别的地方，如果返回值是存放到堆上的，则多了一个复制的动作。</p>
<p>函数调用前己经为返回值和参数分配了栈空间，分配顺序是从右向左的，先是返回值，然后是参数，通用的栈模型如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">＋----------＋</span><br><span class="line">| 返回值 y   |</span><br><span class="line">|-----------|</span><br><span class="line">| 返回值 x   |</span><br><span class="line">|-----------|</span><br><span class="line">|  参数 b    |</span><br><span class="line">|-----------|</span><br><span class="line">|  参数 a    |</span><br><span class="line">＋----------＋</span><br></pre></td></tr></table></figure>
<p>函数的多返回值是主调函数预先分配好空间来存放返回值，被调函数执行时将返回值复制到该返回位置来实现的。</p>
<h1>Test功能测试函数</h1>
<p>Go语言自带了 testing 测试包，可以进行自动化的单元测试，输出结果验证，并且可以测试性能。</p>
<p><strong>测试规则</strong></p>
<p>要开始一个单元测试，需要准备一个 go 源码文件，在命名文件时文件名必须以<code>_test.go</code>结尾，单元测试源码文件可以由多个测试用例（可以理解为函数）组成，每个测试用例的名称需要以 Test 为前缀，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestXxx</span><span class="params">( t *testing.T )</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试用例有以下几点需要注意：</p>
<ul>
<li>
<p>测试用例文件不会参与正常源码的编译，不会被包含到可执行文件中；</p>
</li>
<li>
<p>测试用例的文件名必须以<code>_test.go</code>结尾；</p>
</li>
<li>
<p>需要使用 import 导入 testing 包；</p>
</li>
<li>
<p>测试函数的名称要以<code>Test</code>或<code>Benchmark</code>开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；</p>
</li>
<li>
<p>单元测试则以<code>(t *testing.T)</code>作为参数，性能测试以<code>(t *testing.B)</code>做为参数；</p>
</li>
<li>
<p>测试用例文件使用<code>go test</code>命令来执行，源码中不需要 main() 函数作为入口，所有以<code>_test.go</code>结尾的源码文件内以<code>Test</code>开头的函数都会自动执行。</p>
</li>
</ul>
<p>Go语言的 testing 包提供了三种测试方式，分别是单元（功能）测试、性能（压力）测试和覆盖率测试。</p>
<p><strong>单元（功能）测试</strong></p>
<p>在同一文件夹下创建两个Go语言文件，分别命名为 demo.go 和 demt_test.go，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210619225010639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>性能（压力）测试</strong></p>
<p>将 demo_test.go 的代码改造成如右边所示的样子：</p>
<p><img src="https://img-blog.csdnimg.cn/20210619225037294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>覆盖率测试</strong></p>
<p>覆盖率测试能知道测试程序总共覆盖了多少业务代码（也就是 demo_test.go 中测试了多少 demo.go 中的代码），可以的话最好是覆盖100%。</p>
<p>将 demo_test.go 代码改造成如右边所示的样子：</p>
<p><img src="https://img-blog.csdnimg.cn/20210619225051708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aWZhZ3VhbmdkZW1hbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1>附录：</h1>
<h1>Go标准库</h1>
<p>Go语言的标准库以包的方式提供支持，下表列出了Go语言标准库中常见的包及其功能。</p>
<table>
<thead>
<tr>
<th>Go语言标准库包名</th>
<th>功  能</th>
</tr>
</thead>
<tbody>
<tr>
<td>bufio</td>
<td>带缓冲的 I/O 操作</td>
</tr>
<tr>
<td>bytes</td>
<td>实现字节操作</td>
</tr>
<tr>
<td>container</td>
<td>封装堆、列表和环形列表等容器</td>
</tr>
<tr>
<td>crypto</td>
<td>加密算法</td>
</tr>
<tr>
<td>database</td>
<td>数据库驱动和接口</td>
</tr>
<tr>
<td>debug</td>
<td>各种调试文件格式访问及调试功能</td>
</tr>
<tr>
<td>encoding</td>
<td>常见算法如 JSON、XML、Base64 等</td>
</tr>
<tr>
<td>flag</td>
<td>命令行解析</td>
</tr>
<tr>
<td>fmt</td>
<td>格式化操作</td>
</tr>
<tr>
<td>go</td>
<td>Go语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改</td>
</tr>
<tr>
<td>html</td>
<td>HTML 转义及模板系统</td>
</tr>
<tr>
<td>image</td>
<td>常见图形格式的访问及生成</td>
</tr>
<tr>
<td>io</td>
<td>实现 I/O 原始访问接口及访问封装</td>
</tr>
<tr>
<td>math</td>
<td>数学库</td>
</tr>
<tr>
<td>net</td>
<td>网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等</td>
</tr>
<tr>
<td>os</td>
<td>操作系统平台不依赖平台操作封装</td>
</tr>
<tr>
<td>path</td>
<td>兼容各操作系统的路径操作实用函数</td>
</tr>
<tr>
<td>plugin</td>
<td>Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载</td>
</tr>
<tr>
<td>reflect</td>
<td>语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值</td>
</tr>
<tr>
<td>regexp</td>
<td>正则表达式封装</td>
</tr>
<tr>
<td>runtime</td>
<td>运行时接口</td>
</tr>
<tr>
<td>sort</td>
<td>排序接口</td>
</tr>
<tr>
<td>strings</td>
<td>字符串转换、解析及实用函数</td>
</tr>
<tr>
<td>time</td>
<td>时间接口</td>
</tr>
<tr>
<td>text</td>
<td>文本模板及 Token 词法器</td>
</tr>
</tbody>
</table>
<h1>使用代理</h1>
<p><strong>VSCode插件、go官网有的东西安装失败，使用代理</strong></p>
<ul>
<li>go env -w GO111MODULE=on</li>
<li>go env -w GOPROXY=https://goproxy.io,direct</li>
</ul>
<h1>参考文献</h1>
<blockquote>
<p><a href="https://tour.studygolang.com/gopl-zh/" target="_blank" rel="noopener">Go语言圣经 | 中文版</a><br>
<a href="http://c.biancheng.net/golang/" target="_blank" rel="noopener">Go语言入门教程</a><br>
<a href="https://tour.studygolang.com/" target="_blank" rel="noopener">Go语言中文社区</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">WangGarrison</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://wanggarrison.top/2021/06/19/Golang%EF%BC%9A%E7%AE%80%E4%BB%8B%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81defer%E3%80%81Test%E5%8A%9F%E8%83%BD/">http://wanggarrison.top/2021/06/19/Golang：简介、基本语法、函数、defer、Test功能/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_email"></a><a class="a2a_dd" href="https://www.addtoany.com/share" target="_blank" rel="noopener"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2021/02/03/Linux%EF%BC%9AI-O%E5%A4%8D%E7%94%A8%E2%80%94%E2%80%94poll%E3%80%81epoll/"><img class="next_cover" src="/img/1index-bg.png" onerror="onerror=null;src='/img/1index-bg.png'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Linux：I-O复用——poll、epoll</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'wRBaqYsEc12U7sIngUG9fsqw-gzGzoHsz',
  appKey: 'W8z4NsMU9uPUGmvT4k38nLwV',
  notify: false,
  verify: false,
  placeholder: '留言支持MarkDown语法...',
  avatar: 'retro',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(/img/1index-bg.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By WangGarrison</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/"});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>